<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../ti-widget-common/ti-widget-image.html">
<link rel="import" href="../ti-widget-common/ti-widget-droplist.html">
<link rel="import" href="../ti-widget-common/ti-widget-label.html">
<link rel="import" href="../ti-widget-common/ti-widget-panel.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../ti-widget-propertygrid/ti-widget-propertygrid.html">
<link rel="import" href="../core-icon-button/core-icon-button.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../core-tooltip/core-tooltip.html">
<link rel="import" href="../core-icons/core-icons.html">
<link rel="import" href="../core-icon/core-icon.html">
<polymer-element name="ti-guicomposer-installer">

    <template id="newinstallerwizard" >
        <style>
            paper-dialog {
                overflow-wrap: break-word;
                white-space:nowrap;
                margin: 0;
                padding: 0;
            }
        </style>

        <paper-dialog id="paper_dialog" heading="Installer Wizard" transition="paper-dialog-transition" autoCloseDisabled="true" style="background-color: white; ">

            <div align="center">
                <ti-widget-propertygrid style="width:600px" colwidthproperty="200" colwidthvalue="400"
                                        id="installerPropertyGrid"></ti-widget-propertygrid>

            </div>
            <div  align="center" style="padding-left:80px;">
                <paper-button id="buttonCreateInstaller" on-click="{{onCreateButtonClickedHdlr}}" style="padding-top:3px;">Create Installer</paper-button>
                <paper-button id="buttonCancel" on-click="{{toggle}}" style="float:right">Close<core-icon icon="close" style="width:18px;" ></core-icon></paper-button>
            </div>
            <div align="left" style="padding:0px;" >
                <core-icon id="warningIcon" icon="info" style="display:none;color:darkorange;width:20px" ></core-icon>
                <ti-widget-label id="statusLabel" style="color:black;" wrap label="status info here."></ti-widget-label>
            </div>
        </paper-dialog>
    </template>


    <!-- ------------------------------------------------------------------------------------- -->
    <script>



        Polymer ('ti-guicomposer-installer', {
            statusLabel: undefined,
            warningIcon: undefined,
            gui: undefined,
            win: undefined,
            path: undefined,
            fs: undefined,
            archiver: undefined,
            _myTimeout: undefined,
            spawn: undefined,
            exec: undefined,
            isWizardOpen: false,
            installerXmlFileLines: undefined,
            properties: undefined,
            workingDir: undefined,
            baseDir: undefined,
            designerDir: undefined,
            designerSplashDir: undefined,
            exportFolder: undefined,
            installerComponentFolder: undefined,
            projectName: undefined,
            projectDir: undefined,
            applicationName: undefined,
            projectInstallerDir: undefined,
            projectZipFilename: undefined,
            installerFilename: undefined,
            patcherFilename: undefined,
            zippedProject: undefined,
            gcruntimeVersion: '2.0.0.0',
            propertyNameValues: "Application Name,name used when installing the application,"+
            "Folder to save installer in,[folder-open]{{#exportInstallerDialog}}path to folder",
            toggle: function(transition){
                if (this._myTimeout) {
                    window.clearTimeout(this._myTimeout);
                }
                var dialog = this.$.paper_dialog;
                this.clearStatus();
                if ((localStorage !== undefined)&&(localStorage !== null)){
                    var folderRow = this.$.installerPropertyGrid.findRow('Folder');
                    if (folderRow >= 0) {
                        if (localStorage.exportFolder !== undefined) {
                            this.$.installerPropertyGrid.setValue(folderRow, localStorage.exportFolder);
                        } else {
                            if (this.projectInstallerDir !== undefined) {
                                this.$.installerPropertyGrid.setValue(folderRow, this.projectInstallerDir);
                            }
                        }
                    }
                }
                this.isWizardOpen = !this.isWizardOpen;
                if (this.isWizardOpen){

                    this.setDefaultProperties();
                }
                dialog.toggle(transition);

            },
            _clearStatus: function(){
                this.warningIcon.style.display = 'none';
                this.warningIcon.style.color='blue';
                this.warningIcon.icon=' ';
                this.statusLabel.style.display = 'none';
                this.statusLabel.style.color = 'black';
                this.statusLabel.innerHtml = '';
            },
            clearStatus: undefined,
            onCreateButtonClickedHdlr: function(){
                var _self = this;
                try {
                    this.generateInstaller('win32');
                } catch(e) {
                    var errMsg = e.toString();
                    console.log(errMsg);
                    this.notifyUser("error", "red", errMsg, "red");
                    this.cleanUpBaseDir();
                }
            },
            onOpenFileDialog: function(){
                this.chooseFile('#openOutFileDialog');
            },
            readInstallerPropertyValue: function(propertyName){
                var result = "";
                this.readInstallerXmlFile();

                var lcPropertyName = propertyName.toLowerCase();
                for (var i = 0; i < this.installerXmlFileLines.length; i++) {
                    var line = this.installerXmlFileLines[i].trim();
                    var startIndex = line.indexOf("<"+lcPropertyName+">");
                    var endIndex = 0;
                    if (startIndex === 0) {
                        endIndex = line.indexOf("</"+lcPropertyName+">")
                        if (endIndex > 0) {
                            result = line.substring(startIndex + 13, endIndex);
                            break;
                        }
                    }
                }
                return result;
            },
            writeInstallerPropertyValue: function(propertyName,propertyValue,commitToFile){
                var result = "";
                if ((this.installerXmlFileLines !== undefined) && (this.installerXmlFileLines !== null) && (this.installerXmlFileLines.length > 0) ){
                    var lcPropertyName = propertyName.toLowerCase();
                    for (var i = 0; i < this.installerXmlFileLines.length; i++) {
                        var line = this.installerXmlFileLines[i];
                        var startIndex = line.indexOf("<"+lcPropertyName+">");
                        if (startIndex >= 0) {
                            var indentStr = "";
                            for (var n=0;n<startIndex;n++){
                                indentStr += " ";
                            }
                            this.installerXmlFileLines[i] = indentStr+"<"+lcPropertyName+">"+propertyValue+"</"+lcPropertyName+">";
                        }
                    }
                    if (commitToFile) {
                        this.writeInstallerXmlFile();
                    }
                }
            },
            readInstallerXmlFile: function() {
                var result = "";
                try {
                    var xmlFileName = this.path.join(document.gcGlobal.projectFolder, "installer/installer.xml");
                    this.installerXmlFileLines = fs.readFileSync(xmlFileName).toString().split("\n");
                    result = this.installerXmlFileLines;
                }
                catch(ex){
                    console.log("Exception reading installer.xml file: ex="+ex.toString());
                }
                return result;
            },
            writeInstallerXmlFile: function() {
                try {
                    var xmlFileName = this.path.join(document.gcGlobal.projectFolder, "installer/installer.xml");
                    fs.writeFileSync(xmlFileName,this.installerXmlFileLines.join("\n") , 'utf-8');
                }
                catch(ex){
                    console.log("Exception reading installer.xml file: ex="+ex.toString());
                }
            },
            _setDefaultProperties: function(){
                this.applicationName = this.readInstallerPropertyValue("application");
                if (this.applicationName.indexOf(":") >= 0){
                    this.applicationName = this.applicationName.replace(':','-');
                }
                if (this.applicationName.length > 0){
                    var appNameRow = this.$.installerPropertyGrid.findRow('Application Name');
                    if (appNameRow >= 0) {
                        this.$.installerPropertyGrid.setValue(appNameRow, this.applicationName);
                    }
                }
            },
            setDefaultProperties: undefined,
            _generateInstaller: function(os){
                //TODO: add support for mac and linux
                // disable the close button so that user's don't close the dialog
                // before the first status message is displayed
                this.$.buttonCancel.disabled = true;
                this.projectName = document.gcGlobal.projectName;
                this.projectDir = document.gcGlobal.projectFolder;
                this.projectInstallerDir = this.path.join(this.projectDir,'installer');
                this.properties = this.$.installerPropertyGrid.getJSON();

                var userApplicationName = this.properties[0].value;
                if ((userApplicationName !== null)&&(userApplicationName.length > 0)) {
                    this.applicationName = userApplicationName;
                    this.writeInstallerPropertyValue("application",userApplicationName,true);
                }
                this.exportFolder = this.properties[1].value;
                if ((this.exportFolder !== undefined) && (this.exportFolder !== null) && (this.exportFolder.trim().length > 0)){
                    this.exportFolder = this.path.normalize(this.exportFolder);
                    this.exportFolder = this.unescapeUnicode(this.exportFolder);
                } else {
                    this.exportFolder = this.projectInstallerDir;
                }

                if ((localStorage !== undefined)&&(localStorage !== null)) {
                    localStorage.exportFolder = this.exportFolder;
                }

                var appInstallerName;
                var appInstallerNameWithVersion;
                var gcrVersionShort = this.gcruntimeVersion.substring(0,this.gcruntimeVersion.lastIndexOf("."));
                var appVersion = this.readInstallerPropertyValue('app_version');
                var appVersionShort = appVersion.substring(0,appVersion.lastIndexOf("."));
                if (this.projectDir === this.designerDir) {
                    appInstallerName = 'GUIComposerDesigner-2.0.0.setup-win.exe';
                } else {
                    appInstallerName = 'GUIComposerApp-2.0.0.setup-win.exe';
                }
                appInstallerNameWithVersion = appInstallerName.replace('2.0.0',appVersionShort);
                // Append the 3 digit GUI Composer Runtime version ID to the appInstaller name
                // (used by the installer to quickly check whether the correct runtime version is installed or not)
                appInstallerNameWithVersion = appInstallerNameWithVersion.substring(0,appInstallerNameWithVersion.indexOf(".exe"))+'_'+gcrVersionShort+".exe";
                console.log("ti-guicomposer-installer: installer name = "+appInstallerNameWithVersion);
                this.installerAppFilename = this.path.join(this.installerComponentFolder,appInstallerName);
                this.installerAppCopyFilename = this.path.join(this.baseDir,appInstallerNameWithVersion );

                try {


                    if ((this.applicationName === undefined) || (this.applicationName === null)){
                        if (this.projectDir === this.designerDir){
                            this.applicationName = "GUI Composer Designer";
                        } else{
                            this.applicationName = "TODO - please give this application a name"
                        }
                    }

                    // save the zip file containing all of the project files in the base gui composer runtime folder
                    // This avoids the scenario where the zip file output is being generated into a folder that is itself
                    // being zipped up
                    this.projectZipFilename = this.path.join(this.baseDir, this.applicationName + '.zip');

                    console.log("ti-guicomposer-installer: projectZipFileName="+this.projectZipFilename);
                    var shortInstallerFilename = this.projectName + '_installer.zip';
                    this.installerFilename = this.path.join(this.exportFolder, shortInstallerFilename);
                    this.cleanUpBaseDir(true, false);
                    var _self = this;
                    if ((!this.projectName) || (this.projectName.length === 0)) {
                        this.projectName = "designer";
                        this.projectDir = this.designerDir;
                    }
                    if ((!this.projectDir) || (!this.fs.existsSync(this.projectDir))) {
                        alert("Invalid project directory (" + this.projectDir + ')');
                    } else {
                        if (this.projectName === 'designer') {
                            this.notifyUser("info", "blue", "Zipping up project contents.  Please wait...", "black")
                        } else {
                            this.notifyUser("info", "blue", "Copying components into project.  Please wait...", "black");
                        }
                        window.setTimeout(function () {
                            _self.updateProject();
                        }, 50);  // give time for notification to be displayed

                    }
                }
                catch(ex0){
                    var ex0Msg = 'Exception in generateInstaller: ex=' + ex0.toString();
                    console.log(ex0Msg);
                    this.notifyUser("error", "red", ex0Msg, "red");
                    this.cleanUpBaseDir();
                }
            },
            generateInstaller: undefined,
            _getSkipFolderLists: function(projectFolder){
                // The skipFolderLists are used by copyRecursiveSync to identify folders that are not to be copied
                // into the destination directory.
                //
                // Each level of the components folder has it's own array of entry names that it can
                // specify to be skipped when copying over the components folder into the project to be installed.
                // e.g. the second array specifies all of the folders within folders to be skipped, so for example
                // any subfolders named tests, test, docs, etc will not be copied over.
                var skipFolderLists = [null,
                    [ 'polymer-test-tools', 'github', 'github-elements','core-component-page','core-elements','ti-core-component-page',
                        'ti-guicomposer-newcomponentwizard', 'ti-guicomposer-installer','inspector-elements',
                        'ti-guicomposer-elements','ti-app-elements','ti-guicomposer-helpindex','ti-guicomposer-newtemplatewizard',
                        'ti-guicomposer-newprojectwizard', 'ti-guicomposer-quickstart'],
                    ['tests', 'test', 'docs', 'demos', 'demo', 'examples', 'example']];

                // Remove any large components that are not used in the project
                var projectFilesObj = JSON.parse(fs.readFileSync(this.path.join(projectFolder,'bower.json'), 'utf8'));
                var checkList = ['core-list','ti-core-mqtt-model','ti-service-programloader','ti-widget-graphs',
                    'ti-widget-dial','ti-widget-analoggauge','code-mirror','ace-element','ti-widget-registerview',
                    'ti-widget-registerviewer-drawer','ti-widget-filesview','ti-widget-propertygrid',
                    'ti-widget-colorwheel','sampler-scaffold'];
                var notFoundList = [];
                if (projectFilesObj.componentfolders !== undefined) {
                    for (var i = 0; i < checkList.length; i++) {
                        if (!projectFilesObj.componentfolders[checkList[i]]) {
                            notFoundList.push(checkList[i]);
                        }
                    }
                    if (notFoundList.length > 0) {
                        skipFolderLists[1] = skipFolderLists[1].concat(notFoundList);
                    }
                }
                return skipFolderLists;
            },
            getSkipFolderLists: undefined,
            _updateProject: function(){
                try {
                    var skipFolderLists = null;
                    // Don't have to copy over the components folder etc. fo the designer as the original
                    // files in this directory will all be used directly when creating the zip file for the installer.
                    if (this.projectName !== 'designer') {
                        skipFolderLists = this.getSkipFolderLists(this.projectDir);

                        var useLinks = true;
                        var componentsDir = this.path.join(this.projectDir, 'components');
                        var designerComponentsDir = this.path.join(this.designerDir, 'components');
                        if (this.fs.existsSync(componentsDir)) {
                            this.deleteFolderRecursiveSync(componentsDir);
                        }
                        this.copyRecursiveSync(designerComponentsDir, componentsDir, useLinks, skipFolderLists, 0);

                        // Update the project's index.html file to reference the components folder in the project directory
                        var indexHtmlPath = this.path.join(this.projectDir, "index.html");
                        var indexHtml = this.fs.readFileSync(indexHtmlPath, 'utf8');
                        while (indexHtml.indexOf("=\"../designer/components/") > -1) {
                            indexHtml = indexHtml.replace("=\"../designer/components/", "=\"components/");
                        }
                        this.fs.writeFileSync(indexHtmlPath, indexHtml);
                    }
                    this.zippedProject = this.archiver('zip');
                    this.notifyUser("info", "blue", "Zipping up project contents.  Please wait...", "black")

                    var output = this.fs.createWriteStream(this.projectZipFilename);
                    var _self = this;
                    output.on('close', function () {
                        _self.notifyUser("info", "blue", "Patching installer to make it project-specific...", "black");
                        console.log('done with the zip', _self.projectZipFilename);
                        // Now that the project folder has been zipped up and stored in the base directory,
                        // patch the application installer with application-specific info.
                        // Once that has completed, call the patchExeCallback function to zip up the
                        // project.zip and the application installer into a single zip file.
                        try {
                            _self.patchExe(_self.projectName,_self.patchExeCallback);
                        }
                        catch (ex) {
                            var errMsg = 'Exception trying to execute patchExe: ex=' + ex.toString();
                            console.log(errMsg);
                            _self.notifyUser("error", "red", errMsg, "red");
                            _self.cleanUpBaseDir();
                        }
                    });
                    this.zippedProject.pipe(output);
                    // zip up the project folder including all of its contents, listing the relative path starting
                    // with the project folder's name.

                    this.zippedProject.bulk([
                        {src: [this.projectName + '**/**/*'], cwd: this.baseDir, expand: true}
                    ]);

                    this.zippedProject.finalize(function (err, bytes) {

                        if (err) {
                            _self.notifyUser("error", "red", err, "red");
                            _self.cleanUpBaseDir();
                            throw err;
                        }

                        console.log('first zip file finalized.', bytes);

                    });
                    /*
                     patcher-windows.exe --splashImage <fullpath to splash screen png>
                     --leftImage <full path to png that shows up on the left side of the installer>
                     --licenseFile <full path to the license txt file>
                     -wmImage <image that shows up in the windows manager task bar>
                     --logoImage <image on the top right corner>
                     --fullName <full name of the application for shortcuts etc.> gcapplication-1.0-windows-installer.exe
                     */
                    /*
                     this.patchExe(function(err,returnStr){
                     if (err){
                     console.log("error patching gcapplication-1.0-windows-installer.exe :"+returnStr);
                     } else {
                     console.log("success patching gcapplication-1.0-windows-installer.exe :"+returnStr);
                     _self.installerZip = new zip();
                     _self.installerZip.addLocalFile(_self.projectZipFilename,_self.installerFilename);
                     }
                     });
                     */
                }
                catch(ex){
                    var exMsg = 'Exception in updateProject: ex=' + ex.toString();
                    console.log(exMsg);
                    this.notifyUser("error", "red", exMsg, "red");
                }

            },
            updateProject: undefined,
            _patchExe: function(projectName,initComplete) {
                // patch the application installer with application-specific info.
                //TODO: check that all of these files exist before starting the installation procedure
                // :Usage: patcher
                // ?--logoImage logo.png?
                // ?--wmImage wmImage.png?
                // ?--splashImage splash.png?
                // ?--leftImage left.png?
                // ?--fullName fullName?
                // ?--licenseFile license.txt?
                // installer-file
                var installDirPath = this.path.normalize(this.projectInstallerDir);
                installDirPath = this.unescapeUnicode(installDirPath);
                var patcherFilePath = this.path.normalize(this.patcherFilename);
                patcherFilePath = this.unescapeUnicode(patcherFilePath);
               if (projectName !== 'designer') {

                   var cmdStr = '"' + patcherFilePath + '" ' +
                           ' --wmImage "' + this.path.join(installDirPath, 'gui_icon.png') + '" ' +
                           ' --logoImage "' + this.path.join(installDirPath, 'gui_icon.png') + '" ' +
                           ' --splashImage "' + this.path.join(installDirPath, 'banner.png') + '" ' +
                           ' --leftImage "' + this.path.join(installDirPath, 'leftImage.png') + '" ' +
                           ' --fullName "' + this.applicationName + '" ' +
                           ' --licenseFile "' + this.path.join(installDirPath, 'license.txt') + '" ' +
                           ' "' + this.installerAppFilename + '" ';
                   console.log("patcher cmdStr = " + cmdStr);
                   var _self = this;
                   var lp = this.exec(cmdStr, function (err, stdout, stderr) {
                       if (err) {
                           _self.notifyUser("error", "red", err, "red");
                           _self.cleanUpBaseDir();
                       }
                       else {
                           console.log('patcher.exe completed ok');
                           if (initComplete) {
                               initComplete(null, "ok");
                           } else {
                               _self._patchExeCallback(null, "ok");
                           }
                       }
                   });
               } else {
                   this._patchExeCallback(null, "ok");
               }
            },
            patchExe: undefined,
            _patchExeCallback: function(err,returnStr){
                var _self = this;
                if (err){
                    var errMsg = "Error patching "+this.path.basename(this.installerAppFilename)+" :"+returnStr;
                    this.notifyUser("error","red",errMsg,"red");
                } else {
                    console.log("Success patching "+this.path.basename(this.installerAppFilename)+" :"+returnStr);
                    this.notifyUser("info","blue","Zipping up project.zip and installer.exe into one zip file...","black");
                    // copy the gcapplication-1.0-windows-installer.exe file into the base directory
                    // so that it can be easily zipped up into the same archive as the project.zip file.
                    var ok = false;
                    try {
                        // remove the old copy of the file if it was not completely removed before
                        if (this.fs.existsSync(this.installerAppCopyFilename)) {
                            this.fs.unlinkSync(this.installerAppCopyFilename);
                        }

                        //copy the installer app .exe into the base directory
                        this.copyFileSync(this.installerAppFilename, this.installerAppCopyFilename);
                        ok = true;
                    }
                    catch(ex2){
                        var ex2Msg = "Exception trying to copy over files! ex="+ex2.toString();
                        console.log(ex2Msg);
                        _self.notifyUser("error","red",ex2Msg,"red");
                    }
                    if (ok) {
                        this.installerZip = this.archiver('zip');
                        var output2 = this.fs.createWriteStream(this.installerFilename);
                        output2.on('close', function () {
                            console.log('done with the zip', _self.installerFilename);
                            // clean up by deleting the installer app .exe and project .zip from the base directory
                            try {
                                _self.cleanUpBaseDir(false,true);
                            }
                            catch(ex3){
                                var ex3Msg = 'Exception trying to clean up base dir and notify user. ex='+ex3.toString();
                                console.log(ex3Msg);

                                _self.notifyUser("error","red",ex3Msg,"red");
                            }
                        });
                        this.installerZip.pipe(output2);
                        // zip up two files: the zip file containing the project folder and the
                        // GUIComposerAppr-2.0.0-windowstaller_<gcr3digitVersion>.exe file (for apps) or the
                        // GUIComposerDesigner-2.0.0-windowstaller.exe (for the designer)
                        // and store these into a new zip file back in the base folder for the runtime.
                        this.installerZip.bulk([
                            {src: ['{GUI*.exe,*.zip}'], cwd: this.baseDir, expand: true}
                        ]);
                        var _self = this;
                        this.installerZip.finalize(function (err, bytes) {

                            if (err) {
                                _self.notifyUser("error","red",err,"red");
                                _self.cleanUpBaseDir();
                                throw err;
                            }

                            console.log('done:' + _self.installerFilename, bytes);

                        });
                    }

                }
            },
            patchExeCallback: undefined,
            _cleanUpBaseDir: function(removeInstallerZipFile,notifyUserOfSuccess){
                // clean up by deleting the installer app .exe and project .zip from the base directory
                if ((this.installerAppCopyFilename)&&
                        (this.fs.existsSync(this.installerAppCopyFilename))) {
                    this.fs.unlinkSync(this.installerAppCopyFilename);
                }
                if ((this.projectZipFilename) &&
                        (this.fs.existsSync(this.projectZipFilename))) {
                    this.fs.unlinkSync(this.projectZipFilename);
                }
                if (removeInstallerZipFile){
                    if ((this.installerFilename) &&
                            (this.fs.existsSync(this.installerFilename))) {
                        this.fs.unlinkSync(this.installerFilename);
                    }
                }
                if (this.projectName !== 'designer') {
                    // Remove the generated components folder to keep disk space footprint low
                    var componentsDir = this.path.join(this.projectDir, 'components');
                    if (this.fs.existsSync(componentsDir)) {
                        this.deleteFolderRecursiveSync(componentsDir);
                    }
                }
                // Restore the project's index.html file to reference the components folder in the designer directory
                var indexHtmlPath = this.path.join(this.projectDir, "index.html");
                var indexHtml = this.fs.readFileSync(indexHtmlPath, 'utf8');
                while (indexHtml.indexOf("=\"components/") > -1) {
                    indexHtml = indexHtml.replace("=\"components/","=\"../designer/components/");
                }
                this.fs.writeFileSync(indexHtmlPath, indexHtml);

                if (notifyUserOfSuccess) {
                    // Tell the user we're done!
                    var msgText = this.path.basename(this.installerFilename)+' created successfully!'
                    this.notifyUser("check-circle","green",msgText,"black")
                    // close the dialog automatically in 1 second
                    var _self = this;
                    this._myTimeout = window.setTimeout(function(){
                        _self.openExplorer();
                        _self.toggle();
                    },1800);
                }
            },
            cleanUpBaseDir: undefined,
            _notifyUser: function(iconName,iconColor, msgText, textColor){
                var _self = this;
                console.log("ti-guicomposer-installer "+iconName+': '+msgText);
                this.async(function() {
                    if (_self.statusLabel) {

                        if ((msgText !== undefined) && (msgText !== null)) {
                            _self.statusLabel.style.color = textColor;
                            _self.statusLabel.label = msgText;
                            _self.statusLabel.style.display = '';
                        } else {
                            _self.statusLabel.style.display = 'none';
                        }
                        if (iconName) {
                            _self.warningIcon.style.color = iconColor;
                            _self.warningIcon.icon = iconName;
                            _self.warningIcon.style.display = '';
                        } else {
                            _self.warningIcon.style.display = 'none';
                        }
                    }
                    if (_self.$.buttonCancel.disabled){
                        if ((iconColor === 'red')||(iconColor === 'green')){
                            _self.$.buttonCancel.disabled = false;
                        }
                    }
                });
            },
            notifyUser: undefined,
            getOS: function(){
                var os = 'linux';
                if (navigator.appVersion.indexOf("Mac") != -1)
                    os = 'osx';
                if (navigator.appVersion.indexOf("Win") != -1)
                    os = 'win';
                return os;
            },
            _openExplorer: function(){

                if (this.getOS() === 'win') {
                    var folderPath = path.normalize(this.exportFolder);
                    var command = 'explorer "' + this.unescapeUnicode(folderPath) + '"';
                    try {
                        this.exec(command);
                    }
                    catch (ex) {
                        console.log('ti-guicomposer-installer: Exception while opening explorer: ex=' + ex.toString());
                    }
                }
                // TODO: add support for other OSes
            },
            openExplorer: undefined,
            _copyFileSync: function(src,dest){
                // see http://stackoverflow.com/questions/19268723/nodejs-with-child-process-how-to-escape-my-command
                try {
                    var buffer = this.fs.readFileSync(src, buffer);
                    if (buffer.length > 0) {
                        this.fs.writeFileSync(dest, buffer);
                    } else {
                        throw "attempted to copy an empty file: " + src;
                    }
                    //              this.execSync('xcopy "'+src+'" "'+dest+'" /y /i');
                }
                catch(ex){
                    throw "error copying file "+src+" ex="+ex.toString();
                }
            },
            copyFileSync: undefined,
            /**
             *   if useLinks parameter is true, the files are linked using fs.linkSync instead of copying them.
             *   This uses much less memory and time than synchronously copying over the files.
             *   However, all changes made to the file in either the source or destination folder
             *   will be seen in both folders (subject to cacheing??)
             */
            _copyRecursiveSync: function(src, dest, useLinks, skipFolderLists,levelIndex) {
                var exists = this.fs.existsSync(src);
                var stats = exists && this.fs.statSync(src);
                var isDirectory = exists && stats.isDirectory();
                var _self = this;
                if (exists && isDirectory) {
                    var dirName = this.path.basename(src);
                    var skipThisFolder = false;
                    if ((skipFolderLists !== null) && (levelIndex >= 0) && (levelIndex < skipFolderLists.length)){
                        var skipFolderList = skipFolderLists[levelIndex++];
                        if (skipFolderList !== null) {
                            for (var j = 0; j < skipFolderList.length; ++j) {
                                var skipFolderName = skipFolderList[j];
                                if (dirName === skipFolderName) {
                                    skipThisFolder = true;
                                    console.log("skipping folder ["+stats.size+"] "+src);
                                    break;
                                }
                            }
                        }
                    }
                    if (!skipThisFolder) {
                        if (!this.fs.existsSync(dest)) {
                            this.fs.mkdirSync(dest);
                        }
                        this.fs.readdirSync(src).forEach(function (childItemName) {
                            _self.copyRecursiveSync(this.path.join(src, childItemName),
                                    this.path.join(dest, childItemName), useLinks, skipFolderLists,levelIndex );
                        });
                    }
                } else {
                    if (useLinks){
                        //  fs.linkSync creates a link of the file, not an actual copy
                        //  however, this uses much less memory and time and is less prone to crashing
                        //  than attempting to do an actual streaming copy of the file.
                        this.fs.linkSync(src, dest);
                    } else {
                        _self.copyFileSync(src,dest);
                    }
                }
            },
            copyRecursiveSync:undefined,
            _deleteFolderRecursiveSync: function(folderName) {
                var files = [];
                var _self = this;
                if (this.fs.existsSync(folderName)) {
                    files = this.fs.readdirSync(folderName);
                    files.forEach(function (file, index) {
                        var curPath = folderName + "/" + file;
                        if (this.fs.lstatSync(curPath).isDirectory()) { // recurse
                            _self.deleteFolderRecursiveSync(curPath);
                        } else { // delete file
                            this.fs.unlinkSync(curPath);
                        }
                    });
                    this.fs.rmdirSync(folderName);
                }
            },
            deleteFolderRecursiveSync: undefined,
            _unescapeUnicode: function (str){
                var _self = this;
                var result = str.replace(/((%[0-9a-fA-F]{2})+)/g,
                        function(value,strToConvert) {
                            return _self.getUnicodeStr(strToConvert);
                        });
                return result;
            },
            unescapeUnicode: undefined,
            getUnicodeStr: function(str){

                var result = "";

                var hexCodesAsStrings = str.split('%');
                var hexCodes = [];
                for ( var j = 1; j < hexCodesAsStrings.length; j++){
                    hexCodes[j-1] = parseInt(hexCodesAsStrings[j],16);
                }
                var charCode = 0;
                var charCode1 = 0;
                var charCode2 = 0;
                var charCode3 = 0;
                var charCode4 = 0;
                var hexCode = 0;
                var page = 0;
                var i = 0;
                var OK = true;

                while ((i < hexCodes.length)&&(OK)) {
                    hexCode = hexCodes[i++];

                    if ((hexCode >= 0) && (hexCode <= 0x7F)){
                        charCode = hexCode;
                        result = result + String.fromCharCode(charCode);
                    } else {
                        if ((i >= hexCodes.length) ||
                                (hexCodes[i] <= 0x80) || (hexCodes[i] >= 0xBF) ) {
                            OK = false;
                        } else {
                            if ((hexCode >= 0xC0) && (hexCode <= 0xDF)) {
                                charCode2 = (hexCode & 0x1F);
                                charCode1 = hexCodes[i++] - 0x80;
                                charCode = (charCode2 << 6) | charCode1;
                                result = result + String.fromCharCode(charCode);
                            } else {
                                if ((i >= (hexCodes.length - 1)) ||
                                        (hexCodes[i]   <= 0x80) || (hexCodes[i]   >= 0xBF) ||
                                        (hexCodes[i+1] <= 0x80) || (hexCodes[i+1] >= 0xBF) ) {

                                    OK = false;
                                } else {
                                    if ((hexCode >= 0xE0) && (hexCode <= 0xEF)) {
                                        charCode3 = (hexCode & 0xF);
                                        charCode2 = hexCodes[i++] - 0x80;
                                        charCode1 = hexCodes[i++] - 0x80;
                                        charCode = (((charCode3 << 6) | charCode2) << 6) | charCode1;
                                        result = result + String.fromCharCode(charCode);

                                    } else {
                                        if ((i >= (hexCodes.length - 2)) ||
                                                (hexCodes[i]   <= 0x80) || (hexCodes[i]   >= 0xBF) ||
                                                (hexCodes[i+1] <= 0x80) || (hexCodes[i+1] >= 0xBF) ||
                                                (hexCodes[i+2] <= 0x80) || (hexCodes[i+2] >= 0xBF) ) {
                                            OK = false;
                                        } else {
                                            if ((hexCode >= 0xF0)&&(hexCode <= 0xF7)){
                                                charCode4 = (hexCode & 0x7);
                                                charCode3 = hexCodes[i++] - 0x80;
                                                charCode2 = hexCodes[i++] - 0x80;
                                                charCode1 = hexCodes[i++] - 0x80;
                                                charCode = ((((charCode4 << 6) | charCode3 << 6) | charCode2) << 6) | charCode1;
                                                result = result + String.fromCharCode(charCode);

                                            } else {

                                                OK = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                }
                if (!OK) {
                    console.log("ti-widget-filesview: failed to convert escaped path to unicode at index = "+i);
                }
                return (result);
            },
            ready: function () {
                this.gui = require('nw.gui');
                this.win = this.gui.Window.get();
                this.path = require('path');
                this.fs = require('fs');
                this.archiver = require('archiver');
                this.spawn = require("child_process").spawn;
                this.exec = require('child_process').exec;
                this.patchExe = this._patchExe.bind(this);
                this.generateInstaller = this._generateInstaller.bind(this);
                this.patchExeCallback = this._patchExeCallback.bind(this);
                this.cleanUpBaseDir = this._cleanUpBaseDir.bind(this);
                this.notifyUser = this._notifyUser.bind(this);
                this.setDefaultProperties = this._setDefaultProperties.bind(this);
                this.copyFileSync = this._copyFileSync.bind(this);
                this.copyRecursiveSync = this._copyRecursiveSync.bind(this);
                this.updateProject = this._updateProject.bind(this);
                this.deleteFolderRecursiveSync = this._deleteFolderRecursiveSync.bind(this);
                this.openExplorer = this._openExplorer.bind(this);
                this.clearStatus = this._clearStatus.bind(this);
                this.unescapeUnicode = this._unescapeUnicode.bind(this);
                this.getSkipFolderLists = this._getSkipFolderLists.bind(this);

                this.workingDir = this.path.normalize(process.cwd());
                this.designerDir = this.path.normalize(process.cwd());
                if (this.designerDir.indexOf('splash') === (this.designerDir.length-6)){
                    this.designerDir = this.path.join(this.designerDir,"..");
                }
                this.designerSplashDir = this.path.join(this.designerDir, 'splash');
                this.baseDir = this.path.join(this.designerDir,'..');

                this.installerComponentFolder = this.path.join(this.designerDir,'components/ti-guicomposer-installer');
                this.patcherFilename = this.path.join(this.installerComponentFolder,'patcher-windows.exe' );

                try {
                    var versionXml = fs.readFileSync(this.path.join(baseDir,"version.xml"),'utf8');
                    if ((versionXml !== undefined) && (versionXml !== null) && (versionXml.length > 0)){
                        this.gcruntimeVersion = versionXml.substring(versionXml.indexOf("<version>")+9,versionXml.indexOf("</version>"));
                    }
                }
                catch(ex){
                    console.log("ti-guicomposer-installer: failed to read version.xml file: ex="+ex.toString());
                }
                console.log('baseDir = '+this.baseDir);
                this.statusLabel = this.$.statusLabel;
                this.warningIcon = this.$.warningIcon;

                this.$.installerPropertyGrid.nameValuePairs=this.propertyNameValues;
                this.$.installerPropertyGrid.nameValuePairsChanged(); // avoid race condition by forcing update of propertyGrid rows with name value pairs prior to calling find

                var _self = this;
                document.querySelector('#exportInstallerDialog').addEventListener("change", function(evt) {
                    console.log("exportInstallerDialog value = "+this.value);
                    var folderRow = _self.$.installerPropertyGrid.findRow('Folder');
                    if (folderRow >= 0) {
                        _self.$.installerPropertyGrid.setValue(folderRow,this.value);
                    }

                }, false);
                // Workaround to ensure paper dialog is properly position: see https://github.com/Polymer/paper-dialog/issues/44
                this.$.paper_dialog.addEventListener("core-overlay-open-completed", function (e) {
                    setTimeout(function(){
                        //_self.$.paper_dialog.resetTargetDimensions();
                        _self.$.paper_dialog.updateTargetDimensions();
                    },400);
                });

            },
            domReady: function(){
                this.$.installerPropertyGrid.configure();
            }

        });
    </script>

</polymer-element>