<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="_u_a_r_t_8h" kind="file" language="C++">
    <compoundname>UART.h</compoundname>
    <includes local="no">stddef.h</includes>
    <includes local="no">stdint.h</includes>
    <includedby refid="_u_a_r_t_m_s_p432_8h" local="no">UARTMSP432.h</includedby>
    <includedby refid="_display_uart_8h" local="no">DisplayUart.h</includedby>
    <incdepgraph>
      <node id="302">
        <label>stdint.h</label>
      </node>
      <node id="301">
        <label>stddef.h</label>
      </node>
      <node id="300">
        <label>UART.h</label>
        <link refid="_u_a_r_t_8h"/>
        <childnode refid="301" relation="include">
        </childnode>
        <childnode refid="302" relation="include">
        </childnode>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="305">
        <label>DisplayUart.h</label>
        <link refid="_display_uart_8h"/>
      </node>
      <node id="303">
        <label>UART.h</label>
        <link refid="_u_a_r_t_8h"/>
        <childnode refid="304" relation="include">
        </childnode>
        <childnode refid="305" relation="include">
        </childnode>
      </node>
      <node id="304">
        <label>UARTMSP432.h</label>
        <link refid="_u_a_r_t_m_s_p432_8h"/>
      </node>
    </invincdepgraph>
    <innerclass refid="struct_u_a_r_t___params__" prot="public">UART_Params_</innerclass>
    <innerclass refid="struct_u_a_r_t___fxn_table__" prot="public">UART_FxnTable_</innerclass>
    <innerclass refid="struct_u_a_r_t___config__" prot="public">UART_Config_</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="group___u_a_r_t___c_o_n_t_r_o_l_1ga0f5a809e0884da33fef102236eb51644" prot="public" static="no">
        <name>UART_CMD_RESERVED</name>
        <initializer>(32)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Common UART_control command code reservation offset. UART driver implementations should offset command codes with UART_CMD_RESERVED growing positively</para><para>Example implementation specific command codes: <programlisting><codeline><highlight class="normal">#define<sp/>UARTXYZ_CMD_COMMAND0<sp/><sp/><sp/><sp/><sp/>UART_CMD_RESERVED<sp/>+<sp/>0</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>UARTXYZ_CMD_COMMAND1<sp/><sp/><sp/><sp/><sp/>UART_CMD_RESERVED<sp/>+<sp/>1</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="283" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="283" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___c_o_n_t_r_o_l_1ga8f35027907fbab6a9ee302d2ee52a879" prot="public" static="no">
        <name>UART_STATUS_RESERVED</name>
        <initializer>(-32)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Common UART_control status code reservation offset. UART driver implementations should offset status codes with UART_STATUS_RESERVED growing negatively.</para><para>Example implementation specific status codes: <programlisting><codeline><highlight class="normal">#define<sp/>UARTXYZ_STATUS_ERROR0<sp/><sp/><sp/><sp/>UART_STATUS_RESERVED<sp/>-<sp/>0</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>UARTXYZ_STATUS_ERROR1<sp/><sp/><sp/><sp/>UART_STATUS_RESERVED<sp/>-<sp/>1</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>UARTXYZ_STATUS_ERROR2<sp/><sp/><sp/><sp/>UART_STATUS_RESERVED<sp/>-<sp/>2</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="297" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="297" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___s_t_a_t_u_s_1ga101b7761f89b3ec49f0c6726669acfed" prot="public" static="no">
        <name>UART_STATUS_SUCCESS</name>
        <initializer>(0)</initializer>
        <briefdescription>
<para>Successful status code returned by <ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> returns UART_STATUS_SUCCESS if the control code was executed successfully. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="312" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="312" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___s_t_a_t_u_s_1ga2ae076f4aae13ca8e2aea674207df0ad" prot="public" static="no">
        <name>UART_STATUS_ERROR</name>
        <initializer>(-1)</initializer>
        <briefdescription>
<para>Generic error status code returned by <ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> returns UART_STATUS_ERROR if the control code was not executed successfully. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="320" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="320" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___s_t_a_t_u_s_1ga61125a2eb8059fd8b96ad95edc68ac2b" prot="public" static="no">
        <name>UART_STATUS_UNDEFINEDCMD</name>
        <initializer>(-2)</initializer>
        <briefdescription>
<para>An error status code returned by <ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> for undefined command codes. </para>        </briefdescription>
        <detaileddescription>
<para><ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> returns UART_STATUS_UNDEFINEDCMD if the control code is not recognized by the driver implementation. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="329" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="329" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___c_m_d_1ga942596a37cb2109ae021f88f3d907bdc" prot="public" static="no">
        <name>UART_CMD_PEEK</name>
        <initializer>(0)</initializer>
        <briefdescription>
<para>Command code used by <ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> to read the next unsigned char. </para>        </briefdescription>
        <detaileddescription>
<para>This command is used to read the next unsigned char from the UART&apos;s circular buffer without removing it. With this command code, <bold>arg</bold> is a pointer to an integer. <bold>*arg</bold> contains the next <computeroutput>unsigned</computeroutput> <computeroutput>char</computeroutput> read if data is present, else <bold>*arg</bold> is set to <ref refid="group___u_a_r_t___s_t_a_t_u_s_1ga2ae076f4aae13ca8e2aea674207df0ad" kindref="member">UART_STATUS_ERROR</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="348" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="348" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___c_m_d_1gaf5be6db621c5b048637dc93b26797693" prot="public" static="no">
        <name>UART_CMD_ISAVAILABLE</name>
        <initializer>(1)</initializer>
        <briefdescription>
<para>Command code used by <ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> to determine if the read buffer is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This command is used to determine if there are any unsigned chars available to read from the UART&apos;s circular buffer using <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref>. With this command code, <bold>arg</bold> is a pointer to a <computeroutput>bool</computeroutput>. <bold>*arg</bold> contains <computeroutput>true</computeroutput> if data is available, else <computeroutput>false</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="359" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="359" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___c_m_d_1ga470321cbd9eccf137ffbe6553ae7f35f" prot="public" static="no">
        <name>UART_CMD_GETRXCOUNT</name>
        <initializer>(2)</initializer>
        <briefdescription>
<para>Command code used by <ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> to determine how many unsigned chars are in the read buffer. </para>        </briefdescription>
        <detaileddescription>
<para>This command is used to determine how many <computeroutput>unsigned</computeroutput> <computeroutput>chars</computeroutput> are available to read from the UART&apos;s circular buffer using <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref>. With this command code, <bold>arg</bold> is a pointer to an <emphasis>integer</emphasis>. <bold>*arg</bold> contains the number of <computeroutput>unsigned</computeroutput> <computeroutput>chars</computeroutput> available to read. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="370" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="370" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___c_m_d_1gad67d01fa376f25bb28141d819647e8d3" prot="public" static="no">
        <name>UART_CMD_RXENABLE</name>
        <initializer>(3)</initializer>
        <briefdescription>
<para>Command code used by <ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> to enable data receive by the UART. </para>        </briefdescription>
        <detaileddescription>
<para>This command is used to enable the UART in such a way that it stores received unsigned chars into the circular buffer. For drivers that support power management, this typically means that the UART will set a power constraint while receive is enabled. <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> will always have this option enabled. With this command code, <bold>arg</bold> is <emphasis>don&apos;t</emphasis> <emphasis>care</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="382" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="382" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___u_a_r_t___c_m_d_1gac0b19ce2fa9f43d3fe255bcdbd3cda7b" prot="public" static="no">
        <name>UART_CMD_RXDISABLE</name>
        <initializer>(4)</initializer>
        <briefdescription>
<para>Command code used by <ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control()</ref> to disable data received by the UART. </para>        </briefdescription>
        <detaileddescription>
<para>This command is used to disable the UART in such a way that ignores the data it receives. For drivers that support power management, this typically means that the driver will release any power constraints, to permit the system to enter low power modes. With this command code, <bold>arg</bold> is <emphasis>don&apos;t</emphasis> <emphasis>care</emphasis>.</para><para><simplesect kind="warning"><para>A call to <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> does <bold>NOT</bold> re-enable receive. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="395" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="395" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="_u_a_r_t_8h_1a7e3562e7931cf51b41a32d8109072251" prot="public" static="no">
        <name>UART_ERROR</name>
        <initializer>(<ref refid="group___u_a_r_t___s_t_a_t_u_s_1ga2ae076f4aae13ca8e2aea674207df0ad" kindref="member">UART_STATUS_ERROR</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="400" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="400" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="_u_a_r_t_8h_1ada620b673241eb6335a71e75da291716" prot="public" static="no">
        <name>UART_WAIT_FOREVER</name>
        <initializer>(~(0U))</initializer>
        <briefdescription>
<para>Wait forever define. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="405" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="405" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173" prot="public" static="no">
        <name>UART_Mode_</name>
        <enumvalue id="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf" prot="public">
          <name>UART_MODE_BLOCKING</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Uses a semaphore to block while data is being sent. Context of the call must be a Task. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" prot="public">
          <name>UART_MODE_CALLBACK</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Non-blocking and will return immediately. When <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> or <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> has finished, the callback function is called from either the caller&apos;s context or from an interrupt context. </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>UART mode settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enum defines the read and write modes for the configured UART. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="430" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="430" bodyend="443"/>
      </memberdef>
      <memberdef kind="enum" id="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25f" prot="public" static="no">
        <name>UART_ReturnMode_</name>
        <enumvalue id="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa50c07cbaf7518a0acd14137e801687e5" prot="public">
          <name>UART_RETURN_FULL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Unblock/callback when buffer is full. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa3b8e419e0e12abf80b25f72d17745f76" prot="public">
          <name>UART_RETURN_NEWLINE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Unblock/callback when newline character is received. </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>UART return mode settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the return modes for <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> and <ref refid="_u_a_r_t_8h_1a3ac6ed8cfd03b84198ba6adcd8c248e6" kindref="member">UART_readPolling()</ref>. This mode only functions when in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode.</para><para><ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa50c07cbaf7518a0acd14137e801687e5" kindref="member">UART_RETURN_FULL</ref> unblocks or performs a callback when the read buffer has been filled. <ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa3b8e419e0e12abf80b25f72d17745f76" kindref="member">UART_RETURN_NEWLINE</ref> unblocks or performs a callback whenever a newline character has been received.</para><para><table rows="3" cols="3"><row>
<entry thead="yes"><para>UART operation </para></entry><entry thead="yes"><para>UART_RETURN_FULL </para></entry><entry thead="yes"><para>UART_RETURN_NEWLINE  </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> </para></entry><entry thead="no"><para>Returns when buffer is full </para></entry><entry thead="no"><para>Returns when buffer is full or newline was read </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> </para></entry><entry thead="no"><para>Sends data as is </para></entry><entry thead="no"><para>Sends data with an additional newline at the end </para></entry></row>
</table>
<simplesect kind="pre"><para>UART driver must be used in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="463" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="463" bodyend="469"/>
      </memberdef>
      <memberdef kind="enum" id="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9" prot="public" static="no">
        <name>UART_DataMode_</name>
        <enumvalue id="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8" prot="public">
          <name>UART_DATA_BINARY</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Data is not processed </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" prot="public">
          <name>UART_DATA_TEXT</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Data is processed according to above </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>UART data mode settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the data mode for reads and writes.</para><para>In <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8" kindref="member">UART_DATA_BINARY</ref>, data is passed as is, with no processing.</para><para>In <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode, the driver will examine the <ref refid="_u_a_r_t_8h_1ad7e89f8faac3d6d04a1de1328c77d360" kindref="member">UART_ReturnMode</ref> value, to determine whether or not to unblock/callback when a newline is received. Read actions replace a carriage return with a newline, and write actions add a carriage return before a newline. This effectively treats all device line endings as LF, and all host PC line endings as CRLF. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="485" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="485" bodyend="488"/>
      </memberdef>
      <memberdef kind="enum" id="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83c" prot="public" static="no">
        <name>UART_Echo_</name>
        <enumvalue id="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca2b286f182793d4a71bdf99409b9600dd" prot="public">
          <name>UART_ECHO_OFF</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Data is not echoed </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca6c4d8a2d4e30c22cf9fa45cd1bf79306" prot="public">
          <name>UART_ECHO_ON</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Data is echoed </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>UART echo settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines if the driver will echo data when uses in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode. This only applies to data received by the UART.</para><para><ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca6c4d8a2d4e30c22cf9fa45cd1bf79306" kindref="member">UART_ECHO_ON</ref> will echo back characters it received while in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode. <ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca2b286f182793d4a71bdf99409b9600dd" kindref="member">UART_ECHO_OFF</ref> will not echo back characters it received in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode.</para><para><simplesect kind="pre"><para>UART driver must be used in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="503" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="503" bodyend="506"/>
      </memberdef>
      <memberdef kind="enum" id="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062" prot="public" static="no">
        <name>UART_LEN_</name>
        <enumvalue id="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a27d04dd1fa818f764eb9b8e849feb7ff" prot="public">
          <name>UART_LEN_5</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Data length is 5 bits </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a5bfd5507335d394d826e560930ce2a12" prot="public">
          <name>UART_LEN_6</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Data length is 6 bits </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a2ac8467047f55cc1954388bf94c72e35" prot="public">
          <name>UART_LEN_7</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Data length is 7 bits </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a31abbaaeaa38a5c66fbe13bfc8ece221" prot="public">
          <name>UART_LEN_8</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Data length is 8 bits </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>UART data length settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the UART data lengths. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="513" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="513" bodyend="518"/>
      </memberdef>
      <memberdef kind="enum" id="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34" prot="public" static="no">
        <name>UART_STOP_</name>
        <enumvalue id="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34a9bfa599e95c5da9cfe5f964dab8a9c6c" prot="public">
          <name>UART_STOP_ONE</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>One stop bit </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34a3f41137f3775e7d33fdb250471c0248e" prot="public">
          <name>UART_STOP_TWO</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Two stop bits </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>UART stop bit settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the UART stop bits. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="525" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="525" bodyend="528"/>
      </memberdef>
      <memberdef kind="enum" id="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfda" prot="public" static="no">
        <name>UART_PAR_</name>
        <enumvalue id="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa469955a283c95f261990ad07043d5d2d" prot="public">
          <name>UART_PAR_NONE</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>No parity </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa5405c8d842bffa2f76999eef9cee32c3" prot="public">
          <name>UART_PAR_EVEN</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Parity bit is even </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa498f72ae68542763da3072d3e3af6603" prot="public">
          <name>UART_PAR_ODD</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Parity bit is odd </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaadfb9d17fa33753ea5550e757b323bd46" prot="public">
          <name>UART_PAR_ZERO</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Parity bit is always zero </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa7ab50a9a14f4c614e875fbab74911afa" prot="public">
          <name>UART_PAR_ONE</name>
          <initializer>= 4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Parity bit is always one </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>UART parity type settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the UART parity types. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="535" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="535" bodyend="541"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" prot="public" static="no">
        <type>struct <ref refid="struct_u_a_r_t___config__" kindref="compound">UART_Config_</ref> *</type>
        <definition>typedef struct UART_Config_* UART_Handle</definition>
        <argsstring></argsstring>
        <name>UART_Handle</name>
        <briefdescription>
<para>A handle that is returned from a <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> call. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="410" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="410" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a5d43bd8997e9153ce790bc81467ec935" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* UART_Callback) (UART_Handle handle, void *buf, size_t count)</definition>
        <argsstring>)(UART_Handle handle, void *buf, size_t count)</argsstring>
        <name>UART_Callback</name>
        <briefdescription>
<para>The definition of a callback function used by the UART driver when used in <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref> The callback can occur in task or HWI context. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>UART_Handle</parametername>
</parameternamelist>
<parameterdescription>
<para>UART_Handle</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to read/write buffer</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements read/written </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="423" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="423" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1ae41b00c68f1c34e4e0efc704d912e979" prot="public" static="no">
        <type>enum <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173" kindref="member">UART_Mode_</ref></type>
        <definition>typedef enum UART_Mode_  UART_Mode</definition>
        <argsstring></argsstring>
        <name>UART_Mode</name>
        <briefdescription>
<para>UART mode settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enum defines the read and write modes for the configured UART. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="443" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1ad7e89f8faac3d6d04a1de1328c77d360" prot="public" static="no">
        <type>enum <ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25f" kindref="member">UART_ReturnMode_</ref></type>
        <definition>typedef enum UART_ReturnMode_  UART_ReturnMode</definition>
        <argsstring></argsstring>
        <name>UART_ReturnMode</name>
        <briefdescription>
<para>UART return mode settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the return modes for <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> and <ref refid="_u_a_r_t_8h_1a3ac6ed8cfd03b84198ba6adcd8c248e6" kindref="member">UART_readPolling()</ref>. This mode only functions when in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode.</para><para><ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa50c07cbaf7518a0acd14137e801687e5" kindref="member">UART_RETURN_FULL</ref> unblocks or performs a callback when the read buffer has been filled. <ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa3b8e419e0e12abf80b25f72d17745f76" kindref="member">UART_RETURN_NEWLINE</ref> unblocks or performs a callback whenever a newline character has been received.</para><para><table rows="3" cols="3"><row>
<entry thead="yes"><para>UART operation </para></entry><entry thead="yes"><para>UART_RETURN_FULL </para></entry><entry thead="yes"><para>UART_RETURN_NEWLINE  </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> </para></entry><entry thead="no"><para>Returns when buffer is full </para></entry><entry thead="no"><para>Returns when buffer is full or newline was read </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> </para></entry><entry thead="no"><para>Sends data as is </para></entry><entry thead="no"><para>Sends data with an additional newline at the end </para></entry></row>
</table>
<simplesect kind="pre"><para>UART driver must be used in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="469" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a408e7775f62e5ef3af6be261e54cfe6f" prot="public" static="no">
        <type>enum <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9" kindref="member">UART_DataMode_</ref></type>
        <definition>typedef enum UART_DataMode_  UART_DataMode</definition>
        <argsstring></argsstring>
        <name>UART_DataMode</name>
        <briefdescription>
<para>UART data mode settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the data mode for reads and writes.</para><para>In <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8" kindref="member">UART_DATA_BINARY</ref>, data is passed as is, with no processing.</para><para>In <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode, the driver will examine the <ref refid="_u_a_r_t_8h_1ad7e89f8faac3d6d04a1de1328c77d360" kindref="member">UART_ReturnMode</ref> value, to determine whether or not to unblock/callback when a newline is received. Read actions replace a carriage return with a newline, and write actions add a carriage return before a newline. This effectively treats all device line endings as LF, and all host PC line endings as CRLF. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="488" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a6ad9119f540c4b08fafdec744910944c" prot="public" static="no">
        <type>enum <ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83c" kindref="member">UART_Echo_</ref></type>
        <definition>typedef enum UART_Echo_  UART_Echo</definition>
        <argsstring></argsstring>
        <name>UART_Echo</name>
        <briefdescription>
<para>UART echo settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines if the driver will echo data when uses in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode. This only applies to data received by the UART.</para><para><ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca6c4d8a2d4e30c22cf9fa45cd1bf79306" kindref="member">UART_ECHO_ON</ref> will echo back characters it received while in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode. <ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca2b286f182793d4a71bdf99409b9600dd" kindref="member">UART_ECHO_OFF</ref> will not echo back characters it received in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode.</para><para><simplesect kind="pre"><para>UART driver must be used in <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref> mode. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="506" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a1ce6782f5b01eba1a9743624a5679676" prot="public" static="no">
        <type>enum <ref refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062" kindref="member">UART_LEN_</ref></type>
        <definition>typedef enum UART_LEN_  UART_LEN</definition>
        <argsstring></argsstring>
        <name>UART_LEN</name>
        <briefdescription>
<para>UART data length settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the UART data lengths. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="518" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1aa703b480e2570985c9b017d55318a744" prot="public" static="no">
        <type>enum <ref refid="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34" kindref="member">UART_STOP_</ref></type>
        <definition>typedef enum UART_STOP_  UART_STOP</definition>
        <argsstring></argsstring>
        <name>UART_STOP</name>
        <briefdescription>
<para>UART stop bit settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the UART stop bits. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="528" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a9319492fe8fd31a7ed85e22f3564cbf4" prot="public" static="no">
        <type>enum <ref refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfda" kindref="member">UART_PAR_</ref></type>
        <definition>typedef enum UART_PAR_  UART_PAR</definition>
        <argsstring></argsstring>
        <name>UART_PAR</name>
        <briefdescription>
<para>UART parity type settings. </para>        </briefdescription>
        <detaileddescription>
<para>This enumeration defines the UART parity types. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="541" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1aa2500401cd05c08f9a392a921ff9c366" prot="public" static="no">
        <type>struct <ref refid="struct_u_a_r_t___params__" kindref="compound">UART_Params_</ref></type>
        <definition>typedef struct UART_Params_  UART_Params</definition>
        <argsstring></argsstring>
        <name>UART_Params</name>
        <briefdescription>
<para>UART Parameters. </para>        </briefdescription>
        <detaileddescription>
<para>UART parameters are used with the <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> call. Default values for these parameters are set using <ref refid="_u_a_r_t_8h_1a40e5c0823bb7ffd2e8fbf19f9f20b399" kindref="member">UART_Params_init()</ref>.</para><para><simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1a40e5c0823bb7ffd2e8fbf19f9f20b399" kindref="member">UART_Params_init()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="567" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1ae08ff15291bd6b21cb4e2eb1fce164a6" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* UART_CloseFxn) (UART_Handle handle)</definition>
        <argsstring>)(UART_Handle handle)</argsstring>
        <name>UART_CloseFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1ae08ff15291bd6b21cb4e2eb1fce164a6" kindref="member">UART_CloseFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="573" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="573" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a583c5e0b34e5806ec225f61d0daed0d6" prot="public" static="no">
        <type>int_fast16_t(*</type>
        <definition>typedef int_fast16_t(* UART_ControlFxn) (UART_Handle handle, uint_fast16_t cmd, void *arg)</definition>
        <argsstring>)(UART_Handle handle, uint_fast16_t cmd, void *arg)</argsstring>
        <name>UART_ControlFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1a583c5e0b34e5806ec225f61d0daed0d6" kindref="member">UART_ControlFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="579" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="579" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a2b3e89df3065fffb47e7354067c14d1b" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* UART_InitFxn) (UART_Handle handle)</definition>
        <argsstring>)(UART_Handle handle)</argsstring>
        <name>UART_InitFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1a2b3e89df3065fffb47e7354067c14d1b" kindref="member">UART_InitFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="585" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="585" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a39e21ac60f24eb9ce32286e21de713d1" prot="public" static="no">
        <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref>(*</type>
        <definition>typedef UART_Handle(* UART_OpenFxn) (UART_Handle handle, UART_Params *params)</definition>
        <argsstring>)(UART_Handle handle, UART_Params *params)</argsstring>
        <name>UART_OpenFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1a39e21ac60f24eb9ce32286e21de713d1" kindref="member">UART_OpenFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="591" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="591" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1ad1d454c210267a4d04ecce802947633c" prot="public" static="no">
        <type>int_fast32_t(*</type>
        <definition>typedef int_fast32_t(* UART_ReadFxn) (UART_Handle handle, void *buffer, size_t size)</definition>
        <argsstring>)(UART_Handle handle, void *buffer, size_t size)</argsstring>
        <name>UART_ReadFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1ad1d454c210267a4d04ecce802947633c" kindref="member">UART_ReadFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="596" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="596" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a96c6ef4189723f6ac960a82e6a232b35" prot="public" static="no">
        <type>int_fast32_t(*</type>
        <definition>typedef int_fast32_t(* UART_ReadPollingFxn) (UART_Handle handle, void *buffer, size_t size)</definition>
        <argsstring>)(UART_Handle handle, void *buffer, size_t size)</argsstring>
        <name>UART_ReadPollingFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1a96c6ef4189723f6ac960a82e6a232b35" kindref="member">UART_ReadPollingFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="603" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="603" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1aa46296acc2c197a775d44458e1eca197" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* UART_ReadCancelFxn) (UART_Handle handle)</definition>
        <argsstring>)(UART_Handle handle)</argsstring>
        <name>UART_ReadCancelFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1aa46296acc2c197a775d44458e1eca197" kindref="member">UART_ReadCancelFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="610" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="610" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1aad6b880dc397d9454038b383d6b821c8" prot="public" static="no">
        <type>int_fast32_t(*</type>
        <definition>typedef int_fast32_t(* UART_WriteFxn) (UART_Handle handle, const void *buffer, size_t size)</definition>
        <argsstring>)(UART_Handle handle, const void *buffer, size_t size)</argsstring>
        <name>UART_WriteFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1aad6b880dc397d9454038b383d6b821c8" kindref="member">UART_WriteFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="616" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="616" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1aa6f14597bf561bf987ce6a48dac08076" prot="public" static="no">
        <type>int_fast32_t(*</type>
        <definition>typedef int_fast32_t(* UART_WritePollingFxn) (UART_Handle handle, const void *buffer, size_t size)</definition>
        <argsstring>)(UART_Handle handle, const void *buffer, size_t size)</argsstring>
        <name>UART_WritePollingFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1aa6f14597bf561bf987ce6a48dac08076" kindref="member">UART_WritePollingFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="623" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="623" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1ac5a3d974279a2d161746dfbc8ca91774" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* UART_WriteCancelFxn) (UART_Handle handle)</definition>
        <argsstring>)(UART_Handle handle)</argsstring>
        <name>UART_WriteCancelFxn</name>
        <briefdescription>
<para>A function pointer to a driver specific implementation of <ref refid="_u_a_r_t_8h_1ac5a3d974279a2d161746dfbc8ca91774" kindref="member">UART_WriteCancelFxn()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="630" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/UART.h" bodystart="630" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1ad50e0d914874c8fcbc16b451984a8f5e" prot="public" static="no">
        <type>struct <ref refid="struct_u_a_r_t___fxn_table__" kindref="compound">UART_FxnTable_</ref></type>
        <definition>typedef struct UART_FxnTable_  UART_FxnTable</definition>
        <argsstring></argsstring>
        <name>UART_FxnTable</name>
        <briefdescription>
<para>The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="667" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_u_a_r_t_8h_1a68be81b9ce429a5e5c3ac02d285dbd3b" prot="public" static="no">
        <type>struct <ref refid="struct_u_a_r_t___config__" kindref="compound">UART_Config_</ref></type>
        <definition>typedef struct UART_Config_  UART_Config</definition>
        <argsstring></argsstring>
        <name>UART_Config</name>
        <briefdescription>
<para>UART Global configuration. </para>        </briefdescription>
        <detaileddescription>
<para>The UART_Config structure contains a set of pointers used to characterize the UART driver implementation.</para><para>This structure needs to be defined before calling <ref refid="_u_a_r_t_8h_1ab60a36f7295d704926120d22f806dcd1" kindref="member">UART_init()</ref> and it must not be changed thereafter.</para><para><simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1ab60a36f7295d704926120d22f806dcd1" kindref="member">UART_init()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="689" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="_u_a_r_t_8h_1a6b49b65f3db709c408dc4db23a68895d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void UART_close</definition>
        <argsstring>(UART_Handle handle)</argsstring>
        <name>UART_close</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <briefdescription>
<para>Function to close a UART peripheral specified by the UART handle. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> has been called. </para></simplesect>
<simplesect kind="pre"><para>Ongoing asynchronous read or write have been canceled using <ref refid="_u_a_r_t_8h_1a51ed7e94d5b409ca1fcb2d65c5a25c3c" kindref="member">UART_readCancel()</ref> or <ref refid="_u_a_r_t_8h_1a0482cd0ab9ee7e802c8e785a5754d16d" kindref="member">UART_writeCancel()</ref> respectively.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>A <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref> returned from <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="702" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int_fast16_t</type>
        <definition>int_fast16_t UART_control</definition>
        <argsstring>(UART_Handle handle, uint_fast16_t cmd, void *arg)</argsstring>
        <name>UART_control</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <param>
          <type>uint_fast16_t</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
<para>Function performs implementation specific features on a given <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Commands for UART_control() can originate from <ref refid="_u_a_r_t_8h" kindref="compound">UART.h</ref> or from implementation specific UART*.h (<emphasis>UARTCC26XX.h</emphasis>, <emphasis><ref refid="_u_a_r_t_m_s_p432_8h" kindref="compound">UARTMSP432.h</ref></emphasis>, etc.. ) files. While commands from <ref refid="_u_a_r_t_8h" kindref="compound">UART.h</ref> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific UART*.h files add unique driver capabilities but are not API portable across all UART driver implementations.</para><para>Commands supported by <ref refid="_u_a_r_t_8h" kindref="compound">UART.h</ref> follow a UART_CMD_&lt;cmd&gt; naming convention.<linebreak/>
 Commands supported by UART*.h follow a UART*_CMD_&lt;cmd&gt; naming convention.<linebreak/>
 Each control command defines <bold>arg</bold> differently. The types of <bold>arg</bold> are documented with each command.</para><para>See <ref refid="group___u_a_r_t___c_m_d" kindref="compound">UART_control command codes</ref> for command codes.</para><para>See <ref refid="group___u_a_r_t___s_t_a_t_u_s" kindref="compound">UART_control return status codes</ref> for status codes.</para><para><simplesect kind="pre"><para><ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> has to be called.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>A UART handle returned from <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmd</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="_u_a_r_t_8h" kindref="compound">UART.h</ref> or UART*.h commands.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>arg</parametername>
</parameternamelist>
<parameterdescription>
<para>An optional R/W (read/write) command argument accompanied with cmd</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Implementation specific return codes. Negative values indicate unsuccessful operations.</para></simplesect>
<simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="741" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1ab60a36f7295d704926120d22f806dcd1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void UART_init</definition>
        <argsstring>(void)</argsstring>
        <name>UART_init</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Function to initialize the UART module. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para>The UART_config structure must exist and be persistent before this function can be called. This function must also be called before any other UART driver APIs. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="750" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
        <definition>UART_Handle UART_open</definition>
        <argsstring>(uint_least8_t index, UART_Params *params)</argsstring>
        <name>UART_open</name>
        <param>
          <type>uint_least8_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type><ref refid="_u_a_r_t_8h_1aa2500401cd05c08f9a392a921ff9c366" kindref="member">UART_Params</ref> *</type>
          <declname>params</declname>
        </param>
        <briefdescription>
<para>Function to initialize a given UART peripheral. </para>        </briefdescription>
        <detaileddescription>
<para>Function to initialize a given UART peripheral specified by the particular index value.</para><para><simplesect kind="pre"><para><ref refid="_u_a_r_t_8h_1ab60a36f7295d704926120d22f806dcd1" kindref="member">UART_init()</ref> has been called</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Logical peripheral number for the UART indexed into the UART_config table</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a parameter block. If NULL, default parameter values will be used. All the fields in this structure are RO (read-only).</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref> upon success. NULL if an error occurs, or if the indexed UART peripheral is already opened.</para></simplesect>
<simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1ab60a36f7295d704926120d22f806dcd1" kindref="member">UART_init()</ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1a6b49b65f3db709c408dc4db23a68895d" kindref="member">UART_close()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="773" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1a40e5c0823bb7ffd2e8fbf19f9f20b399" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void UART_Params_init</definition>
        <argsstring>(UART_Params *params)</argsstring>
        <name>UART_Params_init</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1aa2500401cd05c08f9a392a921ff9c366" kindref="member">UART_Params</ref> *</type>
          <declname>params</declname>
        </param>
        <briefdescription>
<para>Function to initialize the UART_Params struct to its defaults. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>An pointer to UART_Params structure for initialization</para></parameterdescription>
</parameteritem>
</parameterlist>
Defaults values are: readMode = UART_MODE_BLOCKING; writeMode = UART_MODE_BLOCKING; readTimeout = UART_WAIT_FOREVER; writeTimeout = UART_WAIT_FOREVER; readCallback = NULL; writeCallback = NULL; readReturnMode = UART_RETURN_NEWLINE; readDataMode = UART_DATA_TEXT; writeDataMode = UART_DATA_TEXT; readEcho = UART_ECHO_ON; baudRate = 115200; dataLength = UART_LEN_8; stopBits = UART_STOP_ONE; parityType = UART_PAR_NONE; </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="797" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int_fast32_t</type>
        <definition>int_fast32_t UART_write</definition>
        <argsstring>(UART_Handle handle, const void *buffer, size_t size)</argsstring>
        <name>UART_write</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Function that writes data to a UART with interrupts enabled. </para>        </briefdescription>
        <detaileddescription>
<para>UART_write() writes data from a memory buffer to the UART interface. The source is specified by <emphasis>buffer</emphasis> and the number of bytes to write is given by <emphasis>size</emphasis>.</para><para>In <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf" kindref="member">UART_MODE_BLOCKING</ref>, <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> blocks task execution until all the data in buffer has been written.</para><para>In <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref>, UART_write() does not block task execution. Instead, a callback function specified by <ref refid="struct_u_a_r_t___params___1ad8882b7e15bb07a3cb150dec73f05b4d" kindref="member">UART_Params::writeCallback</ref> is called when the transfer is finished. The buffer passed to <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> in <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref> is not copied. The buffer must remain coherent until all the characters have been sent (ie until the tx callback has been called with a byte count equal to that passed to <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref>). The callback function can occur in the caller&apos;s task context or in a HWI or SWI context, depending on the device implementation. An unfinished asynchronous write operation must always be canceled using <ref refid="_u_a_r_t_8h_1a0482cd0ab9ee7e802c8e785a5754d16d" kindref="member">UART_writeCancel()</ref> before calling <ref refid="_u_a_r_t_8h_1a6b49b65f3db709c408dc4db23a68895d" kindref="member">UART_close()</ref>.</para><para>UART_write() is mutually exclusive to <ref refid="_u_a_r_t_8h_1ad8cda326eb3c05ee05950680bee42e5a" kindref="member">UART_writePolling()</ref>. For an opened UART peripheral, either <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> or <ref refid="_u_a_r_t_8h_1ad8cda326eb3c05ee05950680bee42e5a" kindref="member">UART_writePolling()</ref> can be used, but not both.</para><para><simplesect kind="warning"><para>Do not call UART_write() from its own callback function when in <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref>.</para></simplesect>
<simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1ad8cda326eb3c05ee05950680bee42e5a" kindref="member">UART_writePolling()</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>A <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref> returned by <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>A read-only pointer to buffer containing data to be written to the UART</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes in the buffer that should be written to the UART</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the number of bytes that have been written to the UART. If an error occurs, <ref refid="group___u_a_r_t___s_t_a_t_u_s_1ga2ae076f4aae13ca8e2aea674207df0ad" kindref="member">UART_STATUS_ERROR</ref> is returned. In <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref> mode, the return value is always 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="841" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1ad8cda326eb3c05ee05950680bee42e5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int_fast32_t</type>
        <definition>int_fast32_t UART_writePolling</definition>
        <argsstring>(UART_Handle handle, const void *buffer, size_t size)</argsstring>
        <name>UART_writePolling</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Function that writes data to a UART, polling the peripheral to wait until new data can be written. Usage of this API is mutually exclusive with usage of <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This function initiates an operation to write data to a UART controller.</para><para><ref refid="_u_a_r_t_8h_1ad8cda326eb3c05ee05950680bee42e5a" kindref="member">UART_writePolling()</ref> will not return until all the data was written to the UART (or to its FIFO if applicable).</para><para><simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>A <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref> returned by <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>A read-only pointer to the buffer containing the data to be written to the UART</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes in the buffer that should be written to the UART</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the number of bytes that have been written to the UART. If an error occurs, <ref refid="group___u_a_r_t___s_t_a_t_u_s_1ga2ae076f4aae13ca8e2aea674207df0ad" kindref="member">UART_STATUS_ERROR</ref> is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="866" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1a0482cd0ab9ee7e802c8e785a5754d16d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void UART_writeCancel</definition>
        <argsstring>(UART_Handle handle)</argsstring>
        <name>UART_writeCancel</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <briefdescription>
<para>Function that cancels a <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function cancels an asynchronous <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> operation and is only applicable in <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref>. <ref refid="_u_a_r_t_8h_1a0482cd0ab9ee7e802c8e785a5754d16d" kindref="member">UART_writeCancel()</ref> calls the registered TX callback function no matter how many bytes were sent. It is the application&apos;s responsibility to check the count argument in the callback function and handle cases where only a subset of the bytes were sent.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>A <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref> returned by <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="879" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int_fast32_t</type>
        <definition>int_fast32_t UART_read</definition>
        <argsstring>(UART_Handle handle, void *buffer, size_t size)</argsstring>
        <name>UART_read</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Function that reads data from a UART with interrupt enabled. </para>        </briefdescription>
        <detaileddescription>
<para>UART_read() reads data from a UART controller. The destination is specified by <emphasis>buffer</emphasis> and the number of bytes to read is given by <emphasis>size</emphasis>.</para><para>In <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf" kindref="member">UART_MODE_BLOCKING</ref>, UART_read() blocks task execution until all the data in buffer has been read.</para><para>In <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref>, UART_read() does not block task execution. Instead, a callback function specified by <ref refid="struct_u_a_r_t___params___1a90143ce78450225d957e0d05289564d3" kindref="member">UART_Params::readCallback</ref> is called when the transfer is finished. The callback function can occur in the caller&apos;s context or in HWI or SWI context, depending on the device-specific implementation. An unfinished asynchronous read operation must always be canceled using <ref refid="_u_a_r_t_8h_1a51ed7e94d5b409ca1fcb2d65c5a25c3c" kindref="member">UART_readCancel()</ref> before calling <ref refid="_u_a_r_t_8h_1a6b49b65f3db709c408dc4db23a68895d" kindref="member">UART_close()</ref>.</para><para>UART_read() is mutually exclusive to <ref refid="_u_a_r_t_8h_1a3ac6ed8cfd03b84198ba6adcd8c248e6" kindref="member">UART_readPolling()</ref>. For an opened UART peripheral, either UART_read() or <ref refid="_u_a_r_t_8h_1a3ac6ed8cfd03b84198ba6adcd8c248e6" kindref="member">UART_readPolling()</ref> can be used, but not both.</para><para><simplesect kind="warning"><para>Do not call UART_read() from its own callback function when in <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref>.</para></simplesect>
<simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1a3ac6ed8cfd03b84198ba6adcd8c248e6" kindref="member">UART_readPolling()</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>A <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref> returned by <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to an empty buffer to which received data should be written</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes to be written into buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the number of bytes that have been read from the UART, <ref refid="group___u_a_r_t___s_t_a_t_u_s_1ga2ae076f4aae13ca8e2aea674207df0ad" kindref="member">UART_STATUS_ERROR</ref> on an error. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="917" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1a3ac6ed8cfd03b84198ba6adcd8c248e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int_fast32_t</type>
        <definition>int_fast32_t UART_readPolling</definition>
        <argsstring>(UART_Handle handle, void *buffer, size_t size)</argsstring>
        <name>UART_readPolling</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Function that reads data from a UART without interrupts. This API must be used mutually exclusive with <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This function initiates an operation to read data from a UART peripheral.</para><para>UART_readPolling() will not return until size data was read to the UART.</para><para><simplesect kind="see"><para><ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>A <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref> returned by <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to an empty buffer in which received data should be written to</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes to be written into buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the number of bytes that have been read from the UART, <ref refid="group___u_a_r_t___s_t_a_t_u_s_1ga2ae076f4aae13ca8e2aea674207df0ad" kindref="member">UART_STATUS_ERROR</ref> on an error. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="939" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_u_a_r_t_8h_1a51ed7e94d5b409ca1fcb2d65c5a25c3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void UART_readCancel</definition>
        <argsstring>(UART_Handle handle)</argsstring>
        <name>UART_readCancel</name>
        <param>
          <type><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <briefdescription>
<para>Function that cancels a <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function cancels an asynchronous <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> operation and is only applicable in <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref>. <ref refid="_u_a_r_t_8h_1a51ed7e94d5b409ca1fcb2d65c5a25c3c" kindref="member">UART_readCancel()</ref> calls the registered RX callback function no matter how many bytes were received. It is the application&apos;s responsibility to check the count argument in the callback function and handle cases where only a subset of the bytes were received.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>A <ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref> returned by <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h" line="952" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>UART driver interface. </para>    </briefdescription>
    <detaileddescription>
<para><hruler/>
</para><para>To use the UART driver, ensure that the correct driver library for your device is linked in and include this header file as follows: <programlisting><codeline><highlight class="normal">#include<sp/>&lt;ti/drivers/UART.h&gt;</highlight></codeline>
</programlisting></para><para>This module serves as the main interface for applications. Its purpose is to redirect the UART APIs to specific driver implementations which are specified using a pointer to a <ref refid="_u_a_r_t_8h_1ad50e0d914874c8fcbc16b451984a8f5e" kindref="member">UART_FxnTable</ref>.</para><para><heading level="1">Overview</heading>
</para><para>A UART is used to translate data between the chip and a serial port. The UART driver simplifies reading and writing to any of the UART peripherals on the board, with multiple modes of operation and performance. These include blocking, non-blocking, and polling, as well as text/binary mode, echo and return characters.</para><para>The APIs in this driver serve as an interface to a typical RTOS application. The specific peripheral implementations are responsible for creating all the RTOS specific primitives to allow for thread-safe operation.</para><para><heading level="1">Usage</heading>
</para><para>The UART driver interface provides device independent APIs, data types, and macros. The following code example opens a UART instance, reads a byte from the UART, and then writes the byte back to the UART.</para><para><programlisting><codeline><highlight class="normal">char<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input;</highlight></codeline>
<codeline><highlight class="normal">UART_Handle<sp/>uart;</highlight></codeline>
<codeline><highlight class="normal">UART_Params<sp/>uartParams;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Initialize<sp/>the<sp/>UART<sp/>driver.</highlight></codeline>
<codeline><highlight class="normal">UART_init();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Create<sp/>a<sp/>UART<sp/>with<sp/>data<sp/>processing<sp/>off.</highlight></codeline>
<codeline><highlight class="normal">UART_Params_init(&amp;uartParams);</highlight></codeline>
<codeline><highlight class="normal">uartParams.writeDataMode<sp/>=<sp/>UART_DATA_BINARY;</highlight></codeline>
<codeline><highlight class="normal">uartParams.readDataMode<sp/>=<sp/>UART_DATA_BINARY;</highlight></codeline>
<codeline><highlight class="normal">uartParams.readReturnMode<sp/>=<sp/>UART_RETURN_FULL;</highlight></codeline>
<codeline><highlight class="normal">uartParams.readEcho<sp/>=<sp/>UART_ECHO_OFF;</highlight></codeline>
<codeline><highlight class="normal">uartParams.baudRate<sp/>=<sp/>115200;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Open<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>UART<sp/>drivers</highlight></codeline>
<codeline><highlight class="normal">uart<sp/>=<sp/>UART_open(Board_UART0,<sp/>&amp;uartParams);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(uart<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>UART_open()<sp/>failed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Loop<sp/>forever<sp/>echoing</highlight></codeline>
<codeline><highlight class="normal">while<sp/>(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UART_read(uart,<sp/>&amp;input,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UART_write(uart,<sp/>&amp;input,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Details for the example code above are described in the following subsections.</para><para><heading level="3">UART Driver Configuration</heading>
</para><para>In order to use the UART APIs, the application is required to provide device-specific UART configuration in the Board.c file. The UART driver interface defines a configuration data structure:</para><para><programlisting><codeline><highlight class="normal">typedef<sp/>struct<sp/>UART_Config_<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UART_FxnTable<sp/>const<sp/><sp/><sp/><sp/>*fxnTablePtr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*object;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/><sp/><sp/><sp/>*hwAttrs;</highlight></codeline>
<codeline><highlight class="normal">}<sp/>UART_Config;</highlight></codeline>
</programlisting></para><para>The application must declare an array of UART_Config elements, named UART_config[]. Each element of UART_config[] are populated with pointers to a device specific UART driver implementation&apos;s function table, driver object, and hardware attributes. The hardware attributes define properties such as the UART peripheral&apos;s base address, and the pins for RX and TX. Each element in UART_config[] corresponds to a UART instance, and none of the elements should have NULL pointers. There is no correlation between the index and the peripheral designation (such as UART0 or UART1). For example, it is possible to use UART_config[0] for UART1.</para><para>You will need to check the device-specific UART driver implementation&apos;s header file for example configuration. Please also refer to the Board.c file of any of your examples to see the UART configuration.</para><para><heading level="3">Initializing the UART Driver</heading>
</para><para><ref refid="_u_a_r_t_8h_1ab60a36f7295d704926120d22f806dcd1" kindref="member">UART_init()</ref> must be called before any other UART APIs. This function calls the device implementation&apos;s UART initialization function, for each element of UART_config[].</para><para><heading level="3">Opening the UART Driver</heading>
</para><para>Opening a UART requires four steps:<orderedlist>
<listitem><para>Create and initialize a UART_Params structure.</para></listitem><listitem><para>Fill in the desired parameters.</para></listitem><listitem><para>Call <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref>, passing the index of the UART in the UART_config structure, and the address of the UART_Params structure. The UART instance is specified by the index in the UART_config structure.</para></listitem><listitem><para>Check that the UART handle returned by <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> is non-NULL, and save it. The handle will be used to read and write to the UART you just opened.</para></listitem></orderedlist>
</para><para>Only one UART index can be used at a time; calling <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> a second time with the same index previosly passed to <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref> will result in an error. You can, though, re-use the index if the instance is closed via <ref refid="_u_a_r_t_8h_1a6b49b65f3db709c408dc4db23a68895d" kindref="member">UART_close()</ref>. In the example code, Board_UART0 is passed to <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref>. This macro is defined in the example&apos;s Board.h file.</para><para><heading level="3">Modes of Operation</heading>
</para><para>The UART driver can operate in blocking mode or callback mode, by setting the writeMode and readMode parameters passed to <ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open()</ref>. If these parameters are not set, as in the example code, the UART driver defaults to blocking mode. Options for the writeMode and readMode parameters are <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf" kindref="member">UART_MODE_BLOCKING</ref> and <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref>:</para><para><itemizedlist>
<listitem><para><ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf" kindref="member">UART_MODE_BLOCKING</ref> uses a semaphore to block while data is being sent. The context of calling <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> or <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> must be a Task when using <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf" kindref="member">UART_MODE_BLOCKING</ref>. The <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> or <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> call will block until all data is sent or received, or the write timeout or read timeout expires, whichever happens first.</para></listitem><listitem><para><ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref> is non-blocking and <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> and <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> will return while data is being sent in the context of a hardware interrupt. When the read or write finishes, the UART driver will call the user&apos;s callback function. In some cases, the UART data transfer may have been canceled, or a newline may have been received, so the number of bytes sent/received are passed to the callback function. Your implementation of the callback function can use this information as needed. Since the user&apos;s callback may be called in the context of an ISR, the callback function must not make any RTOS blocking calls. The buffer passed to <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> in <ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref> is not copied. The buffer must remain coherent until all the characters have been sent (ie until the tx callback has been called with a byte count equal to that passed to <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref>).</para></listitem></itemizedlist>
</para><para>The example sets the writeDataMode and readDataMode parameters to <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8" kindref="member">UART_DATA_BINARY</ref>. Options for these parameters are <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8" kindref="member">UART_DATA_BINARY</ref> and <ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref>:</para><para><itemizedlist>
<listitem><para><ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8" kindref="member">UART_DATA_BINARY</ref>: The data is passed as is, without processing.</para></listitem><listitem><para><ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref>: Write actions add a carriage return before a newline character, and read actions replace a return with a newline. This effectively treats all device line endings as LF and all host PC line endings as CRLF.</para></listitem></itemizedlist>
</para><para>Other parameters set by the example are readReturnMode and readEcho. Options for the readReturnMode parameter are <ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa50c07cbaf7518a0acd14137e801687e5" kindref="member">UART_RETURN_FULL</ref> and <ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa3b8e419e0e12abf80b25f72d17745f76" kindref="member">UART_RETURN_NEWLINE</ref>:</para><para><itemizedlist>
<listitem><para><ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa50c07cbaf7518a0acd14137e801687e5" kindref="member">UART_RETURN_FULL</ref>: The read action unblocks or returns when the buffer is full.</para></listitem><listitem><para><ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa3b8e419e0e12abf80b25f72d17745f76" kindref="member">UART_RETURN_NEWLINE</ref>: The read action unblocks or returns when a newline character is read, before the buffer is full.</para></listitem></itemizedlist>
</para><para>Options for the readEcho parameter are <ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca2b286f182793d4a71bdf99409b9600dd" kindref="member">UART_ECHO_OFF</ref> and <ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca6c4d8a2d4e30c22cf9fa45cd1bf79306" kindref="member">UART_ECHO_ON</ref>. This parameter determines whether the driver echoes data back to the UART. When echo is turned on, each character that is read by the target is written back, independent of any write operations. If data is received in the middle of a write and echo is turned on, the echoed characters will be mixed in with the write data.</para><para><heading level="3">Reading and Writing data</heading>
</para><para>The example code reads one byte frome the UART instance, and then writes one byte back to the same instance:</para><para><programlisting><codeline><highlight class="normal">UART_read(uart,<sp/>&amp;input,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal">UART_write(uart,<sp/>&amp;input,<sp/>1);</highlight></codeline>
</programlisting></para><para>The UART driver allows full duplex data transfers. Therefore, it is possible to call <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> and <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref> at the same time (for either blocking or callback modes). It is not possible, however, to issue multiple concurrent operations in the same direction. For example, if one thread calls UART_read(uart0, buffer0...), any other thread attempting UART_read(uart0, buffer1...) will result in an error of UART_STATUS_ERROR, until all the data from the first <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> has been transferred to buffer0. This applies to both blocking and and callback modes. So applications must either synchronize <ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read()</ref> (or <ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write()</ref>) calls that use the same UART handle, or check for the UART_STATUS_ERROR return code indicating that a transfer is still ongoing.</para><para><heading level="1">Implementation</heading>
</para><para>The UART driver interface module is joined (at link time) to an array of UART_Config data structures named <emphasis>UART_config</emphasis>. UART_config is implemented in the application with each entry being an instance of a UART peripheral. Each entry in <emphasis>UART_config</emphasis> contains a:<itemizedlist>
<listitem><para>(UART_FxnTable *) to a set of functions that implement a UART peripheral</para></listitem><listitem><para>(void *) data object that is associated with the UART_FxnTable</para></listitem><listitem><para>(void *) hardware attributes that are associated with the UART_FxnTable</para></listitem></itemizedlist>
</para><para>The UART APIs are redirected to the device specific implementations using the UART_FxnTable pointer of the UART_config entry. In order to use device specific functions of the UART driver directly, link in the correct driver library for your device and include the device specific UART driver header file (which in turn includes <ref refid="_u_a_r_t_8h" kindref="compound">UART.h</ref>). For example, for the MSP432 family of devices, you would include the following header file: <programlisting><codeline><highlight class="normal">#include<sp/>&lt;ti/drivers/uart/UARTMSP432.h&gt;</highlight></codeline>
</programlisting> <hruler/>
 </para>    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2015-2018,<sp/>Texas<sp/>Instruments<sp/>Incorporated</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*<sp/>Redistribution<sp/>and<sp/>use<sp/>in<sp/>source<sp/>and<sp/>binary<sp/>forms,<sp/>with<sp/>or<sp/>without</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*<sp/>modification,<sp/>are<sp/>permitted<sp/>provided<sp/>that<sp/>the<sp/>following<sp/>conditions</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>*<sp/>are<sp/>met:</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Redistributions<sp/>of<sp/>source<sp/>code<sp/>must<sp/>retain<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer.</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Redistributions<sp/>in<sp/>binary<sp/>form<sp/>must<sp/>reproduce<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer<sp/>in<sp/>the</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>documentation<sp/>and/or<sp/>other<sp/>materials<sp/>provided<sp/>with<sp/>the<sp/>distribution.</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Neither<sp/>the<sp/>name<sp/>of<sp/>Texas<sp/>Instruments<sp/>Incorporated<sp/>nor<sp/>the<sp/>names<sp/>of</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>its<sp/>contributors<sp/>may<sp/>be<sp/>used<sp/>to<sp/>endorse<sp/>or<sp/>promote<sp/>products<sp/>derived</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>from<sp/>this<sp/>software<sp/>without<sp/>specific<sp/>prior<sp/>written<sp/>permission.</highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*<sp/>THIS<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>BY<sp/>THE<sp/>COPYRIGHT<sp/>HOLDERS<sp/>AND<sp/>CONTRIBUTORS<sp/>&quot;AS<sp/>IS&quot;</highlight></codeline>
<codeline lineno="21"><highlight class="comment"><sp/>*<sp/>AND<sp/>ANY<sp/>EXPRESS<sp/>OR<sp/>IMPLIED<sp/>WARRANTIES,<sp/>INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,</highlight></codeline>
<codeline lineno="22"><highlight class="comment"><sp/>*<sp/>THE<sp/>IMPLIED<sp/>WARRANTIES<sp/>OF<sp/>MERCHANTABILITY<sp/>AND<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR</highlight></codeline>
<codeline lineno="23"><highlight class="comment"><sp/>*<sp/>PURPOSE<sp/>ARE<sp/>DISCLAIMED.<sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>THE<sp/>COPYRIGHT<sp/>OWNER<sp/>OR</highlight></codeline>
<codeline lineno="24"><highlight class="comment"><sp/>*<sp/>CONTRIBUTORS<sp/>BE<sp/>LIABLE<sp/>FOR<sp/>ANY<sp/>DIRECT,<sp/>INDIRECT,<sp/>INCIDENTAL,<sp/>SPECIAL,</highlight></codeline>
<codeline lineno="25"><highlight class="comment"><sp/>*<sp/>EXEMPLARY,<sp/>OR<sp/>CONSEQUENTIAL<sp/>DAMAGES<sp/>(INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,</highlight></codeline>
<codeline lineno="26"><highlight class="comment"><sp/>*<sp/>PROCUREMENT<sp/>OF<sp/>SUBSTITUTE<sp/>GOODS<sp/>OR<sp/>SERVICES;<sp/>LOSS<sp/>OF<sp/>USE,<sp/>DATA,<sp/>OR<sp/>PROFITS;</highlight></codeline>
<codeline lineno="27"><highlight class="comment"><sp/>*<sp/>OR<sp/>BUSINESS<sp/>INTERRUPTION)<sp/>HOWEVER<sp/>CAUSED<sp/>AND<sp/>ON<sp/>ANY<sp/>THEORY<sp/>OF<sp/>LIABILITY,</highlight></codeline>
<codeline lineno="28"><highlight class="comment"><sp/>*<sp/>WHETHER<sp/>IN<sp/>CONTRACT,<sp/>STRICT<sp/>LIABILITY,<sp/>OR<sp/>TORT<sp/>(INCLUDING<sp/>NEGLIGENCE<sp/>OR</highlight></codeline>
<codeline lineno="29"><highlight class="comment"><sp/>*<sp/>OTHERWISE)<sp/>ARISING<sp/>IN<sp/>ANY<sp/>WAY<sp/>OUT<sp/>OF<sp/>THE<sp/>USE<sp/>OF<sp/>THIS<sp/>SOFTWARE,</highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/>*<sp/>EVEN<sp/>IF<sp/>ADVISED<sp/>OF<sp/>THE<sp/>POSSIBILITY<sp/>OF<sp/>SUCH<sp/>DAMAGE.</highlight></codeline>
<codeline lineno="31"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight><highlight class="comment">/*!*****************************************************************************</highlight></codeline>
<codeline lineno="33"><highlight class="comment"><sp/>*<sp/><sp/>@file<sp/><sp/><sp/><sp/><sp/><sp/><sp/>UART.h</highlight></codeline>
<codeline lineno="34"><highlight class="comment"><sp/>*<sp/><sp/>@brief<sp/><sp/><sp/><sp/><sp/><sp/>UART<sp/>driver<sp/>interface</highlight></codeline>
<codeline lineno="35"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="36"><highlight class="comment"><sp/>*<sp/><sp/>To<sp/>use<sp/>the<sp/>UART<sp/>driver,<sp/>ensure<sp/>that<sp/>the<sp/>correct<sp/>driver<sp/>library<sp/>for<sp/>your</highlight></codeline>
<codeline lineno="37"><highlight class="comment"><sp/>*<sp/><sp/>device<sp/>is<sp/>linked<sp/>in<sp/>and<sp/>include<sp/>this<sp/>header<sp/>file<sp/>as<sp/>follows:</highlight></codeline>
<codeline lineno="38"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="39"><highlight class="comment"><sp/>*<sp/><sp/>#include<sp/>&lt;ti/drivers/UART.h&gt;</highlight></codeline>
<codeline lineno="40"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="41"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="42"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>module<sp/>serves<sp/>as<sp/>the<sp/>main<sp/>interface<sp/>for<sp/>applications.<sp/><sp/>Its<sp/>purpose</highlight></codeline>
<codeline lineno="43"><highlight class="comment"><sp/>*<sp/><sp/>is<sp/>to<sp/>redirect<sp/>the<sp/>UART<sp/>APIs<sp/>to<sp/>specific<sp/>driver<sp/>implementations</highlight></codeline>
<codeline lineno="44"><highlight class="comment"><sp/>*<sp/><sp/>which<sp/>are<sp/>specified<sp/>using<sp/>a<sp/>pointer<sp/>to<sp/>a<sp/>#UART_FxnTable.</highlight></codeline>
<codeline lineno="45"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="46"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>Overview<sp/>#</highlight></codeline>
<codeline lineno="47"><highlight class="comment"><sp/>*<sp/><sp/>A<sp/>UART<sp/>is<sp/>used<sp/>to<sp/>translate<sp/>data<sp/>between<sp/>the<sp/>chip<sp/>and<sp/>a<sp/>serial<sp/>port.</highlight></codeline>
<codeline lineno="48"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UART<sp/>driver<sp/>simplifies<sp/>reading<sp/>and<sp/>writing<sp/>to<sp/>any<sp/>of<sp/>the<sp/>UART</highlight></codeline>
<codeline lineno="49"><highlight class="comment"><sp/>*<sp/><sp/>peripherals<sp/>on<sp/>the<sp/>board,<sp/>with<sp/>multiple<sp/>modes<sp/>of<sp/>operation<sp/>and<sp/>performance.</highlight></codeline>
<codeline lineno="50"><highlight class="comment"><sp/>*<sp/><sp/>These<sp/>include<sp/>blocking,<sp/>non-blocking,<sp/>and<sp/>polling,<sp/>as<sp/>well<sp/>as<sp/>text/binary</highlight></codeline>
<codeline lineno="51"><highlight class="comment"><sp/>*<sp/><sp/>mode,<sp/>echo<sp/>and<sp/>return<sp/>characters.</highlight></codeline>
<codeline lineno="52"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="53"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>APIs<sp/>in<sp/>this<sp/>driver<sp/>serve<sp/>as<sp/>an<sp/>interface<sp/>to<sp/>a<sp/>typical<sp/>RTOS</highlight></codeline>
<codeline lineno="54"><highlight class="comment"><sp/>*<sp/><sp/>application.<sp/>The<sp/>specific<sp/>peripheral<sp/>implementations<sp/>are<sp/>responsible<sp/>for</highlight></codeline>
<codeline lineno="55"><highlight class="comment"><sp/>*<sp/><sp/>creating<sp/>all<sp/>the<sp/>RTOS<sp/>specific<sp/>primitives<sp/>to<sp/>allow<sp/>for<sp/>thread-safe</highlight></codeline>
<codeline lineno="56"><highlight class="comment"><sp/>*<sp/><sp/>operation.</highlight></codeline>
<codeline lineno="57"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="58"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>Usage<sp/>#</highlight></codeline>
<codeline lineno="59"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UART<sp/>driver<sp/>interface<sp/>provides<sp/>device<sp/>independent<sp/>APIs,<sp/>data<sp/>types,</highlight></codeline>
<codeline lineno="61"><highlight class="comment"><sp/>*<sp/><sp/>and<sp/>macros.<sp/><sp/>The<sp/>following<sp/>code<sp/>example<sp/>opens<sp/>a<sp/>UART<sp/>instance,<sp/>reads</highlight></codeline>
<codeline lineno="62"><highlight class="comment"><sp/>*<sp/><sp/>a<sp/>byte<sp/>from<sp/>the<sp/>UART,<sp/>and<sp/>then<sp/>writes<sp/>the<sp/>byte<sp/>back<sp/>to<sp/>the<sp/>UART.</highlight></codeline>
<codeline lineno="63"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="64"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="65"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>char<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input;</highlight></codeline>
<codeline lineno="66"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>UART_Handle<sp/>uart;</highlight></codeline>
<codeline lineno="67"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>UART_Params<sp/>uartParams;</highlight></codeline>
<codeline lineno="68"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="69"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>the<sp/>UART<sp/>driver.</highlight></codeline>
<codeline lineno="70"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>UART_init();</highlight></codeline>
<codeline lineno="71"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="72"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>//<sp/>Create<sp/>a<sp/>UART<sp/>with<sp/>data<sp/>processing<sp/>off.</highlight></codeline>
<codeline lineno="73"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>UART_Params_init(&amp;uartParams);</highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>uartParams.writeDataMode<sp/>=<sp/>UART_DATA_BINARY;</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>uartParams.readDataMode<sp/>=<sp/>UART_DATA_BINARY;</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>uartParams.readReturnMode<sp/>=<sp/>UART_RETURN_FULL;</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>uartParams.readEcho<sp/>=<sp/>UART_ECHO_OFF;</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>uartParams.baudRate<sp/>=<sp/>115200;</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>//<sp/>Open<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>UART<sp/>drivers</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>uart<sp/>=<sp/>UART_open(Board_UART0,<sp/>&amp;uartParams);</highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="83"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>if<sp/>(uart<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>UART_open()<sp/>failed</highlight></codeline>
<codeline lineno="85"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(1);</highlight></codeline>
<codeline lineno="86"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="87"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="88"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>//<sp/>Loop<sp/>forever<sp/>echoing</highlight></codeline>
<codeline lineno="89"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>while<sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="90"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UART_read(uart,<sp/>&amp;input,<sp/>1);</highlight></codeline>
<codeline lineno="91"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UART_write(uart,<sp/>&amp;input,<sp/>1);</highlight></codeline>
<codeline lineno="92"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="93"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="94"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="95"><highlight class="comment"><sp/>*<sp/><sp/>Details<sp/>for<sp/>the<sp/>example<sp/>code<sp/>above<sp/>are<sp/>described<sp/>in<sp/>the<sp/>following</highlight></codeline>
<codeline lineno="96"><highlight class="comment"><sp/>*<sp/><sp/>subsections.</highlight></codeline>
<codeline lineno="97"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="98"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="99"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>UART<sp/>Driver<sp/>Configuration<sp/>#</highlight></codeline>
<codeline lineno="100"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="101"><highlight class="comment"><sp/>*<sp/><sp/>In<sp/>order<sp/>to<sp/>use<sp/>the<sp/>UART<sp/>APIs,<sp/>the<sp/>application<sp/>is<sp/>required</highlight></codeline>
<codeline lineno="102"><highlight class="comment"><sp/>*<sp/><sp/>to<sp/>provide<sp/>device-specific<sp/>UART<sp/>configuration<sp/>in<sp/>the<sp/>Board.c<sp/>file.</highlight></codeline>
<codeline lineno="103"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UART<sp/>driver<sp/>interface<sp/>defines<sp/>a<sp/>configuration<sp/>data<sp/>structure:</highlight></codeline>
<codeline lineno="104"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="105"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="106"><highlight class="comment"><sp/>*<sp/><sp/>typedef<sp/>struct<sp/>UART_Config_<sp/>{</highlight></codeline>
<codeline lineno="107"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>UART_FxnTable<sp/>const<sp/><sp/><sp/><sp/>*fxnTablePtr;</highlight></codeline>
<codeline lineno="108"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*object;</highlight></codeline>
<codeline lineno="109"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/><sp/><sp/><sp/>*hwAttrs;</highlight></codeline>
<codeline lineno="110"><highlight class="comment"><sp/>*<sp/><sp/>}<sp/>UART_Config;</highlight></codeline>
<codeline lineno="111"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="112"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="113"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>application<sp/>must<sp/>declare<sp/>an<sp/>array<sp/>of<sp/>UART_Config<sp/>elements,<sp/>named</highlight></codeline>
<codeline lineno="114"><highlight class="comment"><sp/>*<sp/><sp/>UART_config[].<sp/><sp/>Each<sp/>element<sp/>of<sp/>UART_config[]<sp/>are<sp/>populated<sp/>with</highlight></codeline>
<codeline lineno="115"><highlight class="comment"><sp/>*<sp/><sp/>pointers<sp/>to<sp/>a<sp/>device<sp/>specific<sp/>UART<sp/>driver<sp/>implementation&apos;s<sp/>function</highlight></codeline>
<codeline lineno="116"><highlight class="comment"><sp/>*<sp/><sp/>table,<sp/>driver<sp/>object,<sp/>and<sp/>hardware<sp/>attributes.<sp/><sp/>The<sp/>hardware<sp/>attributes</highlight></codeline>
<codeline lineno="117"><highlight class="comment"><sp/>*<sp/><sp/>define<sp/>properties<sp/>such<sp/>as<sp/>the<sp/>UART<sp/>peripheral&apos;s<sp/>base<sp/>address,<sp/>and</highlight></codeline>
<codeline lineno="118"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>pins<sp/>for<sp/>RX<sp/>and<sp/>TX.<sp/><sp/>Each<sp/>element<sp/>in<sp/>UART_config[]<sp/>corresponds<sp/>to</highlight></codeline>
<codeline lineno="119"><highlight class="comment"><sp/>*<sp/><sp/>a<sp/>UART<sp/>instance,<sp/>and<sp/>none<sp/>of<sp/>the<sp/>elements<sp/>should<sp/>have<sp/>NULL<sp/>pointers.</highlight></codeline>
<codeline lineno="120"><highlight class="comment"><sp/>*<sp/><sp/>There<sp/>is<sp/>no<sp/>correlation<sp/>between<sp/>the<sp/>index<sp/>and<sp/>the<sp/>peripheral<sp/>designation</highlight></codeline>
<codeline lineno="121"><highlight class="comment"><sp/>*<sp/><sp/>(such<sp/>as<sp/>UART0<sp/>or<sp/>UART1).<sp/><sp/>For<sp/>example,<sp/>it<sp/>is<sp/>possible<sp/>to<sp/>use</highlight></codeline>
<codeline lineno="122"><highlight class="comment"><sp/>*<sp/><sp/>UART_config[0]<sp/>for<sp/>UART1.</highlight></codeline>
<codeline lineno="123"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="124"><highlight class="comment"><sp/>*<sp/><sp/>You<sp/>will<sp/>need<sp/>to<sp/>check<sp/>the<sp/>device-specific<sp/>UART<sp/>driver<sp/>implementation&apos;s</highlight></codeline>
<codeline lineno="125"><highlight class="comment"><sp/>*<sp/><sp/>header<sp/>file<sp/>for<sp/>example<sp/>configuration.<sp/><sp/>Please<sp/>also<sp/>refer<sp/>to<sp/>the</highlight></codeline>
<codeline lineno="126"><highlight class="comment"><sp/>*<sp/><sp/>Board.c<sp/>file<sp/>of<sp/>any<sp/>of<sp/>your<sp/>examples<sp/>to<sp/>see<sp/>the<sp/>UART<sp/>configuration.</highlight></codeline>
<codeline lineno="127"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="128"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Initializing<sp/>the<sp/>UART<sp/>Driver<sp/>#</highlight></codeline>
<codeline lineno="129"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="130"><highlight class="comment"><sp/>*<sp/><sp/>UART_init()<sp/>must<sp/>be<sp/>called<sp/>before<sp/>any<sp/>other<sp/>UART<sp/>APIs.<sp/><sp/>This<sp/>function</highlight></codeline>
<codeline lineno="131"><highlight class="comment"><sp/>*<sp/><sp/>calls<sp/>the<sp/>device<sp/>implementation&apos;s<sp/>UART<sp/>initialization<sp/>function,<sp/>for<sp/>each</highlight></codeline>
<codeline lineno="132"><highlight class="comment"><sp/>*<sp/><sp/>element<sp/>of<sp/>UART_config[].</highlight></codeline>
<codeline lineno="133"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="134"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Opening<sp/>the<sp/>UART<sp/>Driver<sp/>#</highlight></codeline>
<codeline lineno="135"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="136"><highlight class="comment"><sp/>*<sp/><sp/>Opening<sp/>a<sp/>UART<sp/>requires<sp/>four<sp/>steps:</highlight></codeline>
<codeline lineno="137"><highlight class="comment"><sp/>*<sp/><sp/>1.<sp/><sp/>Create<sp/>and<sp/>initialize<sp/>a<sp/>UART_Params<sp/>structure.</highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/>*<sp/><sp/>2.<sp/><sp/>Fill<sp/>in<sp/>the<sp/>desired<sp/>parameters.</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/>*<sp/><sp/>3.<sp/><sp/>Call<sp/>UART_open(),<sp/>passing<sp/>the<sp/>index<sp/>of<sp/>the<sp/>UART<sp/>in<sp/>the<sp/>UART_config</highlight></codeline>
<codeline lineno="140"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>structure,<sp/>and<sp/>the<sp/>address<sp/>of<sp/>the<sp/>UART_Params<sp/>structure.<sp/><sp/>The</highlight></codeline>
<codeline lineno="141"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>UART<sp/>instance<sp/>is<sp/>specified<sp/>by<sp/>the<sp/>index<sp/>in<sp/>the<sp/>UART_config<sp/>structure.</highlight></codeline>
<codeline lineno="142"><highlight class="comment"><sp/>*<sp/><sp/>4.<sp/><sp/>Check<sp/>that<sp/>the<sp/>UART<sp/>handle<sp/>returned<sp/>by<sp/>UART_open()<sp/>is<sp/>non-NULL,</highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>and<sp/>save<sp/>it.<sp/><sp/>The<sp/>handle<sp/>will<sp/>be<sp/>used<sp/>to<sp/>read<sp/>and<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>UART<sp/>you<sp/>just<sp/>opened.</highlight></codeline>
<codeline lineno="145"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="146"><highlight class="comment"><sp/>*<sp/><sp/>Only<sp/>one<sp/>UART<sp/>index<sp/>can<sp/>be<sp/>used<sp/>at<sp/>a<sp/>time;<sp/>calling<sp/>UART_open()<sp/>a<sp/>second</highlight></codeline>
<codeline lineno="147"><highlight class="comment"><sp/>*<sp/><sp/>time<sp/>with<sp/>the<sp/>same<sp/>index<sp/>previosly<sp/>passed<sp/>to<sp/>UART_open()<sp/>will<sp/>result<sp/>in</highlight></codeline>
<codeline lineno="148"><highlight class="comment"><sp/>*<sp/><sp/>an<sp/>error.<sp/><sp/>You<sp/>can,<sp/>though,<sp/>re-use<sp/>the<sp/>index<sp/>if<sp/>the<sp/>instance<sp/>is<sp/>closed</highlight></codeline>
<codeline lineno="149"><highlight class="comment"><sp/>*<sp/><sp/>via<sp/>UART_close().</highlight></codeline>
<codeline lineno="150"><highlight class="comment"><sp/>*<sp/><sp/>In<sp/>the<sp/>example<sp/>code,<sp/>Board_UART0<sp/>is<sp/>passed<sp/>to<sp/>UART_open().<sp/><sp/>This<sp/>macro</highlight></codeline>
<codeline lineno="151"><highlight class="comment"><sp/>*<sp/><sp/>is<sp/>defined<sp/>in<sp/>the<sp/>example&apos;s<sp/>Board.h<sp/>file.</highlight></codeline>
<codeline lineno="152"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="153"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="154"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Modes<sp/>of<sp/>Operation<sp/>#</highlight></codeline>
<codeline lineno="155"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="156"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UART<sp/>driver<sp/>can<sp/>operate<sp/>in<sp/>blocking<sp/>mode<sp/>or<sp/>callback<sp/>mode,<sp/>by</highlight></codeline>
<codeline lineno="157"><highlight class="comment"><sp/>*<sp/><sp/>setting<sp/>the<sp/>writeMode<sp/>and<sp/>readMode<sp/>parameters<sp/>passed<sp/>to<sp/>UART_open().</highlight></codeline>
<codeline lineno="158"><highlight class="comment"><sp/>*<sp/><sp/>If<sp/>these<sp/>parameters<sp/>are<sp/>not<sp/>set,<sp/>as<sp/>in<sp/>the<sp/>example<sp/>code,<sp/>the<sp/>UART</highlight></codeline>
<codeline lineno="159"><highlight class="comment"><sp/>*<sp/><sp/>driver<sp/>defaults<sp/>to<sp/>blocking<sp/>mode.<sp/><sp/>Options<sp/>for<sp/>the<sp/>writeMode<sp/>and</highlight></codeline>
<codeline lineno="160"><highlight class="comment"><sp/>*<sp/><sp/>readMode<sp/>parameters<sp/>are<sp/>#UART_MODE_BLOCKING<sp/>and<sp/>#UART_MODE_CALLBACK:</highlight></codeline>
<codeline lineno="161"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="162"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>#UART_MODE_BLOCKING<sp/>uses<sp/>a<sp/>semaphore<sp/>to<sp/>block<sp/>while<sp/>data<sp/>is<sp/>being<sp/>sent.</highlight></codeline>
<codeline lineno="163"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>The<sp/>context<sp/>of<sp/>calling<sp/>UART_read()<sp/>or<sp/>UART_write()<sp/>must<sp/>be<sp/>a<sp/>Task<sp/>when</highlight></codeline>
<codeline lineno="164"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>using<sp/>#UART_MODE_BLOCKING.<sp/><sp/>The<sp/>UART_write()<sp/>or<sp/>UART_read()<sp/>call</highlight></codeline>
<codeline lineno="165"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>will<sp/>block<sp/>until<sp/>all<sp/>data<sp/>is<sp/>sent<sp/>or<sp/>received,<sp/>or<sp/>the<sp/>write<sp/>timeout<sp/>or</highlight></codeline>
<codeline lineno="166"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>read<sp/>timeout<sp/>expires,<sp/>whichever<sp/>happens<sp/>first.</highlight></codeline>
<codeline lineno="167"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="168"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>#UART_MODE_CALLBACK<sp/>is<sp/>non-blocking<sp/>and<sp/>UART_read()<sp/>and<sp/>UART_write()</highlight></codeline>
<codeline lineno="169"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>will<sp/>return<sp/>while<sp/>data<sp/>is<sp/>being<sp/>sent<sp/>in<sp/>the<sp/>context<sp/>of<sp/>a<sp/>hardware</highlight></codeline>
<codeline lineno="170"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>interrupt.<sp/><sp/>When<sp/>the<sp/>read<sp/>or<sp/>write<sp/>finishes,<sp/>the<sp/>UART<sp/>driver<sp/>will<sp/>call</highlight></codeline>
<codeline lineno="171"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>the<sp/>user&apos;s<sp/>callback<sp/>function.<sp/><sp/>In<sp/>some<sp/>cases,<sp/>the<sp/>UART<sp/>data<sp/>transfer</highlight></codeline>
<codeline lineno="172"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>may<sp/>have<sp/>been<sp/>canceled,<sp/>or<sp/>a<sp/>newline<sp/>may<sp/>have<sp/>been<sp/>received,<sp/>so<sp/>the</highlight></codeline>
<codeline lineno="173"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>number<sp/>of<sp/>bytes<sp/>sent/received<sp/>are<sp/>passed<sp/>to<sp/>the<sp/>callback<sp/>function.<sp/><sp/>Your</highlight></codeline>
<codeline lineno="174"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>implementation<sp/>of<sp/>the<sp/>callback<sp/>function<sp/>can<sp/>use<sp/>this<sp/>information</highlight></codeline>
<codeline lineno="175"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>as<sp/>needed.<sp/><sp/>Since<sp/>the<sp/>user&apos;s<sp/>callback<sp/>may<sp/>be<sp/>called<sp/>in<sp/>the<sp/>context<sp/>of<sp/>an</highlight></codeline>
<codeline lineno="176"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>ISR,<sp/>the<sp/>callback<sp/>function<sp/>must<sp/>not<sp/>make<sp/>any<sp/>RTOS<sp/>blocking<sp/>calls.</highlight></codeline>
<codeline lineno="177"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>The<sp/>buffer<sp/>passed<sp/>to<sp/>UART_write()<sp/>in<sp/>#UART_MODE_CALLBACK<sp/>is<sp/>not<sp/>copied.</highlight></codeline>
<codeline lineno="178"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>The<sp/>buffer<sp/>must<sp/>remain<sp/>coherent<sp/>until<sp/>all<sp/>the<sp/>characters<sp/>have<sp/>been<sp/>sent</highlight></codeline>
<codeline lineno="179"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>(ie<sp/>until<sp/>the<sp/>tx<sp/>callback<sp/>has<sp/>been<sp/>called<sp/>with<sp/>a<sp/>byte<sp/>count<sp/>equal<sp/>to</highlight></codeline>
<codeline lineno="180"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>that<sp/>passed<sp/>to<sp/>UART_write()).</highlight></codeline>
<codeline lineno="181"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="182"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>example<sp/>sets<sp/>the<sp/>writeDataMode<sp/>and<sp/>readDataMode<sp/>parameters<sp/>to</highlight></codeline>
<codeline lineno="183"><highlight class="comment"><sp/>*<sp/><sp/>#UART_DATA_BINARY.<sp/><sp/>Options<sp/>for<sp/>these<sp/>parameters<sp/>are<sp/>#UART_DATA_BINARY</highlight></codeline>
<codeline lineno="184"><highlight class="comment"><sp/>*<sp/><sp/>and<sp/>#UART_DATA_TEXT:</highlight></codeline>
<codeline lineno="185"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="186"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>#UART_DATA_BINARY:<sp/><sp/>The<sp/>data<sp/>is<sp/>passed<sp/>as<sp/>is,<sp/>without<sp/>processing.</highlight></codeline>
<codeline lineno="187"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="188"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>#UART_DATA_TEXT:<sp/>Write<sp/>actions<sp/>add<sp/>a<sp/>carriage<sp/>return<sp/>before<sp/>a</highlight></codeline>
<codeline lineno="189"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>newline<sp/>character,<sp/>and<sp/>read<sp/>actions<sp/>replace<sp/>a<sp/>return<sp/>with<sp/>a<sp/>newline.</highlight></codeline>
<codeline lineno="190"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>This<sp/>effectively<sp/>treats<sp/>all<sp/>device<sp/>line<sp/>endings<sp/>as<sp/>LF<sp/>and<sp/>all<sp/>host</highlight></codeline>
<codeline lineno="191"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>PC<sp/>line<sp/>endings<sp/>as<sp/>CRLF.</highlight></codeline>
<codeline lineno="192"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="193"><highlight class="comment"><sp/>*<sp/><sp/>Other<sp/>parameters<sp/>set<sp/>by<sp/>the<sp/>example<sp/>are<sp/>readReturnMode<sp/>and<sp/>readEcho.</highlight></codeline>
<codeline lineno="194"><highlight class="comment"><sp/>*<sp/><sp/>Options<sp/>for<sp/>the<sp/>readReturnMode<sp/>parameter<sp/>are<sp/>#UART_RETURN_FULL<sp/>and</highlight></codeline>
<codeline lineno="195"><highlight class="comment"><sp/>*<sp/><sp/>#UART_RETURN_NEWLINE:</highlight></codeline>
<codeline lineno="196"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="197"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>#UART_RETURN_FULL:<sp/><sp/>The<sp/>read<sp/>action<sp/>unblocks<sp/>or<sp/>returns<sp/>when<sp/>the<sp/>buffer</highlight></codeline>
<codeline lineno="198"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>is<sp/>full.</highlight></codeline>
<codeline lineno="199"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>#UART_RETURN_NEWLINE:<sp/><sp/>The<sp/>read<sp/>action<sp/>unblocks<sp/>or<sp/>returns<sp/>when<sp/>a</highlight></codeline>
<codeline lineno="200"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>newline<sp/>character<sp/>is<sp/>read,<sp/>before<sp/>the<sp/>buffer<sp/>is<sp/>full.</highlight></codeline>
<codeline lineno="201"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="202"><highlight class="comment"><sp/>*<sp/><sp/>Options<sp/>for<sp/>the<sp/>readEcho<sp/>parameter<sp/>are<sp/>#UART_ECHO_OFF<sp/>and<sp/>#UART_ECHO_ON.</highlight></codeline>
<codeline lineno="203"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>parameter<sp/>determines<sp/>whether<sp/>the<sp/>driver<sp/>echoes<sp/>data<sp/>back<sp/>to<sp/>the</highlight></codeline>
<codeline lineno="204"><highlight class="comment"><sp/>*<sp/><sp/>UART.<sp/><sp/>When<sp/>echo<sp/>is<sp/>turned<sp/>on,<sp/>each<sp/>character<sp/>that<sp/>is<sp/>read<sp/>by<sp/>the<sp/>target</highlight></codeline>
<codeline lineno="205"><highlight class="comment"><sp/>*<sp/><sp/>is<sp/>written<sp/>back,<sp/>independent<sp/>of<sp/>any<sp/>write<sp/>operations.<sp/><sp/>If<sp/>data<sp/>is</highlight></codeline>
<codeline lineno="206"><highlight class="comment"><sp/>*<sp/><sp/>received<sp/>in<sp/>the<sp/>middle<sp/>of<sp/>a<sp/>write<sp/>and<sp/>echo<sp/>is<sp/>turned<sp/>on,<sp/>the<sp/>echoed</highlight></codeline>
<codeline lineno="207"><highlight class="comment"><sp/>*<sp/><sp/>characters<sp/>will<sp/>be<sp/>mixed<sp/>in<sp/>with<sp/>the<sp/>write<sp/>data.</highlight></codeline>
<codeline lineno="208"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="209"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Reading<sp/>and<sp/>Writing<sp/>data<sp/>#</highlight></codeline>
<codeline lineno="210"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="211"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>example<sp/>code<sp/>reads<sp/>one<sp/>byte<sp/>frome<sp/>the<sp/>UART<sp/>instance,<sp/>and<sp/>then<sp/>writes</highlight></codeline>
<codeline lineno="212"><highlight class="comment"><sp/>*<sp/><sp/>one<sp/>byte<sp/>back<sp/>to<sp/>the<sp/>same<sp/>instance:</highlight></codeline>
<codeline lineno="213"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="214"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="215"><highlight class="comment"><sp/>*<sp/><sp/>UART_read(uart,<sp/>&amp;input,<sp/>1);</highlight></codeline>
<codeline lineno="216"><highlight class="comment"><sp/>*<sp/><sp/>UART_write(uart,<sp/>&amp;input,<sp/>1);</highlight></codeline>
<codeline lineno="217"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="218"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="219"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UART<sp/>driver<sp/>allows<sp/>full<sp/>duplex<sp/>data<sp/>transfers.<sp/>Therefore,<sp/>it<sp/>is</highlight></codeline>
<codeline lineno="220"><highlight class="comment"><sp/>*<sp/><sp/>possible<sp/>to<sp/>call<sp/>UART_read()<sp/>and<sp/>UART_write()<sp/>at<sp/>the<sp/>same<sp/>time<sp/>(for</highlight></codeline>
<codeline lineno="221"><highlight class="comment"><sp/>*<sp/><sp/>either<sp/>blocking<sp/>or<sp/>callback<sp/>modes).<sp/>It<sp/>is<sp/>not<sp/>possible,<sp/>however,</highlight></codeline>
<codeline lineno="222"><highlight class="comment"><sp/>*<sp/><sp/>to<sp/>issue<sp/>multiple<sp/>concurrent<sp/>operations<sp/>in<sp/>the<sp/>same<sp/>direction.</highlight></codeline>
<codeline lineno="223"><highlight class="comment"><sp/>*<sp/><sp/>For<sp/>example,<sp/>if<sp/>one<sp/>thread<sp/>calls<sp/>UART_read(uart0,<sp/>buffer0...),</highlight></codeline>
<codeline lineno="224"><highlight class="comment"><sp/>*<sp/><sp/>any<sp/>other<sp/>thread<sp/>attempting<sp/>UART_read(uart0,<sp/>buffer1...)<sp/>will<sp/>result<sp/>in</highlight></codeline>
<codeline lineno="225"><highlight class="comment"><sp/>*<sp/><sp/>an<sp/>error<sp/>of<sp/>UART_STATUS_ERROR,<sp/>until<sp/>all<sp/>the<sp/>data<sp/>from<sp/>the<sp/>first<sp/>UART_read()</highlight></codeline>
<codeline lineno="226"><highlight class="comment"><sp/>*<sp/><sp/>has<sp/>been<sp/>transferred<sp/>to<sp/>buffer0.<sp/>This<sp/>applies<sp/>to<sp/>both<sp/>blocking<sp/>and</highlight></codeline>
<codeline lineno="227"><highlight class="comment"><sp/>*<sp/><sp/>and<sp/>callback<sp/>modes.<sp/>So<sp/>applications<sp/>must<sp/>either<sp/>synchronize</highlight></codeline>
<codeline lineno="228"><highlight class="comment"><sp/>*<sp/><sp/>UART_read()<sp/>(or<sp/>UART_write())<sp/>calls<sp/>that<sp/>use<sp/>the<sp/>same<sp/>UART<sp/>handle,<sp/>or</highlight></codeline>
<codeline lineno="229"><highlight class="comment"><sp/>*<sp/><sp/>check<sp/>for<sp/>the<sp/>UART_STATUS_ERROR<sp/>return<sp/>code<sp/>indicating<sp/>that<sp/>a<sp/>transfer<sp/>is</highlight></codeline>
<codeline lineno="230"><highlight class="comment"><sp/>*<sp/><sp/>still<sp/>ongoing.</highlight></codeline>
<codeline lineno="231"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="232"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>Implementation<sp/>#</highlight></codeline>
<codeline lineno="233"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="234"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UART<sp/>driver<sp/>interface<sp/>module<sp/>is<sp/>joined<sp/>(at<sp/>link<sp/>time)<sp/>to<sp/>an</highlight></codeline>
<codeline lineno="235"><highlight class="comment"><sp/>*<sp/><sp/>array<sp/>of<sp/>UART_Config<sp/>data<sp/>structures<sp/>named<sp/>*UART_config*.</highlight></codeline>
<codeline lineno="236"><highlight class="comment"><sp/>*<sp/><sp/>UART_config<sp/>is<sp/>implemented<sp/>in<sp/>the<sp/>application<sp/>with<sp/>each<sp/>entry<sp/>being<sp/>an</highlight></codeline>
<codeline lineno="237"><highlight class="comment"><sp/>*<sp/><sp/>instance<sp/>of<sp/>a<sp/>UART<sp/>peripheral.<sp/>Each<sp/>entry<sp/>in<sp/>*UART_config*<sp/>contains<sp/>a:</highlight></codeline>
<codeline lineno="238"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>(UART_FxnTable<sp/>*)<sp/>to<sp/>a<sp/>set<sp/>of<sp/>functions<sp/>that<sp/>implement<sp/>a<sp/>UART<sp/>peripheral</highlight></codeline>
<codeline lineno="239"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>(void<sp/>*)<sp/>data<sp/>object<sp/>that<sp/>is<sp/>associated<sp/>with<sp/>the<sp/>UART_FxnTable</highlight></codeline>
<codeline lineno="240"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>(void<sp/>*)<sp/>hardware<sp/>attributes<sp/>that<sp/>are<sp/>associated<sp/>with<sp/>the<sp/>UART_FxnTable</highlight></codeline>
<codeline lineno="241"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="242"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UART<sp/>APIs<sp/>are<sp/>redirected<sp/>to<sp/>the<sp/>device<sp/>specific<sp/>implementations</highlight></codeline>
<codeline lineno="243"><highlight class="comment"><sp/>*<sp/><sp/>using<sp/>the<sp/>UART_FxnTable<sp/>pointer<sp/>of<sp/>the<sp/>UART_config<sp/>entry.</highlight></codeline>
<codeline lineno="244"><highlight class="comment"><sp/>*<sp/><sp/>In<sp/>order<sp/>to<sp/>use<sp/>device<sp/>specific<sp/>functions<sp/>of<sp/>the<sp/>UART<sp/>driver<sp/>directly,</highlight></codeline>
<codeline lineno="245"><highlight class="comment"><sp/>*<sp/><sp/>link<sp/>in<sp/>the<sp/>correct<sp/>driver<sp/>library<sp/>for<sp/>your<sp/>device<sp/>and<sp/>include<sp/>the</highlight></codeline>
<codeline lineno="246"><highlight class="comment"><sp/>*<sp/><sp/>device<sp/>specific<sp/>UART<sp/>driver<sp/>header<sp/>file<sp/>(which<sp/>in<sp/>turn<sp/>includes<sp/>UART.h).</highlight></codeline>
<codeline lineno="247"><highlight class="comment"><sp/>*<sp/><sp/>For<sp/>example,<sp/>for<sp/>the<sp/>MSP432<sp/>family<sp/>of<sp/>devices,<sp/>you<sp/>would<sp/>include<sp/>the</highlight></codeline>
<codeline lineno="248"><highlight class="comment"><sp/>*<sp/><sp/>following<sp/>header<sp/>file:</highlight></codeline>
<codeline lineno="249"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>@code</highlight></codeline>
<codeline lineno="250"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>#include<sp/>&lt;ti/drivers/uart/UARTMSP432.h&gt;</highlight></codeline>
<codeline lineno="251"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="252"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="253"><highlight class="comment"><sp/>*<sp/><sp/>============================================================================</highlight></codeline>
<codeline lineno="254"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>ti_drivers_UART__include</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ti_drivers_UART__include</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="260"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal"></highlight></codeline>
<codeline lineno="263"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stddef.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdint.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight></codeline>
<codeline lineno="283" refid="group___u_a_r_t___c_o_n_t_r_o_l_1ga0f5a809e0884da33fef102236eb51644" refkind="member"><highlight class="preprocessor">#define<sp/>UART_CMD_RESERVED<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight></codeline>
<codeline lineno="297" refid="group___u_a_r_t___c_o_n_t_r_o_l_1ga8f35027907fbab6a9ee302d2ee52a879" refkind="member"><highlight class="preprocessor">#define<sp/>UART_STATUS_RESERVED<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(-32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="298"><highlight class="normal"></highlight></codeline>
<codeline lineno="312" refid="group___u_a_r_t___s_t_a_t_u_s_1ga101b7761f89b3ec49f0c6726669acfed" refkind="member"><highlight class="preprocessor">#define<sp/>UART_STATUS_SUCCESS<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"></highlight></codeline>
<codeline lineno="320" refid="group___u_a_r_t___s_t_a_t_u_s_1ga2ae076f4aae13ca8e2aea674207df0ad" refkind="member"><highlight class="preprocessor">#define<sp/>UART_STATUS_ERROR<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(-1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="321"><highlight class="normal"></highlight></codeline>
<codeline lineno="329" refid="group___u_a_r_t___s_t_a_t_u_s_1ga61125a2eb8059fd8b96ad95edc68ac2b" refkind="member"><highlight class="preprocessor">#define<sp/>UART_STATUS_UNDEFINEDCMD<sp/><sp/><sp/><sp/>(-2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal"></highlight></codeline>
<codeline lineno="348" refid="group___u_a_r_t___c_m_d_1ga942596a37cb2109ae021f88f3d907bdc" refkind="member"><highlight class="preprocessor">#define<sp/>UART_CMD_PEEK<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight></codeline>
<codeline lineno="359" refid="group___u_a_r_t___c_m_d_1gaf5be6db621c5b048637dc93b26797693" refkind="member"><highlight class="preprocessor">#define<sp/>UART_CMD_ISAVAILABLE<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"></highlight></codeline>
<codeline lineno="370" refid="group___u_a_r_t___c_m_d_1ga470321cbd9eccf137ffbe6553ae7f35f" refkind="member"><highlight class="preprocessor">#define<sp/>UART_CMD_GETRXCOUNT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="371"><highlight class="normal"></highlight></codeline>
<codeline lineno="382" refid="group___u_a_r_t___c_m_d_1gad67d01fa376f25bb28141d819647e8d3" refkind="member"><highlight class="preprocessor">#define<sp/>UART_CMD_RXENABLE<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(3)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="383"><highlight class="normal"></highlight></codeline>
<codeline lineno="395" refid="group___u_a_r_t___c_m_d_1gac0b19ce2fa9f43d3fe255bcdbd3cda7b" refkind="member"><highlight class="preprocessor">#define<sp/>UART_CMD_RXDISABLE<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(4)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="396"><highlight class="normal"></highlight></codeline>
<codeline lineno="400" refid="_u_a_r_t_8h_1a7e3562e7931cf51b41a32d8109072251" refkind="member"><highlight class="preprocessor">#define<sp/>UART_ERROR<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(UART_STATUS_ERROR)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="401"><highlight class="normal"></highlight></codeline>
<codeline lineno="405" refid="_u_a_r_t_8h_1ada620b673241eb6335a71e75da291716" refkind="member"><highlight class="preprocessor">#define<sp/>UART_WAIT_FOREVER<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(~(0U))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="406"><highlight class="normal"></highlight></codeline>
<codeline lineno="410" refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_u_a_r_t___config__" kindref="compound">UART_Config_</ref><sp/><sp/><sp/><sp/>*<ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref>;</highlight></codeline>
<codeline lineno="411"><highlight class="normal"></highlight></codeline>
<codeline lineno="423" refid="_u_a_r_t_8h_1a5d43bd8997e9153ce790bc81467ec935" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_u_a_r_t_8h_1a5d43bd8997e9153ce790bc81467ec935" kindref="member">UART_Callback</ref>)<sp/>(UART_Handle<sp/>handle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buf,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count);</highlight></codeline>
<codeline lineno="424"><highlight class="normal"></highlight></codeline>
<codeline lineno="430" refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173" kindref="member">UART_Mode_</ref><sp/>{</highlight></codeline>
<codeline lineno="435" refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf" kindref="member">UART_MODE_BLOCKING</ref>,</highlight></codeline>
<codeline lineno="436"><highlight class="normal"></highlight></codeline>
<codeline lineno="442" refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754" kindref="member">UART_MODE_CALLBACK</ref></highlight></codeline>
<codeline lineno="443"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1ae41b00c68f1c34e4e0efc704d912e979" kindref="member">UART_Mode</ref>;</highlight></codeline>
<codeline lineno="444"><highlight class="normal"></highlight></codeline>
<codeline lineno="463" refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25f" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25f" kindref="member">UART_ReturnMode_</ref><sp/>{</highlight></codeline>
<codeline lineno="465" refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa50c07cbaf7518a0acd14137e801687e5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa50c07cbaf7518a0acd14137e801687e5" kindref="member">UART_RETURN_FULL</ref>,</highlight></codeline>
<codeline lineno="466"><highlight class="normal"></highlight></codeline>
<codeline lineno="468" refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa3b8e419e0e12abf80b25f72d17745f76" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1acfee5fbe64f750b1b42701831310c25fa3b8e419e0e12abf80b25f72d17745f76" kindref="member">UART_RETURN_NEWLINE</ref></highlight></codeline>
<codeline lineno="469"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1ad7e89f8faac3d6d04a1de1328c77d360" kindref="member">UART_ReturnMode</ref>;</highlight></codeline>
<codeline lineno="470"><highlight class="normal"></highlight></codeline>
<codeline lineno="485" refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9" kindref="member">UART_DataMode_</ref><sp/>{</highlight></codeline>
<codeline lineno="486" refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8" kindref="member">UART_DATA_BINARY</ref><sp/>=<sp/>0,<sp/></highlight></codeline>
<codeline lineno="487" refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a1dc5f5e884c16722be3b218456f32df9a87fdfb7ca981eab7f56c51380fd7094e" kindref="member">UART_DATA_TEXT</ref><sp/>=<sp/>1<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="488"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1a408e7775f62e5ef3af6be261e54cfe6f" kindref="member">UART_DataMode</ref>;</highlight></codeline>
<codeline lineno="489"><highlight class="normal"></highlight></codeline>
<codeline lineno="503" refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83c" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83c" kindref="member">UART_Echo_</ref><sp/>{</highlight></codeline>
<codeline lineno="504" refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca2b286f182793d4a71bdf99409b9600dd" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca2b286f182793d4a71bdf99409b9600dd" kindref="member">UART_ECHO_OFF</ref><sp/>=<sp/>0,<sp/><sp/></highlight></codeline>
<codeline lineno="505" refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca6c4d8a2d4e30c22cf9fa45cd1bf79306" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a1f00ece3128a6978d1f4346568d7b83ca6c4d8a2d4e30c22cf9fa45cd1bf79306" kindref="member">UART_ECHO_ON</ref><sp/>=<sp/>1<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="506"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1a6ad9119f540c4b08fafdec744910944c" kindref="member">UART_Echo</ref>;</highlight></codeline>
<codeline lineno="507"><highlight class="normal"></highlight></codeline>
<codeline lineno="513" refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062" kindref="member">UART_LEN_</ref><sp/>{</highlight></codeline>
<codeline lineno="514" refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a27d04dd1fa818f764eb9b8e849feb7ff" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a27d04dd1fa818f764eb9b8e849feb7ff" kindref="member">UART_LEN_5</ref><sp/>=<sp/>0,<sp/><sp/></highlight></codeline>
<codeline lineno="515" refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a5bfd5507335d394d826e560930ce2a12" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a5bfd5507335d394d826e560930ce2a12" kindref="member">UART_LEN_6</ref><sp/>=<sp/>1,<sp/><sp/></highlight></codeline>
<codeline lineno="516" refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a2ac8467047f55cc1954388bf94c72e35" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a2ac8467047f55cc1954388bf94c72e35" kindref="member">UART_LEN_7</ref><sp/>=<sp/>2,<sp/><sp/></highlight></codeline>
<codeline lineno="517" refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a31abbaaeaa38a5c66fbe13bfc8ece221" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a8d08ef9450dc27498f9bd15dad3e7062a31abbaaeaa38a5c66fbe13bfc8ece221" kindref="member">UART_LEN_8</ref><sp/>=<sp/>3<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="518"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1a1ce6782f5b01eba1a9743624a5679676" kindref="member">UART_LEN</ref>;</highlight></codeline>
<codeline lineno="519"><highlight class="normal"></highlight></codeline>
<codeline lineno="525" refid="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34" kindref="member">UART_STOP_</ref><sp/>{</highlight></codeline>
<codeline lineno="526" refid="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34a9bfa599e95c5da9cfe5f964dab8a9c6c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34a9bfa599e95c5da9cfe5f964dab8a9c6c" kindref="member">UART_STOP_ONE</ref><sp/>=<sp/>0,<sp/><sp/></highlight></codeline>
<codeline lineno="527" refid="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34a3f41137f3775e7d33fdb250471c0248e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ad5747b19c0ead5512c84224a89a26b34a3f41137f3775e7d33fdb250471c0248e" kindref="member">UART_STOP_TWO</ref><sp/>=<sp/>1<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="528"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1aa703b480e2570985c9b017d55318a744" kindref="member">UART_STOP</ref>;</highlight></codeline>
<codeline lineno="529"><highlight class="normal"></highlight></codeline>
<codeline lineno="535" refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfda" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfda" kindref="member">UART_PAR_</ref><sp/>{</highlight></codeline>
<codeline lineno="536" refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa469955a283c95f261990ad07043d5d2d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa469955a283c95f261990ad07043d5d2d" kindref="member">UART_PAR_NONE</ref><sp/>=<sp/>0,<sp/><sp/></highlight></codeline>
<codeline lineno="537" refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa5405c8d842bffa2f76999eef9cee32c3" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa5405c8d842bffa2f76999eef9cee32c3" kindref="member">UART_PAR_EVEN</ref><sp/>=<sp/>1,<sp/><sp/></highlight></codeline>
<codeline lineno="538" refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa498f72ae68542763da3072d3e3af6603" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa498f72ae68542763da3072d3e3af6603" kindref="member">UART_PAR_ODD</ref><sp/><sp/>=<sp/>2,<sp/><sp/></highlight></codeline>
<codeline lineno="539" refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaadfb9d17fa33753ea5550e757b323bd46" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaadfb9d17fa33753ea5550e757b323bd46" kindref="member">UART_PAR_ZERO</ref><sp/>=<sp/>3,<sp/><sp/></highlight></codeline>
<codeline lineno="540" refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa7ab50a9a14f4c614e875fbab74911afa" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ac9d05230e0702ab72ff2d5b0cb67cfdaa7ab50a9a14f4c614e875fbab74911afa" kindref="member">UART_PAR_ONE</ref><sp/><sp/>=<sp/>4<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="541"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1a9319492fe8fd31a7ed85e22f3564cbf4" kindref="member">UART_PAR</ref>;</highlight></codeline>
<codeline lineno="542"><highlight class="normal"></highlight></codeline>
<codeline lineno="551" refid="struct_u_a_r_t___params__" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_u_a_r_t___params__" kindref="compound">UART_Params_</ref><sp/>{</highlight></codeline>
<codeline lineno="552" refid="struct_u_a_r_t___params___1a3595f9cd8c7629a977f6833c2578f7f9" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>UART_Mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1a3595f9cd8c7629a977f6833c2578f7f9" kindref="member">readMode</ref>;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="553" refid="struct_u_a_r_t___params___1aba1e2f7319961148683112ce7c46fef9" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>UART_Mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1aba1e2f7319961148683112ce7c46fef9" kindref="member">writeMode</ref>;<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="554" refid="struct_u_a_r_t___params___1ad7d6962c8a9f89ec9ea12f2b8485f43d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1ad7d6962c8a9f89ec9ea12f2b8485f43d" kindref="member">readTimeout</ref>;<sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="555" refid="struct_u_a_r_t___params___1a880f731e24ba95677cfeb6e802bb2bce" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1a880f731e24ba95677cfeb6e802bb2bce" kindref="member">writeTimeout</ref>;<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="556" refid="struct_u_a_r_t___params___1a90143ce78450225d957e0d05289564d3" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a5d43bd8997e9153ce790bc81467ec935" kindref="member">UART_Callback</ref><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1a90143ce78450225d957e0d05289564d3" kindref="member">readCallback</ref>;<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="557" refid="struct_u_a_r_t___params___1ad8882b7e15bb07a3cb150dec73f05b4d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a5d43bd8997e9153ce790bc81467ec935" kindref="member">UART_Callback</ref><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1ad8882b7e15bb07a3cb150dec73f05b4d" kindref="member">writeCallback</ref>;<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="558" refid="struct_u_a_r_t___params___1ad79c1d618eacd0e40d09aafe0c3b9a69" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>UART_ReturnMode<sp/><ref refid="struct_u_a_r_t___params___1ad79c1d618eacd0e40d09aafe0c3b9a69" kindref="member">readReturnMode</ref>;<sp/><sp/></highlight></codeline>
<codeline lineno="559" refid="struct_u_a_r_t___params___1ac0748b65265ff4fced9fee6a8c003398" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a408e7775f62e5ef3af6be261e54cfe6f" kindref="member">UART_DataMode</ref><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1ac0748b65265ff4fced9fee6a8c003398" kindref="member">readDataMode</ref>;<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="560" refid="struct_u_a_r_t___params___1afa84cf6a6b53150ab6908785a7aac41d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a408e7775f62e5ef3af6be261e54cfe6f" kindref="member">UART_DataMode</ref><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1afa84cf6a6b53150ab6908785a7aac41d" kindref="member">writeDataMode</ref>;<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="561" refid="struct_u_a_r_t___params___1a2a06d92c34f52e31debd8882d061ff06" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a6ad9119f540c4b08fafdec744910944c" kindref="member">UART_Echo</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1a2a06d92c34f52e31debd8882d061ff06" kindref="member">readEcho</ref>;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="562" refid="struct_u_a_r_t___params___1a4423b9250bb409710872f0a00b3383c7" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1a4423b9250bb409710872f0a00b3383c7" kindref="member">baudRate</ref>;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="563" refid="struct_u_a_r_t___params___1a37be40bc926b38cba71c494ccd1c2d15" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a1ce6782f5b01eba1a9743624a5679676" kindref="member">UART_LEN</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1a37be40bc926b38cba71c494ccd1c2d15" kindref="member">dataLength</ref>;<sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="564" refid="struct_u_a_r_t___params___1a7f10fa36761f30f658c12f86ceee4b47" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1aa703b480e2570985c9b017d55318a744" kindref="member">UART_STOP</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1a7f10fa36761f30f658c12f86ceee4b47" kindref="member">stopBits</ref>;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="565" refid="struct_u_a_r_t___params___1a575f35085ddbf8a58ec0b02b18f58e54" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a9319492fe8fd31a7ed85e22f3564cbf4" kindref="member">UART_PAR</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___params___1a575f35085ddbf8a58ec0b02b18f58e54" kindref="member">parityType</ref>;<sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="566" refid="struct_u_a_r_t___params___1a2ccda88cd42b0d919a094d486d879d2e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<ref refid="struct_u_a_r_t___params___1a2ccda88cd42b0d919a094d486d879d2e" kindref="member">custom</ref>;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="567"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1aa2500401cd05c08f9a392a921ff9c366" kindref="member">UART_Params</ref>;</highlight></codeline>
<codeline lineno="568"><highlight class="normal"></highlight></codeline>
<codeline lineno="573" refid="_u_a_r_t_8h_1ae08ff15291bd6b21cb4e2eb1fce164a6" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_u_a_r_t_8h_1ae08ff15291bd6b21cb4e2eb1fce164a6" kindref="member">UART_CloseFxn</ref>)<sp/>(UART_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="574"><highlight class="normal"></highlight></codeline>
<codeline lineno="579" refid="_u_a_r_t_8h_1a583c5e0b34e5806ec225f61d0daed0d6" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>int_fast16_t<sp/>(*<ref refid="_u_a_r_t_8h_1a583c5e0b34e5806ec225f61d0daed0d6" kindref="member">UART_ControlFxn</ref>)<sp/>(UART_Handle<sp/>handle,<sp/>uint_fast16_t<sp/>cmd,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*arg);</highlight></codeline>
<codeline lineno="580"><highlight class="normal"></highlight></codeline>
<codeline lineno="585" refid="_u_a_r_t_8h_1a2b3e89df3065fffb47e7354067c14d1b" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_u_a_r_t_8h_1a2b3e89df3065fffb47e7354067c14d1b" kindref="member">UART_InitFxn</ref>)<sp/>(UART_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="586"><highlight class="normal"></highlight></codeline>
<codeline lineno="591" refid="_u_a_r_t_8h_1a39e21ac60f24eb9ce32286e21de713d1" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1ab69886c7119a5054a972d8c735f15928" kindref="member">UART_Handle</ref><sp/>(*<ref refid="_u_a_r_t_8h_1a39e21ac60f24eb9ce32286e21de713d1" kindref="member">UART_OpenFxn</ref>)<sp/>(UART_Handle<sp/>handle,<sp/><ref refid="struct_u_a_r_t___params__" kindref="compound">UART_Params</ref><sp/>*params);</highlight></codeline>
<codeline lineno="596" refid="_u_a_r_t_8h_1ad1d454c210267a4d04ecce802947633c" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>int_fast32_t<sp/>(*<ref refid="_u_a_r_t_8h_1ad1d454c210267a4d04ecce802947633c" kindref="member">UART_ReadFxn</ref>)<sp/>(UART_Handle<sp/>handle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buffer,</highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="598"><highlight class="normal"></highlight></codeline>
<codeline lineno="603" refid="_u_a_r_t_8h_1a96c6ef4189723f6ac960a82e6a232b35" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>int_fast32_t<sp/>(*<ref refid="_u_a_r_t_8h_1a96c6ef4189723f6ac960a82e6a232b35" kindref="member">UART_ReadPollingFxn</ref>)<sp/>(UART_Handle<sp/>handle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buffer,</highlight></codeline>
<codeline lineno="604"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="605"><highlight class="normal"></highlight></codeline>
<codeline lineno="610" refid="_u_a_r_t_8h_1aa46296acc2c197a775d44458e1eca197" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_u_a_r_t_8h_1aa46296acc2c197a775d44458e1eca197" kindref="member">UART_ReadCancelFxn</ref>)<sp/>(UART_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="611"><highlight class="normal"></highlight></codeline>
<codeline lineno="616" refid="_u_a_r_t_8h_1aad6b880dc397d9454038b383d6b821c8" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>int_fast32_t<sp/>(*<ref refid="_u_a_r_t_8h_1aad6b880dc397d9454038b383d6b821c8" kindref="member">UART_WriteFxn</ref>)<sp/>(UART_Handle<sp/>handle,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buffer,</highlight></codeline>
<codeline lineno="617"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="618"><highlight class="normal"></highlight></codeline>
<codeline lineno="623" refid="_u_a_r_t_8h_1aa6f14597bf561bf987ce6a48dac08076" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>int_fast32_t<sp/>(*<ref refid="_u_a_r_t_8h_1aa6f14597bf561bf987ce6a48dac08076" kindref="member">UART_WritePollingFxn</ref>)<sp/>(UART_Handle<sp/>handle,</highlight></codeline>
<codeline lineno="624"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buffer,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="625"><highlight class="normal"></highlight></codeline>
<codeline lineno="630" refid="_u_a_r_t_8h_1ac5a3d974279a2d161746dfbc8ca91774" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_u_a_r_t_8h_1ac5a3d974279a2d161746dfbc8ca91774" kindref="member">UART_WriteCancelFxn</ref>)<sp/>(UART_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="631"><highlight class="normal"></highlight></codeline>
<codeline lineno="637" refid="struct_u_a_r_t___fxn_table__" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_u_a_r_t___fxn_table__" kindref="compound">UART_FxnTable_</ref><sp/>{</highlight></codeline>
<codeline lineno="639" refid="struct_u_a_r_t___fxn_table___1a91b9bc339349b571f1752a85808c09e6" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ae08ff15291bd6b21cb4e2eb1fce164a6" kindref="member">UART_CloseFxn</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1a91b9bc339349b571f1752a85808c09e6" kindref="member">closeFxn</ref>;</highlight></codeline>
<codeline lineno="640"><highlight class="normal"></highlight></codeline>
<codeline lineno="642" refid="struct_u_a_r_t___fxn_table___1a63d0403a3c65b008b649f0dcfa2a635d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a583c5e0b34e5806ec225f61d0daed0d6" kindref="member">UART_ControlFxn</ref><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1a63d0403a3c65b008b649f0dcfa2a635d" kindref="member">controlFxn</ref>;</highlight></codeline>
<codeline lineno="643"><highlight class="normal"></highlight></codeline>
<codeline lineno="645" refid="struct_u_a_r_t___fxn_table___1adf5bc14a3aee187f2af8a733832ce0af" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a2b3e89df3065fffb47e7354067c14d1b" kindref="member">UART_InitFxn</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1adf5bc14a3aee187f2af8a733832ce0af" kindref="member">initFxn</ref>;</highlight></codeline>
<codeline lineno="646"><highlight class="normal"></highlight></codeline>
<codeline lineno="648" refid="struct_u_a_r_t___fxn_table___1ad83109d4aeba8cbf8dbbacac36e61fd6" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a39e21ac60f24eb9ce32286e21de713d1" kindref="member">UART_OpenFxn</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1ad83109d4aeba8cbf8dbbacac36e61fd6" kindref="member">openFxn</ref>;</highlight></codeline>
<codeline lineno="649"><highlight class="normal"></highlight></codeline>
<codeline lineno="651" refid="struct_u_a_r_t___fxn_table___1a4f2ca105cea6f46e0b939dfacd763267" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ad1d454c210267a4d04ecce802947633c" kindref="member">UART_ReadFxn</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1a4f2ca105cea6f46e0b939dfacd763267" kindref="member">readFxn</ref>;</highlight></codeline>
<codeline lineno="652"><highlight class="normal"></highlight></codeline>
<codeline lineno="654" refid="struct_u_a_r_t___fxn_table___1a863502e89af278503cdfa1d9493f4534" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1a96c6ef4189723f6ac960a82e6a232b35" kindref="member">UART_ReadPollingFxn</ref><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1a863502e89af278503cdfa1d9493f4534" kindref="member">readPollingFxn</ref>;</highlight></codeline>
<codeline lineno="655"><highlight class="normal"></highlight></codeline>
<codeline lineno="657" refid="struct_u_a_r_t___fxn_table___1a971fb08a118142918ee91fd48b6d03b6" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1aa46296acc2c197a775d44458e1eca197" kindref="member">UART_ReadCancelFxn</ref><sp/><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1a971fb08a118142918ee91fd48b6d03b6" kindref="member">readCancelFxn</ref>;</highlight></codeline>
<codeline lineno="658"><highlight class="normal"></highlight></codeline>
<codeline lineno="660" refid="struct_u_a_r_t___fxn_table___1ad873762990c060a91fb679f1a0f769d0" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1aad6b880dc397d9454038b383d6b821c8" kindref="member">UART_WriteFxn</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1ad873762990c060a91fb679f1a0f769d0" kindref="member">writeFxn</ref>;</highlight></codeline>
<codeline lineno="661"><highlight class="normal"></highlight></codeline>
<codeline lineno="663" refid="struct_u_a_r_t___fxn_table___1a765f0674a82bcf26aa6aba2e0ac71ff7" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1aa6f14597bf561bf987ce6a48dac08076" kindref="member">UART_WritePollingFxn</ref><sp/><ref refid="struct_u_a_r_t___fxn_table___1a765f0674a82bcf26aa6aba2e0ac71ff7" kindref="member">writePollingFxn</ref>;</highlight></codeline>
<codeline lineno="664"><highlight class="normal"></highlight></codeline>
<codeline lineno="666" refid="struct_u_a_r_t___fxn_table___1a1e325b42b7b7122b2b5521a15d88be0f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_u_a_r_t_8h_1ac5a3d974279a2d161746dfbc8ca91774" kindref="member">UART_WriteCancelFxn</ref><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table___1a1e325b42b7b7122b2b5521a15d88be0f" kindref="member">writeCancelFxn</ref>;</highlight></codeline>
<codeline lineno="667"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1ad50e0d914874c8fcbc16b451984a8f5e" kindref="member">UART_FxnTable</ref>;</highlight></codeline>
<codeline lineno="668"><highlight class="normal"></highlight></codeline>
<codeline lineno="680" refid="struct_u_a_r_t___config__" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_u_a_r_t___config__" kindref="compound">UART_Config_</ref><sp/>{</highlight></codeline>
<codeline lineno="682" refid="struct_u_a_r_t___config___1a20c35d866935a4bb465c5a4d02183d74" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_u_a_r_t___fxn_table__" kindref="compound">UART_FxnTable</ref><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>*<ref refid="struct_u_a_r_t___config___1a20c35d866935a4bb465c5a4d02183d74" kindref="member">fxnTablePtr</ref>;</highlight></codeline>
<codeline lineno="683"><highlight class="normal"></highlight></codeline>
<codeline lineno="685" refid="struct_u_a_r_t___config___1a3e4817fc0e2b0225caeda2072acf56c0" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<ref refid="struct_u_a_r_t___config___1a3e4817fc0e2b0225caeda2072acf56c0" kindref="member">object</ref>;</highlight></codeline>
<codeline lineno="686"><highlight class="normal"></highlight></codeline>
<codeline lineno="688" refid="struct_u_a_r_t___config___1a33679e33b65c88fc4e7c2815054923ff" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>*<ref refid="struct_u_a_r_t___config___1a33679e33b65c88fc4e7c2815054923ff" kindref="member">hwAttrs</ref>;</highlight></codeline>
<codeline lineno="689"><highlight class="normal">}<sp/><ref refid="_u_a_r_t_8h_1a68be81b9ce429a5e5c3ac02d285dbd3b" kindref="member">UART_Config</ref>;</highlight></codeline>
<codeline lineno="690"><highlight class="normal"></highlight></codeline>
<codeline lineno="702"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1a6b49b65f3db709c408dc4db23a68895d" kindref="member">UART_close</ref>(UART_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="703"><highlight class="normal"></highlight></codeline>
<codeline lineno="741"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>int_fast16_t<sp/><ref refid="_u_a_r_t_8h_1a5ce79dc51ddc3ef73e8f08983bfee2c7" kindref="member">UART_control</ref>(UART_Handle<sp/>handle,<sp/>uint_fast16_t<sp/>cmd,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*arg);</highlight></codeline>
<codeline lineno="742"><highlight class="normal"></highlight></codeline>
<codeline lineno="750"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1ab60a36f7295d704926120d22f806dcd1" kindref="member">UART_init</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="751"><highlight class="normal"></highlight></codeline>
<codeline lineno="773"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UART_Handle<sp/><ref refid="_u_a_r_t_8h_1ab6d1d6b7b1f9922484f9b8a0f78ed030" kindref="member">UART_open</ref>(uint_least8_t<sp/>index,<sp/><ref refid="struct_u_a_r_t___params__" kindref="compound">UART_Params</ref><sp/>*params);</highlight></codeline>
<codeline lineno="774"><highlight class="normal"></highlight></codeline>
<codeline lineno="797"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1a40e5c0823bb7ffd2e8fbf19f9f20b399" kindref="member">UART_Params_init</ref>(<ref refid="struct_u_a_r_t___params__" kindref="compound">UART_Params</ref><sp/>*params);</highlight></codeline>
<codeline lineno="798"><highlight class="normal"></highlight></codeline>
<codeline lineno="841"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>int_fast32_t<sp/><ref refid="_u_a_r_t_8h_1a1036c2d5258ff70e9afe6cbfc326544f" kindref="member">UART_write</ref>(UART_Handle<sp/>handle,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buffer,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="842"><highlight class="normal"></highlight></codeline>
<codeline lineno="866"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>int_fast32_t<sp/><ref refid="_u_a_r_t_8h_1ad8cda326eb3c05ee05950680bee42e5a" kindref="member">UART_writePolling</ref>(UART_Handle<sp/>handle,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buffer,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="867"><highlight class="normal"></highlight></codeline>
<codeline lineno="879"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1a0482cd0ab9ee7e802c8e785a5754d16d" kindref="member">UART_writeCancel</ref>(UART_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="880"><highlight class="normal"></highlight></codeline>
<codeline lineno="917"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>int_fast32_t<sp/><ref refid="_u_a_r_t_8h_1a15d77f489566ff9f7c9c28d25e9a0135" kindref="member">UART_read</ref>(UART_Handle<sp/>handle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buffer,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="918"><highlight class="normal"></highlight></codeline>
<codeline lineno="939"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>int_fast32_t<sp/><ref refid="_u_a_r_t_8h_1a3ac6ed8cfd03b84198ba6adcd8c248e6" kindref="member">UART_readPolling</ref>(UART_Handle<sp/>handle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buffer,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="940"><highlight class="normal"></highlight></codeline>
<codeline lineno="952"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_u_a_r_t_8h_1a51ed7e94d5b409ca1fcb2d65c5a25c3c" kindref="member">UART_readCancel</ref>(UART_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="953"><highlight class="normal"></highlight></codeline>
<codeline lineno="954"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="955"><highlight class="normal">}</highlight></codeline>
<codeline lineno="956"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="957"><highlight class="normal"></highlight></codeline>
<codeline lineno="958"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>ti_drivers_UART__include<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="exports/tidrivers_msp432/source/ti/drivers/UART.h"/>
  </compounddef>
</doxygen>
