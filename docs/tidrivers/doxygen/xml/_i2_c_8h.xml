<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="_i2_c_8h" kind="file" language="C++">
    <compoundname>I2C.h</compoundname>
    <includes local="no">stdbool.h</includes>
    <includes local="no">stddef.h</includes>
    <includes local="no">stdint.h</includes>
    <includedby refid="_i2_c_m_s_p432_8h" local="no">I2CMSP432.h</includedby>
    <incdepgraph>
      <node id="103">
        <label>stdbool.h</label>
      </node>
      <node id="102">
        <label>I2C.h</label>
        <link refid="_i2_c_8h"/>
        <childnode refid="103" relation="include">
        </childnode>
        <childnode refid="104" relation="include">
        </childnode>
        <childnode refid="105" relation="include">
        </childnode>
      </node>
      <node id="105">
        <label>stdint.h</label>
      </node>
      <node id="104">
        <label>stddef.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="107">
        <label>I2CMSP432.h</label>
        <link refid="_i2_c_m_s_p432_8h"/>
      </node>
      <node id="106">
        <label>I2C.h</label>
        <link refid="_i2_c_8h"/>
        <childnode refid="107" relation="include">
        </childnode>
      </node>
    </invincdepgraph>
    <innerclass refid="struct_i2_c___transaction__" prot="public">I2C_Transaction_</innerclass>
    <innerclass refid="struct_i2_c___params__" prot="public">I2C_Params_</innerclass>
    <innerclass refid="struct_i2_c___fxn_table__" prot="public">I2C_FxnTable_</innerclass>
    <innerclass refid="struct_i2_c___config__" prot="public">I2C_Config_</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="group___i2_c___c_o_n_t_r_o_l_1ga760ec0a6fdb876ccc67b6f06301d53ec" prot="public" static="no">
        <name>I2C_CMD_RESERVED</name>
        <initializer>(32)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Common I2C_control command code reservation offset. I2C driver implementations should offset command codes with <ref refid="group___i2_c___c_o_n_t_r_o_l_1ga760ec0a6fdb876ccc67b6f06301d53ec" kindref="member">I2C_CMD_RESERVED</ref> growing positively</para><para>Example implementation specific command codes: <programlisting><codeline><highlight class="normal">#define<sp/>I2CXYZ_CMD_COMMAND0<sp/><sp/><sp/><sp/><sp/><sp/>I2C_CMD_RESERVED<sp/>+<sp/>0</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>I2CXYZ_CMD_COMMAND1<sp/><sp/><sp/><sp/><sp/><sp/>I2C_CMD_RESERVED<sp/>+<sp/>1</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="348" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="348" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i2_c___c_o_n_t_r_o_l_1gacfd04572fe349d087c2547501cbc7e0a" prot="public" static="no">
        <name>I2C_STATUS_RESERVED</name>
        <initializer>(-32)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Common I2C_control status code reservation offset. I2C driver implementations should offset status codes with <ref refid="group___i2_c___c_o_n_t_r_o_l_1gacfd04572fe349d087c2547501cbc7e0a" kindref="member">I2C_STATUS_RESERVED</ref> growing negatively.</para><para>Example implementation specific status codes: <programlisting><codeline><highlight class="normal">#define<sp/>I2CXYZ_STATUS_ERROR0<sp/><sp/><sp/><sp/><sp/>I2C_STATUS_RESERVED<sp/>-<sp/>0</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>I2CXYZ_STATUS_ERROR1<sp/><sp/><sp/><sp/><sp/>I2C_STATUS_RESERVED<sp/>-<sp/>1</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>I2CXYZ_STATUS_ERROR2<sp/><sp/><sp/><sp/><sp/>I2C_STATUS_RESERVED<sp/>-<sp/>2</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="362" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="362" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i2_c___s_t_a_t_u_s_1gaa0bcf3acd26ac82bd8ff91daba2c78c4" prot="public" static="no">
        <name>I2C_STATUS_SUCCESS</name>
        <initializer>(0)</initializer>
        <briefdescription>
<para>Successful status code returned by <ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control()</ref> returns <ref refid="group___i2_c___s_t_a_t_u_s_1gaa0bcf3acd26ac82bd8ff91daba2c78c4" kindref="member">I2C_STATUS_SUCCESS</ref> if the control code was executed successfully. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="377" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="377" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i2_c___s_t_a_t_u_s_1ga7323fe57c39c46d0da9910e17f5f0b06" prot="public" static="no">
        <name>I2C_STATUS_ERROR</name>
        <initializer>(-1)</initializer>
        <briefdescription>
<para>Generic error status code returned by <ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control()</ref> returns <ref refid="group___i2_c___s_t_a_t_u_s_1ga7323fe57c39c46d0da9910e17f5f0b06" kindref="member">I2C_STATUS_ERROR</ref> if the control code was not executed successfully. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="385" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="385" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i2_c___s_t_a_t_u_s_1ga11c31c9869ed2441789205d9e5967d66" prot="public" static="no">
        <name>I2C_STATUS_UNDEFINEDCMD</name>
        <initializer>(-2)</initializer>
        <briefdescription>
<para>An error status code returned by <ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control()</ref> for undefined command codes. </para>        </briefdescription>
        <detaileddescription>
<para><ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control()</ref> returns <ref refid="group___i2_c___s_t_a_t_u_s_1ga11c31c9869ed2441789205d9e5967d66" kindref="member">I2C_STATUS_UNDEFINEDCMD</ref> if the control code is not recognized by the driver implementation. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="394" column="9" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="394" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfe" prot="public" static="no">
        <name>I2C_TransferMode_</name>
        <enumvalue id="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75" prot="public">
          <name>I2C_MODE_BLOCKING</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>In blocking mode, a thread calling <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> is blocked until the <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> completes. Other threads requesting I2C transactions while a transaction is in progress are also placed into a blocked state. If multiple threads are blocked, the thread with the highest priority will be unblocked first. This implies that queued blocked transactions will not be executed in chronological order. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" prot="public">
          <name>I2C_MODE_CALLBACK</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>In callback mode, a thread calling <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> is not blocked. The application&apos;s callback function, <ref refid="struct_i2_c___params___1acd2b2ca0da16c1f017ac32cc4831b31e" kindref="member">I2C_Params.transferCallbackFxn</ref>, is called when the transaction is complete. The callback function will be called from either a hardware or software interrupt context. This depends on the device specific driver implementation. Sequential calls to <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> will place <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> structures into an internal queue. Queued transactions are automatically started after the previous transaction has completed. This queuing occurs regardless of any error state from previous transactions. The transactions are always executed in chronological order. The <ref refid="struct_i2_c___params___1acd2b2ca0da16c1f017ac32cc4831b31e" kindref="member">I2C_Params.transferCallbackFxn</ref> function will be called as each transaction is completed. </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Specifies the behavior of I2C_Transfer(). </para>        </briefdescription>
        <detaileddescription>
<para>The I2C_TransferMode is specified using the <ref refid="struct_i2_c___params___1a1c126475468cfc6ce397a520aea93936" kindref="member">I2C_Params.transferMode</ref> field. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="460" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="460" bodyend="481"/>
      </memberdef>
      <memberdef kind="enum" id="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9" prot="public" static="no">
        <name>I2C_BitRate_</name>
        <enumvalue id="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a966fd2df13b3a9825615c50335cf1987" prot="public">
          <name>I2C_100kHz</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>I2C Standard-mode. Up to 100 kbit/s. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a83cc3750242e6ae9194cd7ed94f764d9" prot="public">
          <name>I2C_400kHz</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>I2C Fast-mode. Up to 400 kbit/s. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a38a2e32ba65eb0f67b928d181242befa" prot="public">
          <name>I2C_1000kHz</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>I2C Fast-mode Plus. Up to 1Mbit/s. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a37abd9be14a25ed731f14694922ee7d4" prot="public">
          <name>I2C_3330kHz</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>I2C High-speed mode. Up to 3.4Mbit/s. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a0c1376dab54ab817b76de1513b5707fb" prot="public">
          <name>I2C_3400kHz</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>I2C High-speed mode. Up to 3.4Mbit/s. </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Specifies the standard I2C bus bit rate. </para>        </briefdescription>
        <detaileddescription>
<para>The I2C_BitRate is specified using the <ref refid="struct_i2_c___params___1a03607c385a4e9dd1f29338ec0309a858" kindref="member">I2C_Params.bitRate</ref> parameter. You must check that the device specific implementation supports the desired <ref refid="_i2_c_8h_1a47b244d734eccc02dee744a50ac3aba1" kindref="member">I2C_BitRate</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="512" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="512" bodyend="519"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" prot="public" static="no">
        <type>struct <ref refid="struct_i2_c___config__" kindref="compound">I2C_Config_</ref> *</type>
        <definition>typedef struct I2C_Config_* I2C_Handle</definition>
        <argsstring></argsstring>
        <name>I2C_Handle</name>
        <briefdescription>
<para>A handle that is returned from an <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> call. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="414" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="414" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" prot="public" static="no">
        <type>struct <ref refid="struct_i2_c___transaction__" kindref="compound">I2C_Transaction_</ref></type>
        <definition>typedef struct I2C_Transaction_  I2C_Transaction</definition>
        <argsstring></argsstring>
        <name>I2C_Transaction</name>
        <briefdescription>
<para>Structure used to perform I2C bus transfers. </para>        </briefdescription>
        <detaileddescription>
<para>The application is responsible for allocating and initializing an I2C_Transaction structure prior to passing it to I2C_Transfer(). This structure must persist in memory unmodified until the transfer is complete. This driver will always perform write operations first. Transmission of the I2C slave address with the appropriate read/write bit is handled internally by this driver.</para><para><simplesect kind="note"><para><ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> structures cannot be re-used until the previous transaction has completed.</para></simplesect>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="453" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1aafde66e55b9cc9b1b0b7a2b924db4e83" prot="public" static="no">
        <type>enum <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfe" kindref="member">I2C_TransferMode_</ref></type>
        <definition>typedef enum I2C_TransferMode_  I2C_TransferMode</definition>
        <argsstring></argsstring>
        <name>I2C_TransferMode</name>
        <briefdescription>
<para>Specifies the behavior of I2C_Transfer(). </para>        </briefdescription>
        <detaileddescription>
<para>The I2C_TransferMode is specified using the <ref refid="struct_i2_c___params___1a1c126475468cfc6ce397a520aea93936" kindref="member">I2C_Params.transferMode</ref> field. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="481" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1adaa5c99b7c23a00bac52d15a2469764e" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* I2C_CallbackFxn) (I2C_Handle handle, I2C_Transaction *transaction, bool transferStatus)</definition>
        <argsstring>)(I2C_Handle handle, I2C_Transaction *transaction, bool transferStatus)</argsstring>
        <name>I2C_CallbackFxn</name>
        <briefdescription>
<para>I2C callback function prototype. </para>        </briefdescription>
        <detaileddescription>
<para>The application is responsible for declaring a callback function when <ref refid="struct_i2_c___params___1a1c126475468cfc6ce397a520aea93936" kindref="member">I2C_Params.transferMode</ref> is <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" kindref="member">I2C_MODE_CALLBACK</ref>. The callback function is specified using the <ref refid="struct_i2_c___params___1acd2b2ca0da16c1f017ac32cc4831b31e" kindref="member">I2C_Params.transferCallbackFxn</ref> parameter. The callback function will be called from either a hardware or software interrupt context.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref> to the I2C instance that called the <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref>.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transaction</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> that just completed.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transferStatus</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean indicating if the I2C transaction was successful. False indicates the transaction did not complete. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="502" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="502" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1a47b244d734eccc02dee744a50ac3aba1" prot="public" static="no">
        <type>enum <ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9" kindref="member">I2C_BitRate_</ref></type>
        <definition>typedef enum I2C_BitRate_  I2C_BitRate</definition>
        <argsstring></argsstring>
        <name>I2C_BitRate</name>
        <briefdescription>
<para>Specifies the standard I2C bus bit rate. </para>        </briefdescription>
        <detaileddescription>
<para>The I2C_BitRate is specified using the <ref refid="struct_i2_c___params___1a03607c385a4e9dd1f29338ec0309a858" kindref="member">I2C_Params.bitRate</ref> parameter. You must check that the device specific implementation supports the desired <ref refid="_i2_c_8h_1a47b244d734eccc02dee744a50ac3aba1" kindref="member">I2C_BitRate</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="519" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1a98d59fc71988958e7025a17307ada749" prot="public" static="no">
        <type>struct <ref refid="struct_i2_c___params__" kindref="compound">I2C_Params_</ref></type>
        <definition>typedef struct I2C_Params_  I2C_Params</definition>
        <argsstring></argsstring>
        <name>I2C_Params</name>
        <briefdescription>
<para>I2C Parameters. </para>        </briefdescription>
        <detaileddescription>
<para>I2C parameters are used with the <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> call. Default values for these parameters are set using <ref refid="_i2_c_8h_1ab11636302074d67180207ab81ceb323c" kindref="member">I2C_Params_init()</ref>.</para><para><simplesect kind="note"><para>The I2C_Params for a <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref> cannot be changed after <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> has been called. The <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref> can be closed and re-opened with new parameters. See <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> and <ref refid="_i2_c_8h_1a12c86d89a687f2ee1eb980d99c32326d" kindref="member">I2C_close()</ref>.</para></simplesect>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1ab11636302074d67180207ab81ceb323c" kindref="member">I2C_Params_init()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="544" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1a7a829a2a0fd594c50e93c3e55c7d04aa" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* I2C_CancelFxn) (I2C_Handle handle)</definition>
        <argsstring>)(I2C_Handle handle)</argsstring>
        <name>I2C_CancelFxn</name>
        <briefdescription>
<para>A function pointer to a driver-specific implementation of <ref refid="_i2_c_8h_1a8cad0c04a9eca0fffc0ffe5586a5179b" kindref="member">I2C_cancel()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="550" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="550" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1a083200108e980a0ef61e458f0b9fb9e7" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* I2C_CloseFxn) (I2C_Handle handle)</definition>
        <argsstring>)(I2C_Handle handle)</argsstring>
        <name>I2C_CloseFxn</name>
        <briefdescription>
<para>A function pointer to a driver-specific implementation of <ref refid="_i2_c_8h_1a12c86d89a687f2ee1eb980d99c32326d" kindref="member">I2C_close()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="556" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="556" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1a2b3563e0ae9a6ce2be82bdc938ae5218" prot="public" static="no">
        <type>int_fast16_t(*</type>
        <definition>typedef int_fast16_t(* I2C_ControlFxn) (I2C_Handle handle, uint_fast16_t cmd, void *controlArg)</definition>
        <argsstring>)(I2C_Handle handle, uint_fast16_t cmd, void *controlArg)</argsstring>
        <name>I2C_ControlFxn</name>
        <briefdescription>
<para>A function pointer to a driver-specific implementation of <ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="562" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="562" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1adfb2451c8a1ce70402e43e4743c5fedf" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* I2C_InitFxn) (I2C_Handle handle)</definition>
        <argsstring>)(I2C_Handle handle)</argsstring>
        <name>I2C_InitFxn</name>
        <briefdescription>
<para>A function pointer to a driver-specific implementation of <ref refid="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" kindref="member">I2C_init()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="569" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="569" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1add24fcdaaf1bdef1521ce2489bf1d80e" prot="public" static="no">
        <type><ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref>(*</type>
        <definition>typedef I2C_Handle(* I2C_OpenFxn) (I2C_Handle handle, I2C_Params *params)</definition>
        <argsstring>)(I2C_Handle handle, I2C_Params *params)</argsstring>
        <name>I2C_OpenFxn</name>
        <briefdescription>
<para>A function pointer to a driver-specific implementation of <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="575" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="575" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1aa785484e689c79262f98208689fecd38" prot="public" static="no">
        <type>bool(*</type>
        <definition>typedef bool(* I2C_TransferFxn) (I2C_Handle handle, I2C_Transaction *transaction)</definition>
        <argsstring>)(I2C_Handle handle, I2C_Transaction *transaction)</argsstring>
        <name>I2C_TransferFxn</name>
        <briefdescription>
<para>A function pointer to a driver-specific implementation of <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="581" column="1" bodyfile="exports/tidrivers_msp432/source/ti/drivers/I2C.h" bodystart="581" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1a58fd875c3596b3856b6f1aebbceb3085" prot="public" static="no">
        <type>struct <ref refid="struct_i2_c___fxn_table__" kindref="compound">I2C_FxnTable_</ref></type>
        <definition>typedef struct I2C_FxnTable_  I2C_FxnTable</definition>
        <argsstring></argsstring>
        <name>I2C_FxnTable</name>
        <briefdescription>
<para>The definition of an I2C function table that contains the required set of functions to control a specific I2C driver implementation. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="596" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="_i2_c_8h_1ae43e4c7b224a8cc37764acb792182453" prot="public" static="no">
        <type>struct <ref refid="struct_i2_c___config__" kindref="compound">I2C_Config_</ref></type>
        <definition>typedef struct I2C_Config_  I2C_Config</definition>
        <argsstring></argsstring>
        <name>I2C_Config</name>
        <briefdescription>
<para>I2C global configuration. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="_i2_c_8h_1ae43e4c7b224a8cc37764acb792182453" kindref="member">I2C_Config</ref> structure contains a set of pointers used to characterize the I2C driver implementation.</para><para>This structure needs to be defined before calling <ref refid="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" kindref="member">I2C_init()</ref> and it must not be changed thereafter.</para><para><simplesect kind="see"><para><ref refid="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" kindref="member">I2C_init()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="618" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="_i2_c_8h_1a8cad0c04a9eca0fffc0ffe5586a5179b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void I2C_cancel</definition>
        <argsstring>(I2C_Handle handle)</argsstring>
        <name>I2C_cancel</name>
        <param>
          <type><ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <briefdescription>
<para>Cancels all I2C transfers. </para>        </briefdescription>
        <detaileddescription>
<para>This function will cancel asynchronous <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> operations, and is applicable only for <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" kindref="member">I2C_MODE_CALLBACK</ref> mode. The in progress transfer, as well as any queued transfers, will be canceled. The individual callback functions for each transfer will be called in chronological order. The callback functions are called in the same context as the <ref refid="_i2_c_8h_1a8cad0c04a9eca0fffc0ffe5586a5179b" kindref="member">I2C_cancel()</ref>.</para><para><simplesect kind="pre"><para>I2C_Transfer() has been called.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>An <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref> returned from <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Different I2C slave devices will behave differently when an in-progress transfer fails and needs to be canceled. The slave may need to be reset, or there may be other slave-specific steps that can be used to successfully resume communication.</para></simplesect>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="640" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_i2_c_8h_1a12c86d89a687f2ee1eb980d99c32326d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void I2C_close</definition>
        <argsstring>(I2C_Handle handle)</argsstring>
        <name>I2C_close</name>
        <param>
          <type><ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <briefdescription>
<para>Close an I2C driver instance specified by an <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> has been called.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>An <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref> returned from <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="651" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int_fast16_t</type>
        <definition>int_fast16_t I2C_control</definition>
        <argsstring>(I2C_Handle handle, uint_fast16_t cmd, void *controlArg)</argsstring>
        <name>I2C_control</name>
        <param>
          <type><ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <param>
          <type>uint_fast16_t</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>controlArg</declname>
        </param>
        <briefdescription>
<para>Perform implementation-specific features on a given <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Commands for <ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control()</ref> can originate from <ref refid="_i2_c_8h" kindref="compound">I2C.h</ref> or from device specific implementations files. While commands from <ref refid="_i2_c_8h" kindref="compound">I2C.h</ref> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific I2C*.h files add unique driver capabilities but are not API portable across all I2C driver implementations.</para><para>Commands supported by <ref refid="_i2_c_8h" kindref="compound">I2C.h</ref> follow a I2C_CMD_&lt;cmd&gt; naming convention.<linebreak/>
 Commands supported by <ref refid="_i2_c_8h" kindref="compound">I2C.h</ref> follow a I2C_CMD_&lt;cmd&gt; naming convention.<linebreak/>
 Each control command defines <bold>arg</bold> differently. The types of <bold>arg</bold> are documented with each command.</para><para>See <ref refid="group___i2_c___c_o_n_t_r_o_l" kindref="compound">I2C_control command codes</ref> for command codes.</para><para>See <ref refid="group___i2_c___s_t_a_t_u_s" kindref="compound">I2C_control return status codes</ref> for status codes.</para><para><simplesect kind="pre"><para><ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> has to be called first.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>An <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref> returned from <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmd</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___i2_c___c_o_n_t_r_o_l" kindref="compound">I2C_control command and status codes</ref> command.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>controlArg</parametername>
</parameternamelist>
<parameterdescription>
<para>An optional R/W (read/write) command argument accompanied with cmd</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Implementation-specific return codes. Negative values indicate unsuccessful operations.</para></simplesect>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="690" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void I2C_init</definition>
        <argsstring>(void)</argsstring>
        <name>I2C_init</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Initializes the I2C module. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para>The <computeroutput>I2C_config</computeroutput> structure must exist and be persistent before this function can be called. This function must also be called before any other I2C driver APIs. This function call does not modify any peripheral registers. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="701" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref></type>
        <definition>I2C_Handle I2C_open</definition>
        <argsstring>(uint_least8_t index, I2C_Params *params)</argsstring>
        <name>I2C_open</name>
        <param>
          <type>uint_least8_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type><ref refid="_i2_c_8h_1a98d59fc71988958e7025a17307ada749" kindref="member">I2C_Params</ref> *</type>
          <declname>params</declname>
        </param>
        <briefdescription>
<para>Open an I2C instance. </para>        </briefdescription>
        <detaileddescription>
<para>Initialize a given I2C driver instance as identified by an index value.</para><para><simplesect kind="pre"><para><ref refid="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" kindref="member">I2C_init()</ref> has been called.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Indexed into the I2C_config table</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a parameter block. Default values will be used if <computeroutput>NULL</computeroutput> is specified for <computeroutput>params</computeroutput>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref> on success, or <computeroutput>NULL</computeroutput> on an error.</para></simplesect>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" kindref="member">I2C_init()</ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1a12c86d89a687f2ee1eb980d99c32326d" kindref="member">I2C_close()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="720" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_i2_c_8h_1ab11636302074d67180207ab81ceb323c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void I2C_Params_init</definition>
        <argsstring>(I2C_Params *params)</argsstring>
        <name>I2C_Params_init</name>
        <param>
          <type><ref refid="_i2_c_8h_1a98d59fc71988958e7025a17307ada749" kindref="member">I2C_Params</ref> *</type>
          <declname>params</declname>
        </param>
        <briefdescription>
<para>Initialize an <ref refid="_i2_c_8h_1a98d59fc71988958e7025a17307ada749" kindref="member">I2C_Params</ref> structure to its default values. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to <ref refid="_i2_c_8h_1a98d59fc71988958e7025a17307ada749" kindref="member">I2C_Params</ref> structure for initialization.</para></parameterdescription>
</parameteritem>
</parameterlist>
Defaults values are:<itemizedlist>
<listitem><para><ref refid="struct_i2_c___params___1a1c126475468cfc6ce397a520aea93936" kindref="member">I2C_Params.transferMode</ref> = <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75" kindref="member">I2C_MODE_BLOCKING</ref></para></listitem><listitem><para><ref refid="struct_i2_c___params___1acd2b2ca0da16c1f017ac32cc4831b31e" kindref="member">I2C_Params.transferCallbackFxn</ref> = <computeroutput>NULL</computeroutput> </para></listitem><listitem><para><ref refid="struct_i2_c___params___1a03607c385a4e9dd1f29338ec0309a858" kindref="member">I2C_Params.bitRate</ref> = <ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a966fd2df13b3a9825615c50335cf1987" kindref="member">I2C_100kHz</ref></para></listitem><listitem><para><ref refid="struct_i2_c___params___1ac44da2d70d79ffa122d791b37864d457" kindref="member">I2C_Params.custom</ref> = <computeroutput>NULL</computeroutput> </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="734" column="1"/>
      </memberdef>
      <memberdef kind="function" id="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool I2C_transfer</definition>
        <argsstring>(I2C_Handle handle, I2C_Transaction *transaction)</argsstring>
        <name>I2C_transfer</name>
        <param>
          <type><ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref></type>
          <declname>handle</declname>
        </param>
        <param>
          <type><ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> *</type>
          <declname>transaction</declname>
        </param>
        <briefdescription>
<para>Perform an I2C transaction with an I2C slave peripheral. </para>        </briefdescription>
        <detaileddescription>
<para>This function will perform an I2C transfer, as specified by an <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> structure.</para><para>The data written to the peripheral is preceded with the peripheral&apos;s 7-bit I2C slave address (with the Write bit set). After all the data has been transmitted, the driver will evaluate if any data needs to be read from the device. If yes, another START bit is sent, along with the same 7-bit I2C slave address (with the Read bit). After the specified number of bytes have been read, the transfer is ended with a NACK and a STOP bit. Otherwise, if no data is to be read, the transfer is concluded with a STOP bit.</para><para>In <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75" kindref="member">I2C_MODE_BLOCKING</ref>, <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> will block thread execution until the transaction completes. When using blocking mode, this function must be called from a thread context.</para><para>In <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" kindref="member">I2C_MODE_CALLBACK</ref>, the <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> call does not block thread execution. Success or failure of the transaction is reported via the <ref refid="_i2_c_8h_1adaa5c99b7c23a00bac52d15a2469764e" kindref="member">I2C_CallbackFxn</ref> <bold>bool</bold> argument. If a transfer is already in progress, the new transaction is put on an internal queue. The driver services the queue in a first come first served basis. When using callback mode, this function can be called from any context.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>An <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transaction</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to an <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref>. All of the fields within the transaction structure should be considered write only, unless otherwise noted in the driver implementation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> structure must persist unmodified until the corresponding call to <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> has completed.</para></simplesect>
<simplesect kind="return"><para>In <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75" kindref="member">I2C_MODE_BLOCKING</ref>: <computeroutput>true</computeroutput> for a successful transfer; <computeroutput>false</computeroutput> for an error (for example, an I2C bus fault (NACK)).</para></simplesect>
<simplesect kind="return"><para>In <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" kindref="member">I2C_MODE_CALLBACK</ref>: always <computeroutput>true</computeroutput>. The <ref refid="_i2_c_8h_1adaa5c99b7c23a00bac52d15a2469764e" kindref="member">I2C_CallbackFxn</ref> <computeroutput>bool</computeroutput> argument will be <computeroutput>true</computeroutput> to indicate success, and <computeroutput>false</computeroutput> to indicate an error.</para></simplesect>
<simplesect kind="see"><para><ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h" line="781" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Inter-Integrated Circuit driver interface. </para>    </briefdescription>
    <detaileddescription>
<para><hruler/>
</para><para>The I2C header file should be included in an application as follows: <programlisting><codeline><highlight class="normal">#include<sp/>&lt;ti/drivers/I2C.h&gt;</highlight></codeline>
</programlisting></para><para>This module serves as the main interface for applications using an underlying I2C peripheral. Its purpose is to redirect the I2C APIs to device specific driver implementations which are specified using a pointer to a <ref refid="_i2_c_8h_1a58fd875c3596b3856b6f1aebbceb3085" kindref="member">I2C_FxnTable</ref>.</para><para><heading level="1">Overview</heading>
</para><para>This section assumes that you have prior knowledge about the I2C protocol. For the full I2C-bus specification and user manual, view the <bold>UM10204</bold> document available online.</para><para>This I2C driver is designed to operate as an I2C master and will not function as an I2C slave. Multi-master arbitration is not supported; therefore, this driver assumes it is the only I2C master on the bus. This I2C driver&apos;s API set provides the ability to transmit and receive data over an I2C bus between the I2C master and I2C slave(s). The application is responsible for manipulating and interpreting the data.</para><para><heading level="1">Thread Safety</heading>
</para><para>This driver has been designed to operate with a Real-Time Operating System (RTOS). All I2C APIs are globally thread safe.</para><para><heading level="1">I2C Driver Configuration</heading>
</para><para>In order to use the I2C APIs, the application is required to provide device-specific I2C configuration in the Board.c file. The I2C driver interface defines a configuration data structure, <ref refid="_i2_c_8h_1ae43e4c7b224a8cc37764acb792182453" kindref="member">I2C_Config</ref>.</para><para>The application must declare an array of <ref refid="_i2_c_8h_1ae43e4c7b224a8cc37764acb792182453" kindref="member">I2C_Config</ref> elements, named <computeroutput>I2C_config</computeroutput>[]. Each element of <computeroutput>I2C_config</computeroutput>[] is populated with pointers to a device specific I2C driver implementation&apos;s function table, driver object, and hardware attributes. The hardware attributes define properties such as the I2C peripheral&apos;s base address and pins. Each element in <computeroutput>I2C_config</computeroutput>[] corresponds to an I2C instance, and none of the elements should have <computeroutput>NULL</computeroutput> pointers.</para><para>The I2C configuration is device dependent. You will need to check the device specific I2C driver documentation. There you will find a description of the I2C hardware attributes.</para><para><heading level="1">Usage</heading>
</para><para>For general usage, refer to the function documentation.</para><para><heading level="2">Initializing the I2C Driver</heading>
</para><para><ref refid="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" kindref="member">I2C_init()</ref> must be called before any other I2C API. This function calls the device specific implementation&apos;s I2C initialization function for each element of <computeroutput>I2C_config</computeroutput>[].</para><para><heading level="2">Opening the I2C Driver</heading>
</para><para>After calling <ref refid="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" kindref="member">I2C_init()</ref>, the application can open an I2C instance by calling <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref>. This function takes an index into the <computeroutput>I2C_config</computeroutput>[] array and an <ref refid="_i2_c_8h_1a98d59fc71988958e7025a17307ada749" kindref="member">I2C_Params</ref> structure. The <ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref> returned from the <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> is then associated with that index into the <computeroutput>I2C_config</computeroutput>[] array. The following code example opens an I2C instance with default parameters by passing <computeroutput>NULL</computeroutput> for the <ref refid="_i2_c_8h_1a98d59fc71988958e7025a17307ada749" kindref="member">I2C_Params</ref> argument.</para><para><programlisting><codeline><highlight class="normal">I2C_Handle<sp/>i2cHandle;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">i2cHandle<sp/>=<sp/>I2C_open(Board_I2C0,<sp/>NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(i2cHandle<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Error<sp/>opening<sp/>I2C</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(1)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><simplesect kind="note"><para>Each I2C index can only be opened exclusively. Calling <ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open()</ref> multiple times with the same index will result in an error. The index can be re-used if <ref refid="_i2_c_8h_1a12c86d89a687f2ee1eb980d99c32326d" kindref="member">I2C_close()</ref> is called first.</para></simplesect>
This example shows opening an I2C driver instance in <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" kindref="member">I2C_MODE_CALLBACK</ref> with a bit rate of <ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a83cc3750242e6ae9194cd7ed94f764d9" kindref="member">I2C_400kHz</ref>.</para><para><programlisting><codeline><highlight class="normal">void<sp/>myCallbackFxn(I2C_Handle<sp/>handle,<sp/>I2C_Transaction<sp/>*msg,<sp/>bool<sp/>status)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//transfer<sp/>failed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><programlisting><codeline><highlight class="normal">I2C_Handle<sp/>i2cHandle;</highlight></codeline>
<codeline><highlight class="normal">I2C_Params<sp/>i2cParams;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">I2C_Params_init(&amp;i2cParams);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">i2cParams.transferMode<sp/>=<sp/>I2C_MODE_CALLBACK;</highlight></codeline>
<codeline><highlight class="normal">i2cParams.transferCallbackFxn<sp/>=<sp/>myCallbackFxn;</highlight></codeline>
<codeline><highlight class="normal">i2cParams.bitRate<sp/>=<sp/>I2C_400kHz;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">i2cHandle<sp/>=<sp/>I2C_open(Board_I2C0,<sp/>&amp;i2cParams);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(i2cHandle<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Error<sp/>opening<sp/>I2C</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="2">Transferring data</heading>
</para><para>An I2C data transfer is performed using the <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> function. Three types of transactions are supported: write, read, and write + read. The details of each transaction are specified with an <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> structure. Each transfer is completed before another transfer is initiated.</para><para>For write + read transactions, the specified data is first written to the peripheral, then a repeated start is sent by the driver, which initiates the read operation. This type of transfer is useful if an I2C peripheral has a pointer register that needs to be adjusted prior to reading from the referenced data register.</para><para>The following examples assume an I2C instance has been opened in <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75" kindref="member">I2C_MODE_BLOCKING</ref> mode. <hruler/>
</para><para>Sending three bytes of data.</para><para><programlisting><codeline><highlight class="normal">I2C_Transaction<sp/>i2cTransaction;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>writeBuffer[3];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">writeBuffer[0]<sp/>=<sp/>0xAB;</highlight></codeline>
<codeline><highlight class="normal">writeBuffer[1]<sp/>=<sp/>0xCD;</highlight></codeline>
<codeline><highlight class="normal">writeBuffer[2]<sp/>=<sp/>0xEF;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">i2cTransaction.slaveAddress<sp/>=<sp/>0x50;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.writeBuf<sp/>=<sp/>writeBuffer;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.writeCount<sp/>=<sp/>3;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.readBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.readCount<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">status<sp/>=<sp/>I2C_transfer(i2cHandle,<sp/>&amp;i2cTransaction);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Unsuccessful<sp/>I2C<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Reading five bytes of data.</para><para><programlisting><codeline><highlight class="normal">I2C_Transaction<sp/>i2cTransaction;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>readBuffer[5];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">i2cTransaction.slaveAddress<sp/>=<sp/>0x50;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.writeBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.writeCount<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.readBuf<sp/>=<sp/>readBuffer;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.readCount<sp/>=<sp/>5;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">status<sp/>=<sp/>I2C_transfer(i2cHandle,<sp/>&amp;i2cTransaction);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Unsuccessful<sp/>I2C<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Writing two bytes and reading four bytes in a single transaction.</para><para><programlisting><codeline><highlight class="normal">I2C_Transaction<sp/>i2cTransaction;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>readBuffer[4];</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>writeBuffer[2];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">writeBuffer[0]<sp/>=<sp/>0xAB;</highlight></codeline>
<codeline><highlight class="normal">writeBuffer[1]<sp/>=<sp/>0xCD;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">i2cTransaction.slaveAddress<sp/>=<sp/>0x50;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.writeBuf<sp/>=<sp/>writeBuffer;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.writeCount<sp/>=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.readBuf<sp/>=<sp/>readBuffer;</highlight></codeline>
<codeline><highlight class="normal">i2cTransaction.readCount<sp/>=<sp/>4;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">status<sp/>=<sp/>I2C_transfer(i2cHandle,<sp/>&amp;i2cTransaction);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Unsuccessful<sp/>I2C<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> <hruler/>
</para><para>This final example shows usage of <ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" kindref="member">I2C_MODE_CALLBACK</ref>, with queuing of multiple transactions. Because multiple transactions are simultaneously queued, separate <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> structures must be used. Each <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> will contain a custom application argument of a semaphore handle. The <ref refid="struct_i2_c___transaction___1a5c74a2359742d69b0e9108bb342ded00" kindref="member">I2C_Transaction.arg</ref> will point to the semaphore handle. When the callback function is called, the <ref refid="struct_i2_c___transaction___1a5c74a2359742d69b0e9108bb342ded00" kindref="member">I2C_Transaction.arg</ref> is checked for <computeroutput>NULL</computeroutput>. If this value is not <computeroutput>NULL</computeroutput>, then it can be assumed the <computeroutput>arg</computeroutput> is pointing to a valid semaphore handle. The semaphore handle is then used to call <computeroutput>sem_post()</computeroutput>. Hypothetically, this can be used to signal transaction completion to the task(s) that queued the transaction(s).</para><para><programlisting><codeline><highlight class="normal">void<sp/>callbackFxn(I2C_Handle<sp/>handle,<sp/>I2C_Transaction<sp/>*msg,<sp/>bool<sp/>status)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//transaction<sp/>failed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Check<sp/>for<sp/>a<sp/>semaphore<sp/>handle</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(msg-&gt;arg<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Perform<sp/>a<sp/>semaphore<sp/>post</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sem_post((sem_t<sp/>*)<sp/>(msg-&gt;arg));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Snippets of the thread code that initiates the transactions are shown below. Note the use of multiple <ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref> structures. The handle of the semaphore to be posted is specified via <computeroutput>i2cTransaction2.arg</computeroutput>. <ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer()</ref> is called three times to initiate each transaction. Since callback mode is used, these functions return immediately. After the transactions have been queued, other work can be done. Eventually, <computeroutput>sem_wait()</computeroutput> is called causing the thread to block until the transaction completes. When the transaction completes, the application&apos;s callback function, <computeroutput>callbackFxn</computeroutput> will be called. Once <computeroutput>callbackFxn</computeroutput> posts the semaphore, the thread will be unblocked and can resume execution.</para><para><programlisting><codeline><highlight class="normal">void<sp/>thread(arg0,<sp/>arg1)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>I2C_Transaction<sp/>i2cTransaction0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>I2C_Transaction<sp/>i2cTransaction1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>I2C_Transaction<sp/>i2cTransaction2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>i2cTransaction0.arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>i2cTransaction1.arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>i2cTransaction2.arg<sp/>=<sp/>semaphoreHandle;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>I2C_transfer(i2c,<sp/>&amp;i2cTransaction0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>I2C_transfer(i2c,<sp/>&amp;i2cTransaction1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>I2C_transfer(i2c,<sp/>&amp;i2cTransaction2);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_wait(semaphoreHandle);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="1">Implementation</heading>
</para><para>This top-level I2C module serves as the main interface for RTOS applications. Its purpose is to redirect the module&apos;s APIs to specific peripheral implementations which are specified using a pointer to an <ref refid="_i2_c_8h_1a58fd875c3596b3856b6f1aebbceb3085" kindref="member">I2C_FxnTable</ref>.</para><para>The I2C driver interface module is joined (at link time) to an array of <ref refid="_i2_c_8h_1ae43e4c7b224a8cc37764acb792182453" kindref="member">I2C_Config</ref> data structures named <computeroutput>I2C_config</computeroutput>. <computeroutput>I2C_config</computeroutput> is typically defined in the Board.c file used for the application. If there are multiple instances of I2C peripherals on the device, there will typically be multiple <ref refid="_i2_c_8h_1ae43e4c7b224a8cc37764acb792182453" kindref="member">I2C_Config</ref> structures defined in the board file in the form of an array. Each entry in <computeroutput>I2C_config</computeroutput> contains a:<itemizedlist>
<listitem><para><ref refid="_i2_c_8h_1a58fd875c3596b3856b6f1aebbceb3085" kindref="member">I2C_FxnTable</ref> pointer to a set of functions that implement an I2C peripheral.</para></listitem><listitem><para>(<computeroutput>void</computeroutput> *) data object that is associated with the <ref refid="_i2_c_8h_1a58fd875c3596b3856b6f1aebbceb3085" kindref="member">I2C_FxnTable</ref></para></listitem><listitem><para>(<computeroutput>void</computeroutput> *) hardware attributes that are associated to the <ref refid="_i2_c_8h_1a58fd875c3596b3856b6f1aebbceb3085" kindref="member">I2C_FxnTable</ref> </para></listitem></itemizedlist>
</para>    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2015-2018,<sp/>Texas<sp/>Instruments<sp/>Incorporated</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*<sp/>Redistribution<sp/>and<sp/>use<sp/>in<sp/>source<sp/>and<sp/>binary<sp/>forms,<sp/>with<sp/>or<sp/>without</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*<sp/>modification,<sp/>are<sp/>permitted<sp/>provided<sp/>that<sp/>the<sp/>following<sp/>conditions</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>*<sp/>are<sp/>met:</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Redistributions<sp/>of<sp/>source<sp/>code<sp/>must<sp/>retain<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer.</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Redistributions<sp/>in<sp/>binary<sp/>form<sp/>must<sp/>reproduce<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer<sp/>in<sp/>the</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>documentation<sp/>and/or<sp/>other<sp/>materials<sp/>provided<sp/>with<sp/>the<sp/>distribution.</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Neither<sp/>the<sp/>name<sp/>of<sp/>Texas<sp/>Instruments<sp/>Incorporated<sp/>nor<sp/>the<sp/>names<sp/>of</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>its<sp/>contributors<sp/>may<sp/>be<sp/>used<sp/>to<sp/>endorse<sp/>or<sp/>promote<sp/>products<sp/>derived</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>from<sp/>this<sp/>software<sp/>without<sp/>specific<sp/>prior<sp/>written<sp/>permission.</highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*<sp/>THIS<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>BY<sp/>THE<sp/>COPYRIGHT<sp/>HOLDERS<sp/>AND<sp/>CONTRIBUTORS<sp/>&quot;AS<sp/>IS&quot;</highlight></codeline>
<codeline lineno="21"><highlight class="comment"><sp/>*<sp/>AND<sp/>ANY<sp/>EXPRESS<sp/>OR<sp/>IMPLIED<sp/>WARRANTIES,<sp/>INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,</highlight></codeline>
<codeline lineno="22"><highlight class="comment"><sp/>*<sp/>THE<sp/>IMPLIED<sp/>WARRANTIES<sp/>OF<sp/>MERCHANTABILITY<sp/>AND<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR</highlight></codeline>
<codeline lineno="23"><highlight class="comment"><sp/>*<sp/>PURPOSE<sp/>ARE<sp/>DISCLAIMED.<sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>THE<sp/>COPYRIGHT<sp/>OWNER<sp/>OR</highlight></codeline>
<codeline lineno="24"><highlight class="comment"><sp/>*<sp/>CONTRIBUTORS<sp/>BE<sp/>LIABLE<sp/>FOR<sp/>ANY<sp/>DIRECT,<sp/>INDIRECT,<sp/>INCIDENTAL,<sp/>SPECIAL,</highlight></codeline>
<codeline lineno="25"><highlight class="comment"><sp/>*<sp/>EXEMPLARY,<sp/>OR<sp/>CONSEQUENTIAL<sp/>DAMAGES<sp/>(INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,</highlight></codeline>
<codeline lineno="26"><highlight class="comment"><sp/>*<sp/>PROCUREMENT<sp/>OF<sp/>SUBSTITUTE<sp/>GOODS<sp/>OR<sp/>SERVICES;<sp/>LOSS<sp/>OF<sp/>USE,<sp/>DATA,<sp/>OR<sp/>PROFITS;</highlight></codeline>
<codeline lineno="27"><highlight class="comment"><sp/>*<sp/>OR<sp/>BUSINESS<sp/>INTERRUPTION)<sp/>HOWEVER<sp/>CAUSED<sp/>AND<sp/>ON<sp/>ANY<sp/>THEORY<sp/>OF<sp/>LIABILITY,</highlight></codeline>
<codeline lineno="28"><highlight class="comment"><sp/>*<sp/>WHETHER<sp/>IN<sp/>CONTRACT,<sp/>STRICT<sp/>LIABILITY,<sp/>OR<sp/>TORT<sp/>(INCLUDING<sp/>NEGLIGENCE<sp/>OR</highlight></codeline>
<codeline lineno="29"><highlight class="comment"><sp/>*<sp/>OTHERWISE)<sp/>ARISING<sp/>IN<sp/>ANY<sp/>WAY<sp/>OUT<sp/>OF<sp/>THE<sp/>USE<sp/>OF<sp/>THIS<sp/>SOFTWARE,</highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/>*<sp/>EVEN<sp/>IF<sp/>ADVISED<sp/>OF<sp/>THE<sp/>POSSIBILITY<sp/>OF<sp/>SUCH<sp/>DAMAGE.</highlight></codeline>
<codeline lineno="31"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight><highlight class="comment">/*!****************************************************************************</highlight></codeline>
<codeline lineno="33"><highlight class="comment"><sp/>*<sp/><sp/>@file<sp/><sp/><sp/><sp/><sp/><sp/><sp/>I2C.h</highlight></codeline>
<codeline lineno="34"><highlight class="comment"><sp/>*<sp/><sp/>@brief<sp/><sp/><sp/><sp/><sp/><sp/>Inter-Integrated<sp/>Circuit<sp/>driver<sp/>interface.</highlight></codeline>
<codeline lineno="35"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="36"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>I2C<sp/>header<sp/>file<sp/>should<sp/>be<sp/>included<sp/>in<sp/>an<sp/>application<sp/>as<sp/>follows:</highlight></codeline>
<codeline lineno="37"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="38"><highlight class="comment"><sp/>*<sp/><sp/>#include<sp/>&lt;ti/drivers/I2C.h&gt;</highlight></codeline>
<codeline lineno="39"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="40"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="41"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>module<sp/>serves<sp/>as<sp/>the<sp/>main<sp/>interface<sp/>for<sp/>applications<sp/>using<sp/>an</highlight></codeline>
<codeline lineno="42"><highlight class="comment"><sp/>*<sp/><sp/>underlying<sp/>I2C<sp/>peripheral.<sp/>Its<sp/>purpose<sp/>is<sp/>to<sp/>redirect<sp/>the<sp/>I2C<sp/>APIs<sp/>to</highlight></codeline>
<codeline lineno="43"><highlight class="comment"><sp/>*<sp/><sp/>device<sp/>specific<sp/>driver<sp/>implementations<sp/>which<sp/>are<sp/>specified<sp/>using<sp/>a<sp/>pointer</highlight></codeline>
<codeline lineno="44"><highlight class="comment"><sp/>*<sp/><sp/>to<sp/>a<sp/>#I2C_FxnTable.</highlight></codeline>
<codeline lineno="45"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="46"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>Overview<sp/>#</highlight></codeline>
<codeline lineno="47"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="48"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>section<sp/>assumes<sp/>that<sp/>you<sp/>have<sp/>prior<sp/>knowledge<sp/>about<sp/>the<sp/>I2C<sp/>protocol.</highlight></codeline>
<codeline lineno="49"><highlight class="comment"><sp/>*<sp/><sp/>For<sp/>the<sp/>full<sp/>I2C-bus<sp/>specification<sp/>and<sp/>user<sp/>manual,<sp/>view<sp/>the<sp/>\b<sp/>UM10204</highlight></codeline>
<codeline lineno="50"><highlight class="comment"><sp/>*<sp/><sp/>document<sp/>available<sp/>online.</highlight></codeline>
<codeline lineno="51"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="52"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>I2C<sp/>driver<sp/>is<sp/>designed<sp/>to<sp/>operate<sp/>as<sp/>an<sp/>I2C<sp/>master<sp/>and<sp/>will<sp/>not</highlight></codeline>
<codeline lineno="53"><highlight class="comment"><sp/>*<sp/><sp/>function<sp/>as<sp/>an<sp/>I2C<sp/>slave.<sp/>Multi-master<sp/>arbitration<sp/>is<sp/>not<sp/>supported;</highlight></codeline>
<codeline lineno="54"><highlight class="comment"><sp/>*<sp/><sp/>therefore,<sp/>this<sp/>driver<sp/>assumes<sp/>it<sp/>is<sp/>the<sp/>only<sp/>I2C<sp/>master<sp/>on<sp/>the<sp/>bus.</highlight></codeline>
<codeline lineno="55"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>I2C<sp/>driver&apos;s<sp/>API<sp/>set<sp/>provides<sp/>the<sp/>ability<sp/>to<sp/>transmit<sp/>and<sp/>receive</highlight></codeline>
<codeline lineno="56"><highlight class="comment"><sp/>*<sp/><sp/>data<sp/>over<sp/>an<sp/>I2C<sp/>bus<sp/>between<sp/>the<sp/>I2C<sp/>master<sp/>and<sp/>I2C<sp/>slave(s).<sp/>The</highlight></codeline>
<codeline lineno="57"><highlight class="comment"><sp/>*<sp/><sp/>application<sp/>is<sp/>responsible<sp/>for<sp/>manipulating<sp/>and<sp/>interpreting<sp/>the<sp/>data.</highlight></codeline>
<codeline lineno="58"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="59"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>Thread<sp/>Safety<sp/>#</highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="61"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>driver<sp/>has<sp/>been<sp/>designed<sp/>to<sp/>operate<sp/>with<sp/>a<sp/>Real-Time<sp/>Operating<sp/>System</highlight></codeline>
<codeline lineno="62"><highlight class="comment"><sp/>*<sp/><sp/>(RTOS).<sp/>All<sp/>I2C<sp/>APIs<sp/>are<sp/>globally<sp/>thread<sp/>safe.</highlight></codeline>
<codeline lineno="63"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="64"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>I2C<sp/>Driver<sp/>Configuration<sp/>#</highlight></codeline>
<codeline lineno="65"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="66"><highlight class="comment"><sp/>*<sp/><sp/>In<sp/>order<sp/>to<sp/>use<sp/>the<sp/>I2C<sp/>APIs,<sp/>the<sp/>application<sp/>is<sp/>required<sp/>to<sp/>provide</highlight></codeline>
<codeline lineno="67"><highlight class="comment"><sp/>*<sp/><sp/>device-specific<sp/>I2C<sp/>configuration<sp/>in<sp/>the<sp/>Board.c<sp/>file.<sp/>The<sp/>I2C<sp/>driver</highlight></codeline>
<codeline lineno="68"><highlight class="comment"><sp/>*<sp/><sp/>interface<sp/>defines<sp/>a<sp/>configuration<sp/>data<sp/>structure,<sp/>#I2C_Config.</highlight></codeline>
<codeline lineno="69"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="70"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>application<sp/>must<sp/>declare<sp/>an<sp/>array<sp/>of<sp/>#I2C_Config<sp/>elements,<sp/>named</highlight></codeline>
<codeline lineno="71"><highlight class="comment"><sp/>*<sp/><sp/>\p<sp/>I2C_config[].<sp/>Each<sp/>element<sp/>of<sp/>\p<sp/>I2C_config[]<sp/>is<sp/>populated<sp/>with</highlight></codeline>
<codeline lineno="72"><highlight class="comment"><sp/>*<sp/><sp/>pointers<sp/>to<sp/>a<sp/>device<sp/>specific<sp/>I2C<sp/>driver<sp/>implementation&apos;s<sp/>function</highlight></codeline>
<codeline lineno="73"><highlight class="comment"><sp/>*<sp/><sp/>table,<sp/>driver<sp/>object,<sp/>and<sp/>hardware<sp/>attributes.<sp/>The<sp/>hardware<sp/>attributes</highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/>*<sp/><sp/>define<sp/>properties<sp/>such<sp/>as<sp/>the<sp/>I2C<sp/>peripheral&apos;s<sp/>base<sp/>address<sp/>and</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/>*<sp/><sp/>pins.<sp/>Each<sp/>element<sp/>in<sp/>\p<sp/>I2C_config[]<sp/>corresponds<sp/>to<sp/>an<sp/>I2C<sp/>instance,</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/>*<sp/><sp/>and<sp/>none<sp/>of<sp/>the<sp/>elements<sp/>should<sp/>have<sp/>\p<sp/>NULL<sp/>pointers.</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>I2C<sp/>configuration<sp/>is<sp/>device<sp/>dependent.<sp/>You<sp/>will<sp/>need<sp/>to<sp/>check<sp/>the</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/>*<sp/><sp/>device<sp/>specific<sp/>I2C<sp/>driver<sp/>documentation.<sp/>There<sp/>you<sp/>will<sp/>find<sp/>a</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/>*<sp/><sp/>description<sp/>of<sp/>the<sp/>I2C<sp/>hardware<sp/>attributes.</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>Usage<sp/>#</highlight></codeline>
<codeline lineno="83"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/>*<sp/><sp/>For<sp/>general<sp/>usage,<sp/>refer<sp/>to<sp/>the<sp/>function<sp/>documentation.</highlight></codeline>
<codeline lineno="85"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="86"><highlight class="comment"><sp/>*<sp/><sp/>##<sp/>Initializing<sp/>the<sp/>I2C<sp/>Driver<sp/>##</highlight></codeline>
<codeline lineno="87"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="88"><highlight class="comment"><sp/>*<sp/><sp/>I2C_init()<sp/>must<sp/>be<sp/>called<sp/>before<sp/>any<sp/>other<sp/>I2C<sp/>API.<sp/>This<sp/>function</highlight></codeline>
<codeline lineno="89"><highlight class="comment"><sp/>*<sp/><sp/>calls<sp/>the<sp/>device<sp/>specific<sp/>implementation&apos;s<sp/>I2C<sp/>initialization<sp/>function</highlight></codeline>
<codeline lineno="90"><highlight class="comment"><sp/>*<sp/><sp/>for<sp/>each<sp/>element<sp/>of<sp/>\p<sp/>I2C_config[].</highlight></codeline>
<codeline lineno="91"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="92"><highlight class="comment"><sp/>*<sp/><sp/>##<sp/>Opening<sp/>the<sp/>I2C<sp/>Driver<sp/>##</highlight></codeline>
<codeline lineno="93"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="94"><highlight class="comment"><sp/>*<sp/><sp/>After<sp/>calling<sp/>I2C_init(),<sp/>the<sp/>application<sp/>can<sp/>open<sp/>an<sp/>I2C<sp/>instance<sp/>by</highlight></codeline>
<codeline lineno="95"><highlight class="comment"><sp/>*<sp/><sp/>calling<sp/>I2C_open().<sp/>This<sp/>function<sp/>takes<sp/>an<sp/>index<sp/>into<sp/>the<sp/>\p<sp/>I2C_config[]</highlight></codeline>
<codeline lineno="96"><highlight class="comment"><sp/>*<sp/><sp/>array<sp/>and<sp/>an<sp/>#I2C_Params<sp/>structure.<sp/>The<sp/>#I2C_Handle<sp/>returned<sp/>from<sp/>the</highlight></codeline>
<codeline lineno="97"><highlight class="comment"><sp/>*<sp/><sp/>I2C_open()<sp/>is<sp/>then<sp/>associated<sp/>with<sp/>that<sp/>index<sp/>into<sp/>the<sp/>\p<sp/>I2C_config[]</highlight></codeline>
<codeline lineno="98"><highlight class="comment"><sp/>*<sp/><sp/>array.<sp/>The<sp/>following<sp/>code<sp/>example<sp/>opens<sp/>an<sp/>I2C<sp/>instance<sp/>with<sp/>default</highlight></codeline>
<codeline lineno="99"><highlight class="comment"><sp/>*<sp/><sp/>parameters<sp/>by<sp/>passing<sp/>\p<sp/>NULL<sp/>for<sp/>the<sp/>#I2C_Params<sp/>argument.</highlight></codeline>
<codeline lineno="100"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="101"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="102"><highlight class="comment"><sp/>*<sp/><sp/>I2C_Handle<sp/>i2cHandle;</highlight></codeline>
<codeline lineno="103"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="104"><highlight class="comment"><sp/>*<sp/><sp/>i2cHandle<sp/>=<sp/>I2C_open(Board_I2C0,<sp/>NULL);</highlight></codeline>
<codeline lineno="105"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="106"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(i2cHandle<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="107"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Error<sp/>opening<sp/>I2C</highlight></codeline>
<codeline lineno="108"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(1)<sp/>{}</highlight></codeline>
<codeline lineno="109"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="110"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="111"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="112"><highlight class="comment"><sp/>*<sp/><sp/>\note<sp/>Each<sp/>I2C<sp/>index<sp/>can<sp/>only<sp/>be<sp/>opened<sp/>exclusively.<sp/>Calling<sp/>I2C_open()</highlight></codeline>
<codeline lineno="113"><highlight class="comment"><sp/>*<sp/><sp/>multiple<sp/>times<sp/>with<sp/>the<sp/>same<sp/>index<sp/>will<sp/>result<sp/>in<sp/>an<sp/>error.<sp/>The<sp/>index<sp/>can</highlight></codeline>
<codeline lineno="114"><highlight class="comment"><sp/>*<sp/><sp/>be<sp/>re-used<sp/>if<sp/>I2C_close()<sp/>is<sp/>called<sp/>first.</highlight></codeline>
<codeline lineno="115"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="116"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>example<sp/>shows<sp/>opening<sp/>an<sp/>I2C<sp/>driver<sp/>instance<sp/>in<sp/>#I2C_MODE_CALLBACK</highlight></codeline>
<codeline lineno="117"><highlight class="comment"><sp/>*<sp/><sp/>with<sp/>a<sp/>bit<sp/>rate<sp/>of<sp/>#I2C_400kHz.</highlight></codeline>
<codeline lineno="118"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="119"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="120"><highlight class="comment"><sp/>*<sp/><sp/>void<sp/>myCallbackFxn(I2C_Handle<sp/>handle,<sp/>I2C_Transaction<sp/>*msg,<sp/>bool<sp/>status)</highlight></codeline>
<codeline lineno="121"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="122"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline lineno="123"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//transfer<sp/>failed</highlight></codeline>
<codeline lineno="124"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="125"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="126"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="127"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="128"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="129"><highlight class="comment"><sp/>*<sp/><sp/>I2C_Handle<sp/>i2cHandle;</highlight></codeline>
<codeline lineno="130"><highlight class="comment"><sp/>*<sp/><sp/>I2C_Params<sp/>i2cParams;</highlight></codeline>
<codeline lineno="131"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="132"><highlight class="comment"><sp/>*<sp/><sp/>I2C_Params_init(&amp;i2cParams);</highlight></codeline>
<codeline lineno="133"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="134"><highlight class="comment"><sp/>*<sp/><sp/>i2cParams.transferMode<sp/>=<sp/>I2C_MODE_CALLBACK;</highlight></codeline>
<codeline lineno="135"><highlight class="comment"><sp/>*<sp/><sp/>i2cParams.transferCallbackFxn<sp/>=<sp/>myCallbackFxn;</highlight></codeline>
<codeline lineno="136"><highlight class="comment"><sp/>*<sp/><sp/>i2cParams.bitRate<sp/>=<sp/>I2C_400kHz;</highlight></codeline>
<codeline lineno="137"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/>*<sp/><sp/>i2cHandle<sp/>=<sp/>I2C_open(Board_I2C0,<sp/>&amp;i2cParams);</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="140"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(i2cHandle<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="141"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Error<sp/>opening<sp/>I2C</highlight></codeline>
<codeline lineno="142"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(1);</highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="145"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="146"><highlight class="comment"><sp/>*<sp/><sp/>##<sp/>Transferring<sp/>data<sp/>##</highlight></codeline>
<codeline lineno="147"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="148"><highlight class="comment"><sp/>*<sp/><sp/>An<sp/>I2C<sp/>data<sp/>transfer<sp/>is<sp/>performed<sp/>using<sp/>the<sp/>I2C_transfer()<sp/>function.<sp/>Three</highlight></codeline>
<codeline lineno="149"><highlight class="comment"><sp/>*<sp/><sp/>types<sp/>of<sp/>transactions<sp/>are<sp/>supported:<sp/>write,<sp/>read,<sp/>and<sp/>write<sp/>+<sp/>read.<sp/>The</highlight></codeline>
<codeline lineno="150"><highlight class="comment"><sp/>*<sp/><sp/>details<sp/>of<sp/>each<sp/>transaction<sp/>are<sp/>specified<sp/>with<sp/>an<sp/>#I2C_Transaction</highlight></codeline>
<codeline lineno="151"><highlight class="comment"><sp/>*<sp/><sp/>structure.<sp/>Each<sp/>transfer<sp/>is<sp/>completed<sp/>before<sp/>another<sp/>transfer<sp/>is<sp/>initiated.</highlight></codeline>
<codeline lineno="152"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="153"><highlight class="comment"><sp/>*<sp/><sp/>For<sp/>write<sp/>+<sp/>read<sp/>transactions,<sp/>the<sp/>specified<sp/>data<sp/>is<sp/>first<sp/>written<sp/>to<sp/>the</highlight></codeline>
<codeline lineno="154"><highlight class="comment"><sp/>*<sp/><sp/>peripheral,<sp/>then<sp/>a<sp/>repeated<sp/>start<sp/>is<sp/>sent<sp/>by<sp/>the<sp/>driver,<sp/>which<sp/>initiates</highlight></codeline>
<codeline lineno="155"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>read<sp/>operation.<sp/>This<sp/>type<sp/>of<sp/>transfer<sp/>is<sp/>useful<sp/>if<sp/>an<sp/>I2C<sp/>peripheral</highlight></codeline>
<codeline lineno="156"><highlight class="comment"><sp/>*<sp/><sp/>has<sp/>a<sp/>pointer<sp/>register<sp/>that<sp/>needs<sp/>to<sp/>be<sp/>adjusted<sp/>prior<sp/>to<sp/>reading<sp/>from</highlight></codeline>
<codeline lineno="157"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>referenced<sp/>data<sp/>register.</highlight></codeline>
<codeline lineno="158"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="159"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>following<sp/>examples<sp/>assume<sp/>an<sp/>I2C<sp/>instance<sp/>has<sp/>been<sp/>opened<sp/>in</highlight></codeline>
<codeline lineno="160"><highlight class="comment"><sp/>*<sp/><sp/>#I2C_MODE_BLOCKING<sp/>mode.</highlight></codeline>
<codeline lineno="161"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="162"><highlight class="comment"><sp/>*<sp/>---------------------------------------------------------------------------</highlight></codeline>
<codeline lineno="163"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="164"><highlight class="comment"><sp/>*<sp/><sp/>Sending<sp/>three<sp/>bytes<sp/>of<sp/>data.</highlight></codeline>
<codeline lineno="165"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="166"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="167"><highlight class="comment"><sp/>*<sp/><sp/>I2C_Transaction<sp/>i2cTransaction;</highlight></codeline>
<codeline lineno="168"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>writeBuffer[3];</highlight></codeline>
<codeline lineno="169"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="170"><highlight class="comment"><sp/>*<sp/><sp/>writeBuffer[0]<sp/>=<sp/>0xAB;</highlight></codeline>
<codeline lineno="171"><highlight class="comment"><sp/>*<sp/><sp/>writeBuffer[1]<sp/>=<sp/>0xCD;</highlight></codeline>
<codeline lineno="172"><highlight class="comment"><sp/>*<sp/><sp/>writeBuffer[2]<sp/>=<sp/>0xEF;</highlight></codeline>
<codeline lineno="173"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="174"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.slaveAddress<sp/>=<sp/>0x50;</highlight></codeline>
<codeline lineno="175"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.writeBuf<sp/>=<sp/>writeBuffer;</highlight></codeline>
<codeline lineno="176"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.writeCount<sp/>=<sp/>3;</highlight></codeline>
<codeline lineno="177"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.readBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="178"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.readCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="179"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="180"><highlight class="comment"><sp/>*<sp/><sp/>status<sp/>=<sp/>I2C_transfer(i2cHandle,<sp/>&amp;i2cTransaction);</highlight></codeline>
<codeline lineno="181"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="182"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline lineno="183"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Unsuccessful<sp/>I2C<sp/>transfer</highlight></codeline>
<codeline lineno="184"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="185"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="186"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="187"><highlight class="comment"><sp/>*<sp/><sp/>Reading<sp/>five<sp/>bytes<sp/>of<sp/>data.</highlight></codeline>
<codeline lineno="188"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="189"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="190"><highlight class="comment"><sp/>*<sp/><sp/>I2C_Transaction<sp/>i2cTransaction;</highlight></codeline>
<codeline lineno="191"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>readBuffer[5];</highlight></codeline>
<codeline lineno="192"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="193"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.slaveAddress<sp/>=<sp/>0x50;</highlight></codeline>
<codeline lineno="194"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.writeBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="195"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.writeCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="196"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.readBuf<sp/>=<sp/>readBuffer;</highlight></codeline>
<codeline lineno="197"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.readCount<sp/>=<sp/>5;</highlight></codeline>
<codeline lineno="198"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="199"><highlight class="comment"><sp/>*<sp/><sp/>status<sp/>=<sp/>I2C_transfer(i2cHandle,<sp/>&amp;i2cTransaction);</highlight></codeline>
<codeline lineno="200"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="201"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline lineno="202"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Unsuccessful<sp/>I2C<sp/>transfer</highlight></codeline>
<codeline lineno="203"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="204"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="205"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="206"><highlight class="comment"><sp/>*<sp/><sp/>Writing<sp/>two<sp/>bytes<sp/>and<sp/>reading<sp/>four<sp/>bytes<sp/>in<sp/>a<sp/>single<sp/>transaction.</highlight></codeline>
<codeline lineno="207"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="208"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="209"><highlight class="comment"><sp/>*<sp/><sp/>I2C_Transaction<sp/>i2cTransaction;</highlight></codeline>
<codeline lineno="210"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>readBuffer[4];</highlight></codeline>
<codeline lineno="211"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>writeBuffer[2];</highlight></codeline>
<codeline lineno="212"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="213"><highlight class="comment"><sp/>*<sp/><sp/>writeBuffer[0]<sp/>=<sp/>0xAB;</highlight></codeline>
<codeline lineno="214"><highlight class="comment"><sp/>*<sp/><sp/>writeBuffer[1]<sp/>=<sp/>0xCD;</highlight></codeline>
<codeline lineno="215"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="216"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.slaveAddress<sp/>=<sp/>0x50;</highlight></codeline>
<codeline lineno="217"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.writeBuf<sp/>=<sp/>writeBuffer;</highlight></codeline>
<codeline lineno="218"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.writeCount<sp/>=<sp/>2;</highlight></codeline>
<codeline lineno="219"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.readBuf<sp/>=<sp/>readBuffer;</highlight></codeline>
<codeline lineno="220"><highlight class="comment"><sp/>*<sp/><sp/>i2cTransaction.readCount<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="221"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="222"><highlight class="comment"><sp/>*<sp/><sp/>status<sp/>=<sp/>I2C_transfer(i2cHandle,<sp/>&amp;i2cTransaction);</highlight></codeline>
<codeline lineno="223"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="224"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline lineno="225"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Unsuccessful<sp/>I2C<sp/>transfer</highlight></codeline>
<codeline lineno="226"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="227"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="228"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="229"><highlight class="comment"><sp/>*<sp/>---------------------------------------------------------------------------</highlight></codeline>
<codeline lineno="230"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="231"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>final<sp/>example<sp/>shows<sp/>usage<sp/>of<sp/>#I2C_MODE_CALLBACK,<sp/>with<sp/>queuing</highlight></codeline>
<codeline lineno="232"><highlight class="comment"><sp/>*<sp/><sp/>of<sp/>multiple<sp/>transactions.<sp/>Because<sp/>multiple<sp/>transactions<sp/>are<sp/>simultaneously</highlight></codeline>
<codeline lineno="233"><highlight class="comment"><sp/>*<sp/><sp/>queued,<sp/>separate<sp/>#I2C_Transaction<sp/>structures<sp/>must<sp/>be<sp/>used.<sp/>Each</highlight></codeline>
<codeline lineno="234"><highlight class="comment"><sp/>*<sp/><sp/>#I2C_Transaction<sp/>will<sp/>contain<sp/>a<sp/>custom<sp/>application<sp/>argument<sp/>of<sp/>a</highlight></codeline>
<codeline lineno="235"><highlight class="comment"><sp/>*<sp/><sp/>semaphore<sp/>handle.<sp/>The<sp/>#I2C_Transaction.arg<sp/>will<sp/>point<sp/>to<sp/>the<sp/>semaphore</highlight></codeline>
<codeline lineno="236"><highlight class="comment"><sp/>*<sp/><sp/>handle.<sp/>When<sp/>the<sp/>callback<sp/>function<sp/>is<sp/>called,<sp/>the<sp/>#I2C_Transaction.arg<sp/>is</highlight></codeline>
<codeline lineno="237"><highlight class="comment"><sp/>*<sp/><sp/>checked<sp/>for<sp/>\p<sp/>NULL.<sp/>If<sp/>this<sp/>value<sp/>is<sp/>not<sp/>\p<sp/>NULL,<sp/>then<sp/>it<sp/>can<sp/>be<sp/>assumed</highlight></codeline>
<codeline lineno="238"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>\p<sp/>arg<sp/>is<sp/>pointing<sp/>to<sp/>a<sp/>valid<sp/>semaphore<sp/>handle.<sp/>The<sp/>semaphore<sp/>handle</highlight></codeline>
<codeline lineno="239"><highlight class="comment"><sp/>*<sp/><sp/>is<sp/>then<sp/>used<sp/>to<sp/>call<sp/>\p<sp/>sem_post().<sp/>Hypothetically,<sp/>this<sp/>can<sp/>be<sp/>used<sp/>to</highlight></codeline>
<codeline lineno="240"><highlight class="comment"><sp/>*<sp/><sp/>signal<sp/>transaction<sp/>completion<sp/>to<sp/>the<sp/>task(s)<sp/>that<sp/>queued<sp/>the</highlight></codeline>
<codeline lineno="241"><highlight class="comment"><sp/>*<sp/><sp/>transaction(s).</highlight></codeline>
<codeline lineno="242"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="243"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="244"><highlight class="comment"><sp/>*<sp/><sp/>void<sp/>callbackFxn(I2C_Handle<sp/>handle,<sp/>I2C_Transaction<sp/>*msg,<sp/>bool<sp/>status)</highlight></codeline>
<codeline lineno="245"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="246"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="247"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(status<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline lineno="248"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//transaction<sp/>failed</highlight></codeline>
<codeline lineno="249"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="250"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="251"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Check<sp/>for<sp/>a<sp/>semaphore<sp/>handle</highlight></codeline>
<codeline lineno="252"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(msg-&gt;arg<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="253"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="254"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Perform<sp/>a<sp/>semaphore<sp/>post</highlight></codeline>
<codeline lineno="255"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sem_post((sem_t<sp/>*)<sp/>(msg-&gt;arg));</highlight></codeline>
<codeline lineno="256"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="257"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="258"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="259"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="260"><highlight class="comment"><sp/>*<sp/><sp/>Snippets<sp/>of<sp/>the<sp/>thread<sp/>code<sp/>that<sp/>initiates<sp/>the<sp/>transactions<sp/>are<sp/>shown<sp/>below.</highlight></codeline>
<codeline lineno="261"><highlight class="comment"><sp/>*<sp/><sp/>Note<sp/>the<sp/>use<sp/>of<sp/>multiple<sp/>#I2C_Transaction<sp/>structures.<sp/>The<sp/>handle<sp/>of<sp/>the</highlight></codeline>
<codeline lineno="262"><highlight class="comment"><sp/>*<sp/><sp/>semaphore<sp/>to<sp/>be<sp/>posted<sp/>is<sp/>specified<sp/>via<sp/>\p<sp/>i2cTransaction2.arg.</highlight></codeline>
<codeline lineno="263"><highlight class="comment"><sp/>*<sp/><sp/>I2C_transfer()<sp/>is<sp/>called<sp/>three<sp/>times<sp/>to<sp/>initiate<sp/>each<sp/>transaction.</highlight></codeline>
<codeline lineno="264"><highlight class="comment"><sp/>*<sp/><sp/>Since<sp/>callback<sp/>mode<sp/>is<sp/>used,<sp/>these<sp/>functions<sp/>return<sp/>immediately.<sp/>After</highlight></codeline>
<codeline lineno="265"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>transactions<sp/>have<sp/>been<sp/>queued,<sp/>other<sp/>work<sp/>can<sp/>be<sp/>done.<sp/>Eventually,</highlight></codeline>
<codeline lineno="266"><highlight class="comment"><sp/>*<sp/><sp/>\p<sp/>sem_wait()<sp/>is<sp/>called<sp/>causing<sp/>the<sp/>thread<sp/>to<sp/>block<sp/>until<sp/>the<sp/>transaction</highlight></codeline>
<codeline lineno="267"><highlight class="comment"><sp/>*<sp/><sp/>completes.<sp/>When<sp/>the<sp/>transaction<sp/>completes,<sp/>the<sp/>application&apos;s<sp/>callback</highlight></codeline>
<codeline lineno="268"><highlight class="comment"><sp/>*<sp/><sp/>function,<sp/>\p<sp/>callbackFxn<sp/>will<sp/>be<sp/>called.<sp/>Once<sp/>\p<sp/>callbackFxn<sp/>posts<sp/>the</highlight></codeline>
<codeline lineno="269"><highlight class="comment"><sp/>*<sp/><sp/>semaphore,<sp/>the<sp/>thread<sp/>will<sp/>be<sp/>unblocked<sp/>and<sp/>can<sp/>resume<sp/>execution.</highlight></codeline>
<codeline lineno="270"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="271"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="272"><highlight class="comment"><sp/>*<sp/><sp/>void<sp/>thread(arg0,<sp/>arg1)</highlight></codeline>
<codeline lineno="273"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="274"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="275"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>I2C_Transaction<sp/>i2cTransaction0;</highlight></codeline>
<codeline lineno="276"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>I2C_Transaction<sp/>i2cTransaction1;</highlight></codeline>
<codeline lineno="277"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>I2C_Transaction<sp/>i2cTransaction2;</highlight></codeline>
<codeline lineno="278"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="279"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline lineno="280"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="281"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>i2cTransaction0.arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="282"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>i2cTransaction1.arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="283"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>i2cTransaction2.arg<sp/>=<sp/>semaphoreHandle;</highlight></codeline>
<codeline lineno="284"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="285"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline lineno="286"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="287"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>I2C_transfer(i2c,<sp/>&amp;i2cTransaction0);</highlight></codeline>
<codeline lineno="288"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>I2C_transfer(i2c,<sp/>&amp;i2cTransaction1);</highlight></codeline>
<codeline lineno="289"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>I2C_transfer(i2c,<sp/>&amp;i2cTransaction2);</highlight></codeline>
<codeline lineno="290"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="291"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline lineno="292"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="293"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>sem_wait(semaphoreHandle);</highlight></codeline>
<codeline lineno="294"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="295"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="296"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="297"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>Implementation<sp/>#</highlight></codeline>
<codeline lineno="298"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="299"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>top-level<sp/>I2C<sp/>module<sp/>serves<sp/>as<sp/>the<sp/>main<sp/>interface<sp/>for<sp/>RTOS</highlight></codeline>
<codeline lineno="300"><highlight class="comment"><sp/>*<sp/><sp/>applications.<sp/>Its<sp/>purpose<sp/>is<sp/>to<sp/>redirect<sp/>the<sp/>module&apos;s<sp/>APIs<sp/>to<sp/>specific</highlight></codeline>
<codeline lineno="301"><highlight class="comment"><sp/>*<sp/><sp/>peripheral<sp/>implementations<sp/>which<sp/>are<sp/>specified<sp/>using<sp/>a<sp/>pointer<sp/>to<sp/>an</highlight></codeline>
<codeline lineno="302"><highlight class="comment"><sp/>*<sp/><sp/>#I2C_FxnTable.</highlight></codeline>
<codeline lineno="303"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="304"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>I2C<sp/>driver<sp/>interface<sp/>module<sp/>is<sp/>joined<sp/>(at<sp/>link<sp/>time)<sp/>to<sp/>an</highlight></codeline>
<codeline lineno="305"><highlight class="comment"><sp/>*<sp/><sp/>array<sp/>of<sp/>#I2C_Config<sp/>data<sp/>structures<sp/>named<sp/>\p<sp/>I2C_config.</highlight></codeline>
<codeline lineno="306"><highlight class="comment"><sp/>*<sp/><sp/>\p<sp/>I2C_config<sp/>is<sp/>typically<sp/>defined<sp/>in<sp/>the<sp/>Board.c<sp/>file<sp/>used<sp/>for<sp/>the</highlight></codeline>
<codeline lineno="307"><highlight class="comment"><sp/>*<sp/><sp/>application.<sp/>If<sp/>there<sp/>are<sp/>multiple<sp/>instances<sp/>of<sp/>I2C<sp/>peripherals<sp/>on<sp/>the</highlight></codeline>
<codeline lineno="308"><highlight class="comment"><sp/>*<sp/><sp/>device,<sp/>there<sp/>will<sp/>typically<sp/>be<sp/>multiple<sp/>#I2C_Config<sp/>structures<sp/>defined<sp/>in</highlight></codeline>
<codeline lineno="309"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>board<sp/>file<sp/>in<sp/>the<sp/>form<sp/>of<sp/>an<sp/>array.<sp/>Each<sp/>entry<sp/>in<sp/>\p<sp/>I2C_config</highlight></codeline>
<codeline lineno="310"><highlight class="comment"><sp/>*<sp/><sp/>contains<sp/>a:</highlight></codeline>
<codeline lineno="311"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>#I2C_FxnTable<sp/>pointer<sp/>to<sp/>a<sp/>set<sp/>of<sp/>functions<sp/>that<sp/>implement<sp/>an<sp/>I2C</highlight></codeline>
<codeline lineno="312"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>peripheral.</highlight></codeline>
<codeline lineno="313"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>(\p<sp/>void<sp/>*)<sp/>data<sp/>object<sp/>that<sp/>is<sp/>associated<sp/>with<sp/>the<sp/>#I2C_FxnTable</highlight></codeline>
<codeline lineno="314"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>(\p<sp/>void<sp/>*)<sp/>hardware<sp/>attributes<sp/>that<sp/>are<sp/>associated<sp/>to<sp/>the<sp/>#I2C_FxnTable</highlight></codeline>
<codeline lineno="315"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="316"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="317"><highlight class="comment"><sp/>******************************************************************************</highlight></codeline>
<codeline lineno="318"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>ti_drivers_I2C__include</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="321"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ti_drivers_I2C__include</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="322"><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="324"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="325"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="326"><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdbool.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="328"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stddef.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdint.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal"></highlight></codeline>
<codeline lineno="348" refid="group___i2_c___c_o_n_t_r_o_l_1ga760ec0a6fdb876ccc67b6f06301d53ec" refkind="member"><highlight class="preprocessor">#define<sp/>I2C_CMD_RESERVED<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight></codeline>
<codeline lineno="362" refid="group___i2_c___c_o_n_t_r_o_l_1gacfd04572fe349d087c2547501cbc7e0a" refkind="member"><highlight class="preprocessor">#define<sp/>I2C_STATUS_RESERVED<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(-32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="363"><highlight class="normal"></highlight></codeline>
<codeline lineno="377" refid="group___i2_c___s_t_a_t_u_s_1gaa0bcf3acd26ac82bd8ff91daba2c78c4" refkind="member"><highlight class="preprocessor">#define<sp/>I2C_STATUS_SUCCESS<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="378"><highlight class="normal"></highlight></codeline>
<codeline lineno="385" refid="group___i2_c___s_t_a_t_u_s_1ga7323fe57c39c46d0da9910e17f5f0b06" refkind="member"><highlight class="preprocessor">#define<sp/>I2C_STATUS_ERROR<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(-1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="386"><highlight class="normal"></highlight></codeline>
<codeline lineno="394" refid="group___i2_c___s_t_a_t_u_s_1ga11c31c9869ed2441789205d9e5967d66" refkind="member"><highlight class="preprocessor">#define<sp/>I2C_STATUS_UNDEFINEDCMD<sp/><sp/><sp/><sp/>(-2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="comment">/*<sp/>Add<sp/>I2C_CMD_&lt;commands&gt;<sp/>here<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="406"><highlight class="normal"></highlight></codeline>
<codeline lineno="414" refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_i2_c___config__" kindref="compound">I2C_Config_</ref><sp/>*<ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref>;</highlight></codeline>
<codeline lineno="415"><highlight class="normal"></highlight></codeline>
<codeline lineno="431" refid="struct_i2_c___transaction__" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_i2_c___transaction__" kindref="compound">I2C_Transaction_</ref><sp/>{</highlight></codeline>
<codeline lineno="434" refid="struct_i2_c___transaction___1a5d9c494aca871ebb272899856e1fa6bb" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<ref refid="struct_i2_c___transaction___1a5d9c494aca871ebb272899856e1fa6bb" kindref="member">writeBuf</ref>;</highlight></codeline>
<codeline lineno="437" refid="struct_i2_c___transaction___1a3bee82494f85dc33d1229e48a2ec63c8" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_i2_c___transaction___1a3bee82494f85dc33d1229e48a2ec63c8" kindref="member">writeCount</ref>;</highlight></codeline>
<codeline lineno="440" refid="struct_i2_c___transaction___1aca335a8f98036308396f27fddeb96f7b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<ref refid="struct_i2_c___transaction___1aca335a8f98036308396f27fddeb96f7b" kindref="member">readBuf</ref>;</highlight></codeline>
<codeline lineno="443" refid="struct_i2_c___transaction___1a175470cacf5d42b11d505e2196ff6494" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_i2_c___transaction___1a175470cacf5d42b11d505e2196ff6494" kindref="member">readCount</ref>;</highlight></codeline>
<codeline lineno="445" refid="struct_i2_c___transaction___1a09a6dc5d7ab40ed03cb0442feb456889" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint_least8_t<sp/><ref refid="struct_i2_c___transaction___1a09a6dc5d7ab40ed03cb0442feb456889" kindref="member">slaveAddress</ref>;</highlight></codeline>
<codeline lineno="449" refid="struct_i2_c___transaction___1a5c74a2359742d69b0e9108bb342ded00" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<ref refid="struct_i2_c___transaction___1a5c74a2359742d69b0e9108bb342ded00" kindref="member">arg</ref>;</highlight></codeline>
<codeline lineno="452" refid="struct_i2_c___transaction___1a568092ead614401487c18c850e93540c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<ref refid="struct_i2_c___transaction___1a568092ead614401487c18c850e93540c" kindref="member">nextPtr</ref>;</highlight></codeline>
<codeline lineno="453"><highlight class="normal">}<sp/><ref refid="_i2_c_8h_1adb9098b8bae10ab04381350227058a51" kindref="member">I2C_Transaction</ref>;</highlight></codeline>
<codeline lineno="454"><highlight class="normal"></highlight></codeline>
<codeline lineno="460" refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfe" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfe" kindref="member">I2C_TransferMode_</ref><sp/>{</highlight></codeline>
<codeline lineno="467" refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75" kindref="member">I2C_MODE_BLOCKING</ref>,</highlight></codeline>
<codeline lineno="480" refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72" kindref="member">I2C_MODE_CALLBACK</ref></highlight></codeline>
<codeline lineno="481"><highlight class="normal">}<sp/><ref refid="_i2_c_8h_1aafde66e55b9cc9b1b0b7a2b924db4e83" kindref="member">I2C_TransferMode</ref>;</highlight></codeline>
<codeline lineno="482"><highlight class="normal"></highlight></codeline>
<codeline lineno="502" refid="_i2_c_8h_1adaa5c99b7c23a00bac52d15a2469764e" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_i2_c_8h_1adaa5c99b7c23a00bac52d15a2469764e" kindref="member">I2C_CallbackFxn</ref>)(I2C_Handle<sp/>handle,<sp/><ref refid="struct_i2_c___transaction__" kindref="compound">I2C_Transaction</ref><sp/>*transaction,</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>transferStatus);</highlight></codeline>
<codeline lineno="504"><highlight class="normal"></highlight></codeline>
<codeline lineno="512" refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9" kindref="member">I2C_BitRate_</ref><sp/>{</highlight></codeline>
<codeline lineno="513"><highlight class="normal"></highlight></codeline>
<codeline lineno="514" refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a966fd2df13b3a9825615c50335cf1987" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a966fd2df13b3a9825615c50335cf1987" kindref="member">I2C_100kHz</ref><sp/><sp/><sp/><sp/><sp/>=<sp/>0,<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="515" refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a83cc3750242e6ae9194cd7ed94f764d9" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a83cc3750242e6ae9194cd7ed94f764d9" kindref="member">I2C_400kHz</ref><sp/><sp/><sp/><sp/><sp/>=<sp/>1,<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="516" refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a38a2e32ba65eb0f67b928d181242befa" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a38a2e32ba65eb0f67b928d181242befa" kindref="member">I2C_1000kHz</ref><sp/><sp/><sp/><sp/>=<sp/>2,<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="517" refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a37abd9be14a25ed731f14694922ee7d4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a37abd9be14a25ed731f14694922ee7d4" kindref="member">I2C_3330kHz</ref><sp/><sp/><sp/><sp/>=<sp/>3,<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="518" refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a0c1376dab54ab817b76de1513b5707fb" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1adf9ba181c193aea867303fb6e6471db9a0c1376dab54ab817b76de1513b5707fb" kindref="member">I2C_3400kHz</ref><sp/><sp/><sp/><sp/>=<sp/>3,<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="519"><highlight class="normal">}<sp/><ref refid="_i2_c_8h_1a47b244d734eccc02dee744a50ac3aba1" kindref="member">I2C_BitRate</ref>;</highlight></codeline>
<codeline lineno="520"><highlight class="normal"></highlight></codeline>
<codeline lineno="534" refid="struct_i2_c___params__" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_i2_c___params__" kindref="compound">I2C_Params_</ref><sp/>{</highlight></codeline>
<codeline lineno="536" refid="struct_i2_c___params___1a1c126475468cfc6ce397a520aea93936" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>I2C_TransferMode<sp/><ref refid="struct_i2_c___params___1a1c126475468cfc6ce397a520aea93936" kindref="member">transferMode</ref>;</highlight></codeline>
<codeline lineno="539" refid="struct_i2_c___params___1acd2b2ca0da16c1f017ac32cc4831b31e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1adaa5c99b7c23a00bac52d15a2469764e" kindref="member">I2C_CallbackFxn</ref><sp/><ref refid="struct_i2_c___params___1acd2b2ca0da16c1f017ac32cc4831b31e" kindref="member">transferCallbackFxn</ref>;</highlight></codeline>
<codeline lineno="541" refid="struct_i2_c___params___1a03607c385a4e9dd1f29338ec0309a858" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1a47b244d734eccc02dee744a50ac3aba1" kindref="member">I2C_BitRate</ref><sp/><ref refid="struct_i2_c___params___1a03607c385a4e9dd1f29338ec0309a858" kindref="member">bitRate</ref>;</highlight></codeline>
<codeline lineno="543" refid="struct_i2_c___params___1ac44da2d70d79ffa122d791b37864d457" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<ref refid="struct_i2_c___params___1ac44da2d70d79ffa122d791b37864d457" kindref="member">custom</ref>;</highlight></codeline>
<codeline lineno="544"><highlight class="normal">}<sp/><ref refid="_i2_c_8h_1a98d59fc71988958e7025a17307ada749" kindref="member">I2C_Params</ref>;</highlight></codeline>
<codeline lineno="545"><highlight class="normal"></highlight></codeline>
<codeline lineno="550" refid="_i2_c_8h_1a7a829a2a0fd594c50e93c3e55c7d04aa" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_i2_c_8h_1a7a829a2a0fd594c50e93c3e55c7d04aa" kindref="member">I2C_CancelFxn</ref>)<sp/>(I2C_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="551"><highlight class="normal"></highlight></codeline>
<codeline lineno="556" refid="_i2_c_8h_1a083200108e980a0ef61e458f0b9fb9e7" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_i2_c_8h_1a083200108e980a0ef61e458f0b9fb9e7" kindref="member">I2C_CloseFxn</ref>)<sp/>(I2C_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="557"><highlight class="normal"></highlight></codeline>
<codeline lineno="562" refid="_i2_c_8h_1a2b3563e0ae9a6ce2be82bdc938ae5218" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>int_fast16_t<sp/>(*<ref refid="_i2_c_8h_1a2b3563e0ae9a6ce2be82bdc938ae5218" kindref="member">I2C_ControlFxn</ref>)<sp/>(I2C_Handle<sp/>handle,<sp/>uint_fast16_t<sp/>cmd,</highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*controlArg);</highlight></codeline>
<codeline lineno="564"><highlight class="normal"></highlight></codeline>
<codeline lineno="569" refid="_i2_c_8h_1adfb2451c8a1ce70402e43e4743c5fedf" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*<ref refid="_i2_c_8h_1adfb2451c8a1ce70402e43e4743c5fedf" kindref="member">I2C_InitFxn</ref>)<sp/>(I2C_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="570"><highlight class="normal"></highlight></codeline>
<codeline lineno="575" refid="_i2_c_8h_1add24fcdaaf1bdef1521ce2489bf1d80e" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="_i2_c_8h_1a1d8718f847129c7aa61dd1c264d8a13c" kindref="member">I2C_Handle</ref><sp/>(*<ref refid="_i2_c_8h_1add24fcdaaf1bdef1521ce2489bf1d80e" kindref="member">I2C_OpenFxn</ref>)<sp/>(I2C_Handle<sp/>handle,<sp/><ref refid="struct_i2_c___params__" kindref="compound">I2C_Params</ref><sp/>*params);</highlight></codeline>
<codeline lineno="576"><highlight class="normal"></highlight></codeline>
<codeline lineno="581" refid="_i2_c_8h_1aa785484e689c79262f98208689fecd38" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>bool<sp/>(*<ref refid="_i2_c_8h_1aa785484e689c79262f98208689fecd38" kindref="member">I2C_TransferFxn</ref>)<sp/>(I2C_Handle<sp/>handle,</highlight></codeline>
<codeline lineno="582"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_i2_c___transaction__" kindref="compound">I2C_Transaction</ref><sp/>*transaction);</highlight></codeline>
<codeline lineno="583"><highlight class="normal"></highlight></codeline>
<codeline lineno="589" refid="struct_i2_c___fxn_table__" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_i2_c___fxn_table__" kindref="compound">I2C_FxnTable_</ref><sp/>{</highlight></codeline>
<codeline lineno="590" refid="struct_i2_c___fxn_table___1a8cadbe830929fa9a54461448e471d359" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1a7a829a2a0fd594c50e93c3e55c7d04aa" kindref="member">I2C_CancelFxn</ref><sp/><sp/><sp/><ref refid="struct_i2_c___fxn_table___1a8cadbe830929fa9a54461448e471d359" kindref="member">cancelFxn</ref>;</highlight></codeline>
<codeline lineno="591" refid="struct_i2_c___fxn_table___1af53a791f92401f932164b46c4f36c64b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1a083200108e980a0ef61e458f0b9fb9e7" kindref="member">I2C_CloseFxn</ref><sp/><sp/><sp/><sp/><ref refid="struct_i2_c___fxn_table___1af53a791f92401f932164b46c4f36c64b" kindref="member">closeFxn</ref>;</highlight></codeline>
<codeline lineno="592" refid="struct_i2_c___fxn_table___1a64329bef0f93df5f00ab40ebbff55781" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1a2b3563e0ae9a6ce2be82bdc938ae5218" kindref="member">I2C_ControlFxn</ref><sp/><sp/><ref refid="struct_i2_c___fxn_table___1a64329bef0f93df5f00ab40ebbff55781" kindref="member">controlFxn</ref>;</highlight></codeline>
<codeline lineno="593" refid="struct_i2_c___fxn_table___1a1cf1cb27dbc1b6df32f4539fa673ff47" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1adfb2451c8a1ce70402e43e4743c5fedf" kindref="member">I2C_InitFxn</ref><sp/><sp/><sp/><sp/><sp/><ref refid="struct_i2_c___fxn_table___1a1cf1cb27dbc1b6df32f4539fa673ff47" kindref="member">initFxn</ref>;</highlight></codeline>
<codeline lineno="594" refid="struct_i2_c___fxn_table___1a729b2903401dbfe7b39dd57e21a113bd" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1add24fcdaaf1bdef1521ce2489bf1d80e" kindref="member">I2C_OpenFxn</ref><sp/><sp/><sp/><sp/><sp/><ref refid="struct_i2_c___fxn_table___1a729b2903401dbfe7b39dd57e21a113bd" kindref="member">openFxn</ref>;</highlight></codeline>
<codeline lineno="595" refid="struct_i2_c___fxn_table___1acbc284ea2ca7877265e72167f716f3c4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_i2_c_8h_1aa785484e689c79262f98208689fecd38" kindref="member">I2C_TransferFxn</ref><sp/><ref refid="struct_i2_c___fxn_table___1acbc284ea2ca7877265e72167f716f3c4" kindref="member">transferFxn</ref>;</highlight></codeline>
<codeline lineno="596"><highlight class="normal">}<sp/><ref refid="_i2_c_8h_1a58fd875c3596b3856b6f1aebbceb3085" kindref="member">I2C_FxnTable</ref>;</highlight></codeline>
<codeline lineno="597"><highlight class="normal"></highlight></codeline>
<codeline lineno="609" refid="struct_i2_c___config__" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_i2_c___config__" kindref="compound">I2C_Config_</ref><sp/>{</highlight></codeline>
<codeline lineno="611" refid="struct_i2_c___config___1a635dcef77b14e153ffb35e270cd46886" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_i2_c___fxn_table__" kindref="compound">I2C_FxnTable</ref><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>*<ref refid="struct_i2_c___config___1a635dcef77b14e153ffb35e270cd46886" kindref="member">fxnTablePtr</ref>;</highlight></codeline>
<codeline lineno="612"><highlight class="normal"></highlight></codeline>
<codeline lineno="614" refid="struct_i2_c___config___1a8bdac95426bbb6b46559fab1e81898ba" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<ref refid="struct_i2_c___config___1a8bdac95426bbb6b46559fab1e81898ba" kindref="member">object</ref>;</highlight></codeline>
<codeline lineno="615"><highlight class="normal"></highlight></codeline>
<codeline lineno="617" refid="struct_i2_c___config___1af4722d351fb7137a34166e047a4f96bc" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>*<ref refid="struct_i2_c___config___1af4722d351fb7137a34166e047a4f96bc" kindref="member">hwAttrs</ref>;</highlight></codeline>
<codeline lineno="618"><highlight class="normal">}<sp/><ref refid="_i2_c_8h_1ae43e4c7b224a8cc37764acb792182453" kindref="member">I2C_Config</ref>;</highlight></codeline>
<codeline lineno="619"><highlight class="normal"></highlight></codeline>
<codeline lineno="640"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_i2_c_8h_1a8cad0c04a9eca0fffc0ffe5586a5179b" kindref="member">I2C_cancel</ref>(I2C_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="641"><highlight class="normal"></highlight></codeline>
<codeline lineno="651"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_i2_c_8h_1a12c86d89a687f2ee1eb980d99c32326d" kindref="member">I2C_close</ref>(I2C_Handle<sp/>handle);</highlight></codeline>
<codeline lineno="652"><highlight class="normal"></highlight></codeline>
<codeline lineno="690"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>int_fast16_t<sp/><ref refid="_i2_c_8h_1a4c74b1b9f8e76ac22bec7608491cb223" kindref="member">I2C_control</ref>(I2C_Handle<sp/>handle,<sp/>uint_fast16_t<sp/>cmd,</highlight></codeline>
<codeline lineno="691"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*controlArg);</highlight></codeline>
<codeline lineno="692"><highlight class="normal"></highlight></codeline>
<codeline lineno="701"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_i2_c_8h_1a9ff51ddf1d325776fef90cce0223772b" kindref="member">I2C_init</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="702"><highlight class="normal"></highlight></codeline>
<codeline lineno="720"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>I2C_Handle<sp/><ref refid="_i2_c_8h_1a2db3461e1e956d9b86af414da2fb05f6" kindref="member">I2C_open</ref>(uint_least8_t<sp/>index,<sp/><ref refid="struct_i2_c___params__" kindref="compound">I2C_Params</ref><sp/>*params);</highlight></codeline>
<codeline lineno="721"><highlight class="normal"></highlight></codeline>
<codeline lineno="734"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="_i2_c_8h_1ab11636302074d67180207ab81ceb323c" kindref="member">I2C_Params_init</ref>(<ref refid="struct_i2_c___params__" kindref="compound">I2C_Params</ref><sp/>*params);</highlight></codeline>
<codeline lineno="735"><highlight class="normal"></highlight></codeline>
<codeline lineno="781"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="_i2_c_8h_1ac5d827b67fe77d7d179026941cc069d7" kindref="member">I2C_transfer</ref>(I2C_Handle<sp/>handle,<sp/><ref refid="struct_i2_c___transaction__" kindref="compound">I2C_Transaction</ref><sp/>*transaction);</highlight></codeline>
<codeline lineno="782"><highlight class="normal"></highlight></codeline>
<codeline lineno="783"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="784"><highlight class="normal">}</highlight></codeline>
<codeline lineno="785"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="786"><highlight class="normal"></highlight></codeline>
<codeline lineno="787"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>ti_drivers_I2C__include<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="exports/tidrivers_msp432/source/ti/drivers/I2C.h"/>
  </compounddef>
</doxygen>
