<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SPI.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_1395dc6568e73d67e90e363c4035e4f6.html">tidrivers_msp432</a></li><li class="navelem"><a class="el" href="dir_2ad5680906f12c9eddf121ba68442a90.html">source</a></li><li class="navelem"><a class="el" href="dir_0da705fc44f28017c66964e8e9f342d2.html">ti</a></li><li class="navelem"><a class="el" href="dir_5cee8d03ec8e05f2dc78c474d8f4ba05.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Serial Peripheral Interface (SPI) Driver Interface. </p>
<hr/>
<p><a class="anchor" id="ti_drivers_SPI_Overview"></a></p><h1>Overview</h1>
<p>The Serial Peripheral Interface (SPI) driver is a generic, full-duplex driver that transmits and receives data on a SPI bus. SPI is sometimes called SSI (Synchronous Serial Interface). The SPI protocol defines the format of a data transfer over the SPI bus, but it leaves flow control, data formatting, and handshaking mechanisms to higher-level software layers.</p>
<p>The SPI driver operates on some key definitions and assumptions:</p><ul>
<li>The driver operates transparently from the chip select. Some SPI controllers feature a hardware chip select to assert SPI slave peripherals. See the specific device implementations on chip select requirements.</li>
<li>The SPI protocol does not account for a built-in handshaking mechanism and neither does this SPI driver. Therefore, when operating in <a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942abc98c1546fe12d3fceb1f86cf670faa9">SPI_SLAVE</a> mode, the application must provide such a mechanism to ensure that the SPI slave is ready for the SPI master. The SPI slave must call <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> <em>before</em> the SPI master starts transmitting. Some example application mechanisms could include:<ul>
<li>Timed delays on the SPI master to guarantee the SPI slave is ready for a SPI transaction.</li>
<li>A form of GPIO flow control from the slave to the SPI master to notify the master when ready.</li>
</ul>
</li>
</ul>
<hr/>
<p> <a class="anchor" id="ti_drivers_SPI_Usage"></a></p><h1>Usage</h1>
<p>To use the SPI driver to send data over the SPI bus, the application calls the following APIs:</p><ul>
<li><a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a>: Initialize the SPI driver.</li>
<li><a class="el" href="_s_p_i_8h.html#a9c3dd1748332fd6e31c79a6538a71642" title="Function to initialize the SPI_Params struct to its defaults. ">SPI_Params_init()</a>: Initialize a <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> structure with default values. Then change the parameters from non-default values as needed.</li>
<li><a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>: Open an instance of the SPI driver, passing the initialized parameters, or NULL, and an index to the configuration to open (detailed later).</li>
<li><a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>: Transmit/receive data. This function takes a <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a> argument that describes the transfer that is requested.</li>
<li><a class="el" href="_s_p_i_8h.html#a0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a>: De-initialize the SPI instance.</li>
</ul>
<p><a class="anchor" id="ti_drivers_SPI_Synopsis"></a></p><h2>Synopsis</h2>
<p>The following code example opens a SPI instance as a master SPI, and issues a transaction.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a>      spi;</div><div class="line"><a class="code" href="struct_s_p_i___params.html">SPI_Params</a>      spiParams;</div><div class="line"><a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> spiTransaction;</div><div class="line">uint8_t         transmitBuffer[MSGSIZE];</div><div class="line">uint8_t         receiveBuffer[MSGSIZE];</div><div class="line"><span class="keywordtype">bool</span>            transferOK;</div><div class="line"></div><div class="line"><a class="code" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214">SPI_init</a>();  <span class="comment">// Initialize the SPI driver</span></div><div class="line"></div><div class="line"><a class="code" href="_s_p_i_8h.html#a9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;spiParams);  <span class="comment">// Initialize SPI parameters</span></div><div class="line">spiParams.<a class="code" href="struct_s_p_i___params.html#a30722b1de5e3b089ecf0c669da42ed2d">dataSize</a> = 8;       <span class="comment">// 8-bit data size</span></div><div class="line"></div><div class="line">spi = <a class="code" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(Board_SPI0, &amp;spiParams);</div><div class="line"><span class="keywordflow">if</span> (spi == NULL) {</div><div class="line">    <span class="keywordflow">while</span> (1);  <span class="comment">// SPI_open() failed</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Fill in transmitBuffer</span></div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">count</a> = MSGSIZE;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = (<span class="keywordtype">void</span> *)transmitBuffer;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = (<span class="keywordtype">void</span> *)receiveBuffer;</div><div class="line"></div><div class="line">transferOK = <a class="code" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spi, &amp;spiTransaction);</div><div class="line"><span class="keywordflow">if</span> (!transferOK) {</div><div class="line">    <span class="comment">// Error in SPI or transfer already in progress.</span></div><div class="line">    <span class="keywordflow">while</span> (1);</div><div class="line">}</div></div><!-- fragment --><p>More details on usage are provided in the following subsections.</p>
<p><a class="anchor" id="ti_drivers_SPI_Examples"></a></p><h2>Examples</h2>
<ul>
<li><a class="el" href="_s_p_i_8h.html#ti_drivers_SPI_Synopsis">Usage Synopsis</a></li>
<li><a class="el" href="_s_p_i_8h.html#ti_drivers_SPI_Example_openblocking">Open in blocking mode</a></li>
<li><a class="el" href="_s_p_i_8h.html#ti_drivers_SPI_Example_opencallback">Open in callback mode</a></li>
<li><a class="el" href="_s_p_i_8h.html#ti_drivers_SPI_Example_6bitframes">Sending 6 bit frames</a></li>
<li><a class="el" href="_s_p_i_8h.html#ti_drivers_SPI_Example_12bitframes">Sending 12 bit frames</a></li>
<li><a class="el" href="_s_p_i_8h.html#ti_drivers_SPI_Example_callbackarg">Callback function using arg</a></li>
</ul>
<h2>Initializing the SPI Driver</h2>
<p><a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a> must be called before any other SPI APIs. This function iterates through the elements of the <code>SPI_config</code>[] array, calling the element's device implementation SPI initialization function.</p>
<h2>Opening the SPI Driver</h2>
<p>After initializing the SPI driver by calling <a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a>, the application can open a SPI instance by calling <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>. This function takes an index into the <code>SPI_config</code>[] array, and a SPI parameters data structure. The SPI instance is specified by the index of the SPI in <code>SPI_config</code>[]. Calling <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> a second time with the same index previously passed to <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> will result in an error. You can, though, re-use the index if the instance is closed via <a class="el" href="_s_p_i_8h.html#a0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a>.</p>
<p>If no <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> structure is passed to <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>, default values are used. If the open call is successful, it returns a non-NULL value.</p>
<p><a class="anchor" id="ti_drivers_SPI_Example_openblocking"></a> Example opening a SPI driver instance in blocking mode: </p><div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a>  spi;</div><div class="line"><a class="code" href="struct_s_p_i___params.html">SPI_Params</a>  spiParams;</div><div class="line"></div><div class="line"><a class="code" href="_s_p_i_8h.html#a9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;spiParams);</div><div class="line">spiParams.<a class="code" href="struct_s_p_i___params.html#a16dbcc3768a01fb7deae25b48fc0d69c">transferMode</a> = <a class="code" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a>;</div><div class="line">spi = <a class="code" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(Board_SPI0, &amp;spiParams);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (spi == NULL) {</div><div class="line">    <span class="comment">// Error opening SPI</span></div><div class="line">    <span class="keywordflow">while</span>(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_SPI_Example_opencallback"></a> Example opening a SPI driver instance in callback mode: </p><div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a> spi;</div><div class="line"><a class="code" href="struct_s_p_i___params.html">SPI_Params</a> spiParams;</div><div class="line"></div><div class="line"><a class="code" href="_s_p_i_8h.html#a9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;spiParams);</div><div class="line">spiParams.<a class="code" href="struct_s_p_i___params.html#a16dbcc3768a01fb7deae25b48fc0d69c">transferMode</a> = <a class="code" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>;</div><div class="line">spiParams.<a class="code" href="struct_s_p_i___params.html#a68d1d610da6a6bf299121b939ef2a352">transferCallbackFxn</a> = UserCallbackFxn;</div><div class="line"></div><div class="line">spi = <a class="code" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(Board_SPI0, &amp;spiParams);</div><div class="line"><span class="keywordflow">if</span> (spi == NULL) {</div><div class="line">    <span class="comment">// Error opening SPI</span></div><div class="line">    <span class="keywordflow">while</span> (1);</div><div class="line">}</div></div><!-- fragment --><h2>SPI Parameters</h2>
<p>The <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> structure is passed to the <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> call. If NULL is passed for the parameters, <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> uses default parameters. A <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> structure is initialized with default values by passing it to <a class="el" href="_s_p_i_8h.html#a9c3dd1748332fd6e31c79a6538a71642" title="Function to initialize the SPI_Params struct to its defaults. ">SPI_Params_init()</a>. Some of the SPI parameters are described below. To see brief descriptions of all the parameters, see <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a>.</p>
<h3>SPI Mode</h3>
<p>The SPI driver operates in both SPI master and SPI slave modes. Logically, the implementation is identical, however the difference between these two modes is driven by hardware. The default mode is <a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942a84379dc90398ca075038c8d5ee465f6a">SPI_MASTER</a>, but can be set to slave mode by setting <a class="el" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">SPI_Params.mode</a> to <a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942abc98c1546fe12d3fceb1f86cf670faa9">SPI_SLAVE</a> in the parameters passed to <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>. See <a class="el" href="_s_p_i_8h.html#ti_drivers_SPI_MasterSlaveModes">Master/Slave Modes</a> for further details.</p>
<h3>SPI Transfer Mode</h3>
<p>The SPI driver supports two transfer modes of operation: blocking and callback. The transfer mode is determined by the transferMode parameter in the <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> data structure. The SPI driver defaults to blocking mode, if the application does not set it. Once a SPI driver is opened, the only way to change the operation mode is to close and re-open the SPI instance with the new transfer mode.</p>
<p>In blocking mode, a task's code execution is blocked until a SPI transaction has completed or a timeout has occurred. This ensures that only one SPI transfer operates at a given time. Other tasks requesting SPI transfers while a transfer is currently taking place will receive a FALSE return value. If a timeout occurs the transfer is canceled, the task is unblocked &amp; will receive a FALSE return value. The transaction count field will have the amount of frames which were transferred successfully before the timeout. In blocking mode, transfers cannot be performed in software or hardware ISR context.</p>
<p>In callback mode, a SPI transaction functions asynchronously, which means that it does not block code execution. After a SPI transaction has been completed, the SPI driver calls a user-provided hook function. Callback mode is supported in the execution context of tasks and hardware interrupt routines.</p>
<h3>SPI Frame Formats and Data Size</h3>
<p>The SPI driver can configure the device's SPI peripheral to transfer data in several SPI format options: SPI (with various polarity and phase settings), TI, and Micro-wire. The frame format is set with <a class="el" href="struct_s_p_i___params.html#a67b5ebb8ec72796a0260c427c91cc093">SPI_Params.frameFormat</a>. Some SPI implementations may not support all frame formats &amp; the SPI driver will fail to opened. Refer to the device specific implementation documentation for details on which frame formats are supported.</p>
<p>The smallest single unit of data transmitted onto the SPI bus is called a SPI frame and is of size <a class="el" href="struct_s_p_i___params.html#a30722b1de5e3b089ecf0c669da42ed2d">SPI_Params.dataSize</a>. A series of SPI frames transmitted/received on a SPI bus is referred to as a SPI transaction.</p>
<h2>SPI Transactions</h2>
<p>A SPI transaction consists of a series of SPI frames transmitted/received on a SPI bus. A SPI transaction is performed using <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>. <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> accepts a pointer to a <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a> structure that dictates the quantity of data to be sent and received. The <a class="el" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">SPI_Transaction.txBuf</a> and <a class="el" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">SPI_Transaction.rxBuf</a> are both pointers to data buffers. If txBuf is NULL, the driver sends SPI frames with all data set to the default value specified in the hardware attributes. If rxBuf is NULL, the driver discards all SPI frames received. <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> of a SPI transaction is performed atomically.</p>
<dl class="section warning"><dt>Warning</dt><dd>The use of NULL as a sentinel txBuf or rxBuf value to determine whether the SPI transaction includes a tx or rx component implies that it is not possible to perform a transmit or receive transfer directly from/to a buffer with a base address of 0x00000000. To support this rare use-case, the application will have to manually copy the contents of location 0x00000000 to/from a temporary buffer before/after the tx/rx SPI transaction.</dd></dl>
<p>When the SPI is opened, the dataSize value determines the element types of txBuf and rxBuf. If the dataSize is from 4 to 8 bits, the driver assumes the data buffers are of type uint8_t (unsigned char). If the dataSize is from 8 to 16 bits, the driver assumes the data buffers are of type uint16_t (unsigned short). If the dataSize is greater than 16 bits, the driver assumes the data buffers are uint32_t (unsigned long). Some SPI driver implementations may not support all data sizes; refer to device specific SPI implementation documentation for details on what data sizes are supported.</p>
<p>The optional <a class="el" href="struct_s_p_i___transaction.html#ac47daaa10705d748ace918a098aa1945">SPI_Transaction.arg</a> variable can only be used when the SPI driver has been opened in callback mode. This variable is used to pass a user-defined value into the user-defined callback function.</p>
<p><a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> always performs full-duplex SPI transactions. This means the SPI simultaneously receives data as it transmits data. The application is responsible for formatting the data to be transmitted as well as determining whether the data received is meaningful. Specifics about SPI frame formatting and data sizes are provided in device-specific data sheets and technical reference manuals.</p>
<p>The following code snippets perform SPI transactions.</p>
<p><a class="anchor" id="ti_drivers_SPI_Example_6bitframes"></a> Example transferring 6-bit SPI frames. The transmit and receive buffers are of type uint8_t. </p><div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> spiTransaction;</div><div class="line">uint8_t         transmitBuffer[BUFSIZE];</div><div class="line">uint8_t         receiveBuffer[BUFSIZE];</div><div class="line"><span class="keywordtype">bool</span>            transferOK;</div><div class="line"></div><div class="line"><a class="code" href="_s_p_i_8h.html#a9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;spiParams);</div><div class="line">spiParams.<a class="code" href="struct_s_p_i___params.html#a30722b1de5e3b089ecf0c669da42ed2d">dataSize</a> = 6;</div><div class="line">spi = <a class="code" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(Board_SPI0, &amp;spiParams);</div><div class="line">...</div><div class="line">spiTransaction.count = someIntegerValue;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = transmitBuffer;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = receiveBuffer;</div><div class="line"></div><div class="line">transferOK = <a class="code" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spi, &amp;spiTransaction);</div><div class="line"><span class="keywordflow">if</span> (!transferOK) {</div><div class="line">    <span class="comment">// Error in SPI or transfer already in progress.</span></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_SPI_Example_12bitframes"></a> Example transferring 12-bit SPI frames. The transmit and receive buffers are of type uint16_t. </p><div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> spiTransaction;</div><div class="line">uint16_t        transmitBuffer[BUFSIZE];</div><div class="line">uint16_t        receiveBuffer[BUFSIZE];</div><div class="line"><span class="keywordtype">bool</span>            transferOK;</div><div class="line"></div><div class="line"><a class="code" href="_s_p_i_8h.html#a9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;spiParams);</div><div class="line">spiParams.<a class="code" href="struct_s_p_i___params.html#a30722b1de5e3b089ecf0c669da42ed2d">dataSize</a> = 12;</div><div class="line">spi = <a class="code" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(Board_SPI0, &amp;spiParams);</div><div class="line">...</div><div class="line">spiTransaction.count = someIntegerValue;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = transmitBuffer;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = receiveBuffer;</div><div class="line"></div><div class="line">transferOK = <a class="code" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spi, &amp;spiTransaction);</div><div class="line"><span class="keywordflow">if</span> (!transferOK) {</div><div class="line">    <span class="comment">// Error in SPI or transfer already in progress.</span></div><div class="line">}</div></div><!-- fragment --><p>The following example shows an example of a callback function that utilizes the arg parameter. <a class="anchor" id="ti_drivers_SPI_Example_callbackarg"></a></p><div class="fragment"><div class="line"><span class="comment">// SPI is opened with callback function as seen in other examples</span></div><div class="line"><span class="comment">// Our goal is to post a semaphore when transfer with sufficient size</span></div><div class="line"><span class="comment">// completes.</span></div><div class="line">...</div><div class="line"><span class="comment">// Pass pointer to an initialized semaphore to callback via arg</span></div><div class="line">spiTransaction.count = someIntegerValue;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = transmitBuffer;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = receiveBuffer;</div><div class="line">spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#ac47daaa10705d748ace918a098aa1945">arg</a>   = &amp;mySemaphore;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Our callback function is defined here</span></div><div class="line">void spiCallbackFxn(<a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a> spi, <a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *tran)</div><div class="line">{</div><div class="line">    sem_t *semPtr = (sem_t *)(tran-&gt;<a class="code" href="struct_s_p_i___transaction.html#ac47daaa10705d748ace918a098aa1945">arg</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Post the semaphore if our transaction was more than LIMIT</span></div><div class="line">    <span class="keywordflow">if</span> (tran-&gt;<a class="code" href="struct_s_p_i___transaction.html#aa244504b2384411f7de17340be62128a">status</a> == <a class="code" href="group___s_p_i___s_t_a_t_u_s.html#gab38fa90ff62128dbc98b2ecd84ca106f">SPI_STATUS_SUCCESS</a> &amp;&amp;</div><div class="line">        tran-&gt;<a class="code" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">count</a> &gt; LIMIT) {</div><div class="line">        sem_post(semPtr);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2>Canceling a transaction</h2>
<p><a class="el" href="_s_p_i_8h.html#a6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a> is used to cancel a SPI transaction when the driver is used in <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a> mode.</p>
<p>Calling this API while no transfer is in progress has no effect. If a transfer is in progress, it is canceled and the callback functions is called. The <a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fb" title="Status codes that are set by the SPI driver. ">SPI_Status</a> status field in the <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a> structure can be examined within the callback to determine if the transaction succeeded.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="_s_p_i_8h.html#a6819f7761fc3505c4f885653ff8121f0">SPI_transferCancel</a>(spi);</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_SPI_MasterSlaveModes"></a></p><h2>Master/Slave Modes</h2>
<p>This SPI driver functions in both SPI master and SPI slave modes. Logically, the implementation is identical, however the difference between these two modes is driven by hardware. As a SPI master, the peripheral is in control of the clock signal and therefore will commence communications to the SPI slave immediately. As a SPI slave, the SPI driver prepares the peripheral to transmit and receive data in a way such that the peripheral is ready to transfer data when the SPI master initiates a transaction.</p>
<h2>Asserting on Chip Select</h2>
<p>The SPI protocol requires that the SPI master asserts a SPI slave's chip select pin prior to starting a SPI transaction. While this protocol is generally followed, various types of SPI peripherals have different timing requirements as to when and for how long the chip select pin must remain asserted for a SPI transaction.</p>
<p>Commonly, the SPI master uses a hardware chip select to assert and de-assert the SPI slave for every data frame. In other cases, a SPI slave imposes the requirement of asserting the chip select over several SPI data frames. This is generally accomplished by using a regular, general-purpose output pin. Due to the complexity of such SPI peripheral implementations, this SPI driver has been designed to operate transparently to the SPI chip select. When the hardware chip select is used, the peripheral automatically selects/enables the peripheral. When using a software chip select, the application needs to handle the proper chip select and pin configuration. Chip select support will vary per SPI peripheral, refer to the device specific implementation documentation for details on chip select support.</p>
<ul>
<li><em>Hardware chip select</em> No additional action by the application is required.</li>
<li><em>Software chip select</em> The application needs to handle the chip select assertion and de-assertion for the proper SPI peripheral.</li>
</ul>
<hr/>
<p> <a class="anchor" id="ti_drivers_SPI_Configuration"></a></p><h1>Configuration</h1>
<p>In order to use the SPI APIs, the application is required to provide device-specific SPI configuration in the Board.c file. The SPI driver interface defines a configuration data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct  </span>{</div><div class="line">    <a class="code" href="struct_s_p_i___fxn_table.html">SPI_FxnTable</a>  <span class="keyword">const</span>    *fxnTablePtr;</div><div class="line">    <span class="keywordtype">void</span>                   *object;</div><div class="line">    <span class="keywordtype">void</span>          <span class="keyword">const</span>    *hwAttrs;</div><div class="line">} <a class="code" href="_s_p_i_8h.html#a9ce9680cc88c403db466864c02ee4733">SPI_Config</a>;</div></div><!-- fragment --><p>The application must declare an array of <a class="el" href="_s_p_i_8h.html#a9ce9680cc88c403db466864c02ee4733" title="SPI Global configuration. ">SPI_Config</a> elements, named <code>SPI_config</code>[]. Each element of <code>SPI_config</code>[] must be populated with pointers to a device specific SPI driver implementation's function table, driver object, and hardware attributes. The hardware attributes define properties such as the SPI peripheral's base address, and the MOSI and MISO pins. Each element in <code>SPI_config</code>[] corresponds to a SPI instance, and none of the elements should have NULL pointers. There is no correlation between the index and the peripheral designation (such as SPI0 or SPI1). For example, it is possible to use SPI_config[0] for SPI1.</p>
<p>Because the SPI configuration is very device dependent, you will need to check the doxygen for the device specific SPI implementation. There you will find a description of the SPI hardware attributes. Please also refer to the Board.c file of any of your examples to see the SPI configuration. </p>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for SPI.h:</div>
<div class="dyncontent">
<div class="center"><img src="_s_p_i_8h__incl.png" border="0" usemap="#_s_p_i_8h" alt=""/></div>
<map name="_s_p_i_8h" id="_s_p_i_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_s_p_i_8h__dep__incl.png" border="0" usemap="#_s_p_i_8hdep" alt=""/></div>
<map name="_s_p_i_8hdep" id="_s_p_i_8hdep">
<area shape="rect" id="node2" href="_n_v_s_s_p_i25_x_8h.html" title="Non&#45;Volatile Storage driver implementation for SPI flash peripherals. " alt="" coords="5,80,112,107"/>
<area shape="rect" id="node3" href="_s_d_s_p_i_8h.html" title="SD driver implementation built on the TI SPI driver. " alt="" coords="136,80,211,107"/>
<area shape="rect" id="node4" href="_s_p_i_m_s_p432_d_m_a_8h.html" title="SPI driver implementation for a EUSCI peripheral on MSP432 using the micro DMA controller. " alt="" coords="235,80,370,107"/>
<area shape="rect" id="node5" href="_display_sharp_8h.html" title="DisplaySharp.h" alt="" coords="394,80,505,107"/>
<area shape="rect" id="node6" href="_sharp_gr_lib_8h.html" title="SharpGrLib.h" alt="" coords="529,80,628,107"/>
</map>
</div>
</div>
<p><a href="_s_p_i_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___transaction.html">SPI_Transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a> data structure is used with <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>. It indicates how many <a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489" title="Definitions for various SPI data frame formats. ">SPI_FrameFormat</a> frames are sent and received from the buffers pointed to txBuf and rxBuf. The arg variable is an user-definable argument which gets passed to the <a class="el" href="_s_p_i_8h.html#a207e2d5a7e7ea5606b6995b6485ca015" title="The definition of a callback function used by the SPI driver when used in SPI_MODE_CALLBACK. ">SPI_CallbackFxn</a> when the SPI driver is in <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>.  <a href="struct_s_p_i___transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___params.html">SPI_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Parameters.  <a href="struct_s_p_i___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___fxn_table.html">SPI_FxnTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a SPI function table that contains the required set of functions to control a specific SPI driver implementation.  <a href="struct_s_p_i___fxn_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___config__.html">SPI_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Global configuration.  <a href="struct_s_p_i___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3d23d16525ee76f77276472d8dea80b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___c_o_n_t_r_o_l.html#ga3d23d16525ee76f77276472d8dea80b0">SPI_CMD_RESERVED</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="separator:ga3d23d16525ee76f77276472d8dea80b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1af8c6ebf5e8fe481649f65e37b1b9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___c_o_n_t_r_o_l.html#gae1af8c6ebf5e8fe481649f65e37b1b9f">SPI_STATUS_RESERVED</a>&#160;&#160;&#160;(-32)</td></tr>
<tr class="separator:gae1af8c6ebf5e8fe481649f65e37b1b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38fa90ff62128dbc98b2ecd84ca106f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___s_t_a_t_u_s.html#gab38fa90ff62128dbc98b2ecd84ca106f">SPI_STATUS_SUCCESS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gab38fa90ff62128dbc98b2ecd84ca106f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code returned by <a class="el" href="_s_p_i_8h.html#a1b3fafc9892141b7bab1bc9c19ede9ef" title="Function performs implementation specific features on a given SPI_Handle. ">SPI_control()</a>.  <a href="group___s_p_i___s_t_a_t_u_s.html#gab38fa90ff62128dbc98b2ecd84ca106f">More...</a><br /></td></tr>
<tr class="separator:gab38fa90ff62128dbc98b2ecd84ca106f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0020dd673cc28a9e1c20b0ff101073"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___s_t_a_t_u_s.html#ga2d0020dd673cc28a9e1c20b0ff101073">SPI_STATUS_ERROR</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:ga2d0020dd673cc28a9e1c20b0ff101073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code returned by <a class="el" href="_s_p_i_8h.html#a1b3fafc9892141b7bab1bc9c19ede9ef" title="Function performs implementation specific features on a given SPI_Handle. ">SPI_control()</a>.  <a href="group___s_p_i___s_t_a_t_u_s.html#ga2d0020dd673cc28a9e1c20b0ff101073">More...</a><br /></td></tr>
<tr class="separator:ga2d0020dd673cc28a9e1c20b0ff101073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfcd15e1eecdb99b4867adc7592a8d6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___s_t_a_t_u_s.html#gacfcd15e1eecdb99b4867adc7592a8d6e">SPI_STATUS_UNDEFINEDCMD</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:gacfcd15e1eecdb99b4867adc7592a8d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned by <a class="el" href="_s_p_i_8h.html#a1b3fafc9892141b7bab1bc9c19ede9ef" title="Function performs implementation specific features on a given SPI_Handle. ">SPI_control()</a> for undefined command codes.  <a href="group___s_p_i___s_t_a_t_u_s.html#gacfcd15e1eecdb99b4867adc7592a8d6e">More...</a><br /></td></tr>
<tr class="separator:gacfcd15e1eecdb99b4867adc7592a8d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cab73b936e6e08392882196df41277e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a7cab73b936e6e08392882196df41277e">SPI_WAIT_FOREVER</a>&#160;&#160;&#160;(~(0U))</td></tr>
<tr class="memdesc:a7cab73b936e6e08392882196df41277e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait forever define used to specify timeouts.  <a href="#a7cab73b936e6e08392882196df41277e">More...</a><br /></td></tr>
<tr class="separator:a7cab73b936e6e08392882196df41277e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a93072bc33543d36c9603198df25ee388"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_s_p_i___config__.html">SPI_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a></td></tr>
<tr class="memdesc:a93072bc33543d36c9603198df25ee388"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> call.  <a href="#a93072bc33543d36c9603198df25ee388">More...</a><br /></td></tr>
<tr class="separator:a93072bc33543d36c9603198df25ee388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207e2d5a7e7ea5606b6995b6485ca015"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a207e2d5a7e7ea5606b6995b6485ca015">SPI_CallbackFxn</a>) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, <a class="el" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:a207e2d5a7e7ea5606b6995b6485ca015"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the SPI driver when used in <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>.  <a href="#a207e2d5a7e7ea5606b6995b6485ca015">More...</a><br /></td></tr>
<tr class="separator:a207e2d5a7e7ea5606b6995b6485ca015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa361d580eb0a5a052d0a1403e0aa5746"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#aa361d580eb0a5a052d0a1403e0aa5746">SPI_CloseFxn</a>) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle)</td></tr>
<tr class="memdesc:aa361d580eb0a5a052d0a1403e0aa5746"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a>.  <a href="#aa361d580eb0a5a052d0a1403e0aa5746">More...</a><br /></td></tr>
<tr class="separator:aa361d580eb0a5a052d0a1403e0aa5746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0505b9eca5030ca4fc27959e2b5134ca"><td class="memItemLeft" align="right" valign="top">typedef int_fast16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a0505b9eca5030ca4fc27959e2b5134ca">SPI_ControlFxn</a>) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, uint_fast16_t cmd, void *arg)</td></tr>
<tr class="memdesc:a0505b9eca5030ca4fc27959e2b5134ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a1b3fafc9892141b7bab1bc9c19ede9ef" title="Function performs implementation specific features on a given SPI_Handle. ">SPI_control()</a>.  <a href="#a0505b9eca5030ca4fc27959e2b5134ca">More...</a><br /></td></tr>
<tr class="separator:a0505b9eca5030ca4fc27959e2b5134ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b32db8f017fd0ce92bf46a089659e6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#aa3b32db8f017fd0ce92bf46a089659e6">SPI_InitFxn</a>) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle)</td></tr>
<tr class="memdesc:aa3b32db8f017fd0ce92bf46a089659e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a>.  <a href="#aa3b32db8f017fd0ce92bf46a089659e6">More...</a><br /></td></tr>
<tr class="separator:aa3b32db8f017fd0ce92bf46a089659e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0786f4c1487f9daec49adbc3ac1cf5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a7e0786f4c1487f9daec49adbc3ac1cf5">SPI_OpenFxn</a>) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, <a class="el" href="struct_s_p_i___params.html">SPI_Params</a> *params)</td></tr>
<tr class="memdesc:a7e0786f4c1487f9daec49adbc3ac1cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>.  <a href="#a7e0786f4c1487f9daec49adbc3ac1cf5">More...</a><br /></td></tr>
<tr class="separator:a7e0786f4c1487f9daec49adbc3ac1cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470d264d053b30edb0aaafcafd335c26"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a470d264d053b30edb0aaafcafd335c26">SPI_TransferFxn</a>) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, <a class="el" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:a470d264d053b30edb0aaafcafd335c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>.  <a href="#a470d264d053b30edb0aaafcafd335c26">More...</a><br /></td></tr>
<tr class="separator:a470d264d053b30edb0aaafcafd335c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f5b214451ac89ea462083eeba0bf8c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a33f5b214451ac89ea462083eeba0bf8c">SPI_TransferCancelFxn</a>) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle)</td></tr>
<tr class="memdesc:a33f5b214451ac89ea462083eeba0bf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a>.  <a href="#a33f5b214451ac89ea462083eeba0bf8c">More...</a><br /></td></tr>
<tr class="separator:a33f5b214451ac89ea462083eeba0bf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce9680cc88c403db466864c02ee4733"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_s_p_i___config__.html">SPI_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a9ce9680cc88c403db466864c02ee4733">SPI_Config</a></td></tr>
<tr class="memdesc:a9ce9680cc88c403db466864c02ee4733"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Global configuration.  <a href="#a9ce9680cc88c403db466864c02ee4733">More...</a><br /></td></tr>
<tr class="separator:a9ce9680cc88c403db466864c02ee4733"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a913c57c335166de9caa54b7eb9ad95fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fb">SPI_Status</a> { <br />
&#160;&#160;<a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fbabb35466595b950df7e3e3d880336502b">SPI_TRANSFER_COMPLETED</a> = 0, 
<a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fbad5266453aecb2fdedc0c23cd90921627">SPI_TRANSFER_STARTED</a>, 
<a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fba78957da92681e8400d84d9d3ede55836">SPI_TRANSFER_CANCELED</a>, 
<a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fbac01b83da31c34da13025a5b987ef013f">SPI_TRANSFER_FAILED</a>, 
<br />
&#160;&#160;<a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fbaa363cddc53c1f44ca73aa661e6535816">SPI_TRANSFER_CSN_DEASSERT</a>, 
<a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fbad9c52e5a8cefc5b6926e19a8dd62125b">SPI_TRANSFER_PEND_CSN_ASSERT</a>, 
<a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fba296a4fda0015070e612ab8e1ee5bc287">SPI_TRANSFER_QUEUED</a>
<br />
 }<tr class="memdesc:a913c57c335166de9caa54b7eb9ad95fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status codes that are set by the SPI driver.  <a href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a913c57c335166de9caa54b7eb9ad95fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a7e3d74577b38aa79ea6983362f942"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942">SPI_Mode</a> { <a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942a84379dc90398ca075038c8d5ee465f6a">SPI_MASTER</a> = 0, 
<a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942abc98c1546fe12d3fceb1f86cf670faa9">SPI_SLAVE</a> = 1
 }<tr class="memdesc:a60a7e3d74577b38aa79ea6983362f942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for various SPI modes of operation.  <a href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a60a7e3d74577b38aa79ea6983362f942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1f33555dfa8147205af5b266f3a489"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489">SPI_FrameFormat</a> { <br />
&#160;&#160;<a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489a0396d8c01166ff94e94e0c200261eba3">SPI_POL0_PHA0</a> = 0, 
<a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489a340efc6d0f6f3b5be1151444c15faabf">SPI_POL0_PHA1</a> = 1, 
<a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489ace88daceb628498715aeda698541c95c">SPI_POL1_PHA0</a> = 2, 
<a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489a4441729b292511628cb1e9f102da9166">SPI_POL1_PHA1</a> = 3, 
<br />
&#160;&#160;<a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489ac3cb11b3a833e28368e267161551eb1d">SPI_TI</a> = 4, 
<a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489a34dc698e46fc5c1b2b1f0de19a44fdcb">SPI_MW</a> = 5
<br />
 }<tr class="memdesc:a4e1f33555dfa8147205af5b266f3a489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for various SPI data frame formats.  <a href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4e1f33555dfa8147205af5b266f3a489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ea76c6529d6076eee5e1c4a5a92c6f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6f">SPI_TransferMode</a> { <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a>, 
<a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>
 }<tr class="memdesc:ab9ea76c6529d6076eee5e1c4a5a92c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI transfer mode determines the whether the SPI controller operates synchronously or asynchronously. In <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a> mode <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> blocks code execution until the SPI transaction has completed. In <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a> <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> does not block code execution and instead calls a <a class="el" href="_s_p_i_8h.html#a207e2d5a7e7ea5606b6995b6485ca015" title="The definition of a callback function used by the SPI driver when used in SPI_MODE_CALLBACK. ">SPI_CallbackFxn</a> callback function when the transaction has completed (successfully or not).  <a href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab9ea76c6529d6076eee5e1c4a5a92c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0e3448b30b88609fa120915e49560601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a0e3448b30b88609fa120915e49560601">SPI_close</a> (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle)</td></tr>
<tr class="memdesc:a0e3448b30b88609fa120915e49560601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a SPI peripheral specified by the SPI handle.  <a href="#a0e3448b30b88609fa120915e49560601">More...</a><br /></td></tr>
<tr class="separator:a0e3448b30b88609fa120915e49560601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3fafc9892141b7bab1bc9c19ede9ef"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a1b3fafc9892141b7bab1bc9c19ede9ef">SPI_control</a> (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, uint_fast16_t cmd, void *controlArg)</td></tr>
<tr class="memdesc:a1b3fafc9892141b7bab1bc9c19ede9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388" title="A handle that is returned from a SPI_open() call. ">SPI_Handle</a>.  <a href="#a1b3fafc9892141b7bab1bc9c19ede9ef">More...</a><br /></td></tr>
<tr class="separator:a1b3fafc9892141b7bab1bc9c19ede9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9b09f58917f0e2d14c61b956eba214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214">SPI_init</a> (void)</td></tr>
<tr class="memdesc:afd9b09f58917f0e2d14c61b956eba214"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the SPI module.  <a href="#afd9b09f58917f0e2d14c61b956eba214">More...</a><br /></td></tr>
<tr class="separator:afd9b09f58917f0e2d14c61b956eba214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9022decfb136991d6b53f7dd2ae2fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a> (uint_least8_t index, <a class="el" href="struct_s_p_i___params.html">SPI_Params</a> *params)</td></tr>
<tr class="memdesc:a9c9022decfb136991d6b53f7dd2ae2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function opens a given SPI peripheral.  <a href="#a9c9022decfb136991d6b53f7dd2ae2fc">More...</a><br /></td></tr>
<tr class="separator:a9c9022decfb136991d6b53f7dd2ae2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3dd1748332fd6e31c79a6538a71642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a> (<a class="el" href="struct_s_p_i___params.html">SPI_Params</a> *params)</td></tr>
<tr class="memdesc:a9c3dd1748332fd6e31c79a6538a71642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> struct to its defaults.  <a href="#a9c3dd1748332fd6e31c79a6538a71642">More...</a><br /></td></tr>
<tr class="separator:a9c3dd1748332fd6e31c79a6538a71642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989e17f96b54fcc3dc2cac5f8ac6bdb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a> (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, <a class="el" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:a989e17f96b54fcc3dc2cac5f8ac6bdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform SPI transactions.  <a href="#a989e17f96b54fcc3dc2cac5f8ac6bdb2">More...</a><br /></td></tr>
<tr class="separator:a989e17f96b54fcc3dc2cac5f8ac6bdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6819f7761fc3505c4f885653ff8121f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_s_p_i_8h.html#a6819f7761fc3505c4f885653ff8121f0">SPI_transferCancel</a> (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle)</td></tr>
<tr class="memdesc:a6819f7761fc3505c4f885653ff8121f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to cancel SPI transactions.  <a href="#a6819f7761fc3505c4f885653ff8121f0">More...</a><br /></td></tr>
<tr class="separator:a6819f7761fc3505c4f885653ff8121f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7cab73b936e6e08392882196df41277e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cab73b936e6e08392882196df41277e">&sect;&nbsp;</a></span>SPI_WAIT_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_WAIT_FOREVER&#160;&#160;&#160;(~(0U))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait forever define used to specify timeouts. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a93072bc33543d36c9603198df25ee388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93072bc33543d36c9603198df25ee388">&sect;&nbsp;</a></span>SPI_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_s_p_i___config__.html">SPI_Config_</a>* <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from a <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> call. </p>

</div>
</div>
<a id="a207e2d5a7e7ea5606b6995b6485ca015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207e2d5a7e7ea5606b6995b6485ca015">&sect;&nbsp;</a></span>SPI_CallbackFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SPI_CallbackFxn) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, <a class="el" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *transaction)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the SPI driver when used in <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SPI_Handle</td><td>A <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388" title="A handle that is returned from a SPI_open() call. ">SPI_Handle</a> </td></tr>
    <tr><td class="paramname">SPI_Transaction*</td><td>Pointer to a <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa361d580eb0a5a052d0a1403e0aa5746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa361d580eb0a5a052d0a1403e0aa5746">&sect;&nbsp;</a></span>SPI_CloseFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SPI_CloseFxn) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a>. </p>

</div>
</div>
<a id="a0505b9eca5030ca4fc27959e2b5134ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0505b9eca5030ca4fc27959e2b5134ca">&sect;&nbsp;</a></span>SPI_ControlFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast16_t(* SPI_ControlFxn) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, uint_fast16_t cmd, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a1b3fafc9892141b7bab1bc9c19ede9ef" title="Function performs implementation specific features on a given SPI_Handle. ">SPI_control()</a>. </p>

</div>
</div>
<a id="aa3b32db8f017fd0ce92bf46a089659e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b32db8f017fd0ce92bf46a089659e6">&sect;&nbsp;</a></span>SPI_InitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SPI_InitFxn) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a>. </p>

</div>
</div>
<a id="a7e0786f4c1487f9daec49adbc3ac1cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0786f4c1487f9daec49adbc3ac1cf5">&sect;&nbsp;</a></span>SPI_OpenFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a>(* SPI_OpenFxn) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, <a class="el" href="struct_s_p_i___params.html">SPI_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>. </p>

</div>
</div>
<a id="a470d264d053b30edb0aaafcafd335c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470d264d053b30edb0aaafcafd335c26">&sect;&nbsp;</a></span>SPI_TransferFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* SPI_TransferFxn) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle, <a class="el" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *transaction)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>. </p>

</div>
</div>
<a id="a33f5b214451ac89ea462083eeba0bf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f5b214451ac89ea462083eeba0bf8c">&sect;&nbsp;</a></span>SPI_TransferCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SPI_TransferCancelFxn) (<a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_s_p_i_8h.html#a6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a>. </p>

</div>
</div>
<a id="a9ce9680cc88c403db466864c02ee4733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce9680cc88c403db466864c02ee4733">&sect;&nbsp;</a></span>SPI_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_s_p_i___config__.html">SPI_Config_</a>  <a class="el" href="_s_p_i_8h.html#a9ce9680cc88c403db466864c02ee4733">SPI_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI Global configuration. </p>
<p>The <a class="el" href="_s_p_i_8h.html#a9ce9680cc88c403db466864c02ee4733" title="SPI Global configuration. ">SPI_Config</a> structure contains a set of pointers used to characterize the SPI driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a913c57c335166de9caa54b7eb9ad95fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913c57c335166de9caa54b7eb9ad95fb">&sect;&nbsp;</a></span>SPI_Status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fb">SPI_Status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status codes that are set by the SPI driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a913c57c335166de9caa54b7eb9ad95fbabb35466595b950df7e3e3d880336502b"></a>SPI_TRANSFER_COMPLETED&#160;</td><td class="fielddoc"><p>SPI transfer completed </p>
</td></tr>
<tr><td class="fieldname"><a id="a913c57c335166de9caa54b7eb9ad95fbad5266453aecb2fdedc0c23cd90921627"></a>SPI_TRANSFER_STARTED&#160;</td><td class="fielddoc"><p>SPI transfer started and in progress </p>
</td></tr>
<tr><td class="fieldname"><a id="a913c57c335166de9caa54b7eb9ad95fba78957da92681e8400d84d9d3ede55836"></a>SPI_TRANSFER_CANCELED&#160;</td><td class="fielddoc"><p>SPI transfer was canceled </p>
</td></tr>
<tr><td class="fieldname"><a id="a913c57c335166de9caa54b7eb9ad95fbac01b83da31c34da13025a5b987ef013f"></a>SPI_TRANSFER_FAILED&#160;</td><td class="fielddoc"><p>SPI transfer failed </p>
</td></tr>
<tr><td class="fieldname"><a id="a913c57c335166de9caa54b7eb9ad95fbaa363cddc53c1f44ca73aa661e6535816"></a>SPI_TRANSFER_CSN_DEASSERT&#160;</td><td class="fielddoc"><p>SPI chip select was de-asserted (only applicable in return partial mode) </p>
</td></tr>
<tr><td class="fieldname"><a id="a913c57c335166de9caa54b7eb9ad95fbad9c52e5a8cefc5b6926e19a8dd62125b"></a>SPI_TRANSFER_PEND_CSN_ASSERT&#160;</td><td class="fielddoc"><p>SPI transfer is pending until the chip select is asserted </p>
</td></tr>
<tr><td class="fieldname"><a id="a913c57c335166de9caa54b7eb9ad95fba296a4fda0015070e612ab8e1ee5bc287"></a>SPI_TRANSFER_QUEUED&#160;</td><td class="fielddoc"><p>SPI transfer added to transaction queue </p>
</td></tr>
</table>

</div>
</div>
<a id="a60a7e3d74577b38aa79ea6983362f942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a7e3d74577b38aa79ea6983362f942">&sect;&nbsp;</a></span>SPI_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942">SPI_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for various SPI modes of operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a60a7e3d74577b38aa79ea6983362f942a84379dc90398ca075038c8d5ee465f6a"></a>SPI_MASTER&#160;</td><td class="fielddoc"><p>SPI in master mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a60a7e3d74577b38aa79ea6983362f942abc98c1546fe12d3fceb1f86cf670faa9"></a>SPI_SLAVE&#160;</td><td class="fielddoc"><p>SPI in slave mode </p>
</td></tr>
</table>

</div>
</div>
<a id="a4e1f33555dfa8147205af5b266f3a489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1f33555dfa8147205af5b266f3a489">&sect;&nbsp;</a></span>SPI_FrameFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489">SPI_FrameFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for various SPI data frame formats. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4e1f33555dfa8147205af5b266f3a489a0396d8c01166ff94e94e0c200261eba3"></a>SPI_POL0_PHA0&#160;</td><td class="fielddoc"><p>SPI mode Polarity 0 Phase 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e1f33555dfa8147205af5b266f3a489a340efc6d0f6f3b5be1151444c15faabf"></a>SPI_POL0_PHA1&#160;</td><td class="fielddoc"><p>SPI mode Polarity 0 Phase 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e1f33555dfa8147205af5b266f3a489ace88daceb628498715aeda698541c95c"></a>SPI_POL1_PHA0&#160;</td><td class="fielddoc"><p>SPI mode Polarity 1 Phase 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e1f33555dfa8147205af5b266f3a489a4441729b292511628cb1e9f102da9166"></a>SPI_POL1_PHA1&#160;</td><td class="fielddoc"><p>SPI mode Polarity 1 Phase 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e1f33555dfa8147205af5b266f3a489ac3cb11b3a833e28368e267161551eb1d"></a>SPI_TI&#160;</td><td class="fielddoc"><p>TI mode (not supported on all implementations) </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e1f33555dfa8147205af5b266f3a489a34dc698e46fc5c1b2b1f0de19a44fdcb"></a>SPI_MW&#160;</td><td class="fielddoc"><p>Micro-wire mode (not supported on all implementations) </p>
</td></tr>
</table>

</div>
</div>
<a id="ab9ea76c6529d6076eee5e1c4a5a92c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ea76c6529d6076eee5e1c4a5a92c6f">&sect;&nbsp;</a></span>SPI_TransferMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6f">SPI_TransferMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI transfer mode determines the whether the SPI controller operates synchronously or asynchronously. In <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a> mode <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> blocks code execution until the SPI transaction has completed. In <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a> <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> does not block code execution and instead calls a <a class="el" href="_s_p_i_8h.html#a207e2d5a7e7ea5606b6995b6485ca015" title="The definition of a callback function used by the SPI driver when used in SPI_MODE_CALLBACK. ">SPI_CallbackFxn</a> callback function when the transaction has completed (successfully or not). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8"></a>SPI_MODE_BLOCKING&#160;</td><td class="fielddoc"><p><a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> blocks execution. This mode can only be used when called within a Task context </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb"></a>SPI_MODE_CALLBACK&#160;</td><td class="fielddoc"><p><a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> does not block code execution and will call a <a class="el" href="_s_p_i_8h.html#a207e2d5a7e7ea5606b6995b6485ca015" title="The definition of a callback function used by the SPI driver when used in SPI_MODE_CALLBACK. ">SPI_CallbackFxn</a>. This mode can be used in a Task, software or hardware interrupt context. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0e3448b30b88609fa120915e49560601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3448b30b88609fa120915e49560601">&sect;&nbsp;</a></span>SPI_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a SPI peripheral specified by the SPI handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388" title="A handle that is returned from a SPI_open() call. ">SPI_Handle</a> returned from <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> </dd></dl>

</div>
</div>
<a id="a1b3fafc9892141b7bab1bc9c19ede9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3fafc9892141b7bab1bc9c19ede9ef">&sect;&nbsp;</a></span>SPI_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t SPI_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>controlArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a given <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388" title="A handle that is returned from a SPI_open() call. ">SPI_Handle</a>. </p>
<p>Commands for SPI_control can originate from <a class="el" href="_s_p_i_8h.html" title="Serial Peripheral Interface (SPI) Driver Interface. ">SPI.h</a> or from implementation specific SPI*.h (SPICC26XXDMA.h, <a class="el" href="_s_p_i_m_s_p432_d_m_a_8h.html" title="SPI driver implementation for a EUSCI peripheral on MSP432 using the micro DMA controller. ">SPIMSP432DMA.h</a>, etc.. ) files. While commands from <a class="el" href="_s_p_i_8h.html" title="Serial Peripheral Interface (SPI) Driver Interface. ">SPI.h</a> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific SPI*.h files add unique driver capabilities but are not API portable across all SPI driver implementations.</p>
<p>Commands supported by <a class="el" href="_s_p_i_8h.html" title="Serial Peripheral Interface (SPI) Driver Interface. ">SPI.h</a> follow a SPI_CMD_&lt;cmd&gt; naming convention.<br />
 Commands supported by SPI*.h follow a SPI*_CMD_&lt;cmd&gt; naming convention.<br />
 Each control command defines <b>arg</b> differently. The types of <b>arg</b> are documented with each command.</p>
<p>See <a class="el" href="group___s_p_i___c_m_d.html">SPI_control command codes</a> for command codes.</p>
<p>See <a class="el" href="group___s_p_i___s_t_a_t_u_s.html">SPI_control return status codes</a> for status codes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388" title="A handle that is returned from a SPI_open() call. ">SPI_Handle</a> returned from <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td><a class="el" href="_s_p_i_8h.html" title="Serial Peripheral Interface (SPI) Driver Interface. ">SPI.h</a> or SPI*.h commands.</td></tr>
    <tr><td class="paramname">controlArg</td><td>An optional R/W (read/write) command argument accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> </dd></dl>

</div>
</div>
<a id="afd9b09f58917f0e2d14c61b956eba214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9b09f58917f0e2d14c61b956eba214">&sect;&nbsp;</a></span>SPI_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the SPI module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The SPI_config[] array must exist and be persistent before this function can be called. This function must also be called before any other SPI driver APIs. This function call does not modify any peripheral registers. </dd></dl>

</div>
</div>
<a id="a9c9022decfb136991d6b53f7dd2ae2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9022decfb136991d6b53f7dd2ae2fc">&sect;&nbsp;</a></span>SPI_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a> SPI_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_p_i___params.html">SPI_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function opens a given SPI peripheral. </p>
<dl class="section pre"><dt>Precondition</dt><dd>SPI controller has been initialized using <a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of config to use in the <em>SPI_config</em> array</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to an parameter block, if NULL it will use default values. All the fields in this structure are RO (read-only).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388" title="A handle that is returned from a SPI_open() call. ">SPI_Handle</a> on success or a NULL on an error or if it has been opened already.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a> </dd>
<dd>
<a class="el" href="_s_p_i_8h.html#a0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a> </dd></dl>

</div>
</div>
<a id="a9c3dd1748332fd6e31c79a6538a71642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3dd1748332fd6e31c79a6538a71642">&sect;&nbsp;</a></span>SPI_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_p_i___params.html">SPI_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are:</p><ul>
<li><a class="el" href="struct_s_p_i___params.html#a16dbcc3768a01fb7deae25b48fc0d69c">SPI_Params.transferMode</a> = <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a></li>
<li><a class="el" href="struct_s_p_i___params.html#a600801907cf396a96825eaf69781913a">SPI_Params.transferTimeout</a> = <a class="el" href="_s_p_i_8h.html#a7cab73b936e6e08392882196df41277e" title="Wait forever define used to specify timeouts. ">SPI_WAIT_FOREVER</a></li>
<li><a class="el" href="struct_s_p_i___params.html#a68d1d610da6a6bf299121b939ef2a352">SPI_Params.transferCallbackFxn</a> = NULL</li>
<li><a class="el" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">SPI_Params.mode</a> = <a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942a84379dc90398ca075038c8d5ee465f6a">SPI_MASTER</a></li>
<li><a class="el" href="struct_s_p_i___params.html#ab3f035044fdbe75adac8c1d729d8cf20" title="SPI bit rate in Hz. ">SPI_Params.bitRate</a> = 1000000 (Hz)</li>
<li><a class="el" href="struct_s_p_i___params.html#a30722b1de5e3b089ecf0c669da42ed2d">SPI_Params.dataSize</a> = 8 (bits)</li>
<li><a class="el" href="struct_s_p_i___params.html#a67b5ebb8ec72796a0260c427c91cc093">SPI_Params.frameFormat</a> = <a class="el" href="_s_p_i_8h.html#a4e1f33555dfa8147205af5b266f3a489a0396d8c01166ff94e94e0c200261eba3">SPI_POL0_PHA0</a> </li>
</ul>

</div>
</div>
<a id="a989e17f96b54fcc3dc2cac5f8ac6bdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989e17f96b54fcc3dc2cac5f8ac6bdb2">&sect;&nbsp;</a></span>SPI_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SPI_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to perform SPI transactions. </p>
<p>If the SPI is in <a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942a84379dc90398ca075038c8d5ee465f6a">SPI_MASTER</a> mode, it will immediately start the transaction. If the SPI is in <a class="el" href="_s_p_i_8h.html#a60a7e3d74577b38aa79ea6983362f942abc98c1546fe12d3fceb1f86cf670faa9">SPI_SLAVE</a> mode, it prepares the driver for a transaction with a SPI master device. The device will then wait until the master begins the transfer.</p>
<p>In <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a>, <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> will block task execution until the transaction has completed or a timeout has occurred.</p>
<p>In <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>, SPI_transfer() does not block task execution, but calls a <a class="el" href="_s_p_i_8h.html#a207e2d5a7e7ea5606b6995b6485ca015" title="The definition of a callback function used by the SPI driver when used in SPI_MODE_CALLBACK. ">SPI_CallbackFxn</a> once the transfer has finished. This makes SPI_tranfer() safe to be used within a Task, software or hardware interrupt context. If queued transactions are supported SPI_Transfer may be called multiple times to queue multiple transactions. If the driver does not support this functionality additional calls will return false. Refer to device specific SPI driver documentation for support information.</p>
<p>From calling <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> until transfer completion, the <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a> structure must stay persistent and must not be altered by application code. It is also forbidden to modify the content of the <a class="el" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">SPI_Transaction.txBuf</a> during a transaction, even though the physical transfer might not have started yet. Doing this can result in data corruption. This is especially important for slave operations where <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> might be called a long time before the actual data transfer begins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388" title="A handle that is returned from a SPI_open() call. ">SPI_Handle</a></td></tr>
    <tr><td class="paramname">transaction</td><td>A pointer to a <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a>. All of the fields within transaction except <a class="el" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">SPI_Transaction.count</a> and <a class="el" href="struct_s_p_i___transaction.html#aa244504b2384411f7de17340be62128a">SPI_Transaction.status</a> are WO (write-only) unless otherwise noted in the driver implementations. If a transaction timeout has occurred, <a class="el" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">SPI_Transaction.count</a> will contain the number of frames that were transferred. Neither is it allowed to modify the transaction object nor the content of <a class="el" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">SPI_Transaction.txBuf</a> until the transfer has completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if started successfully; else <code>false</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open</a> </dd>
<dd>
<a class="el" href="_s_p_i_8h.html#a6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel</a> </dd></dl>

</div>
</div>
<a id="a6819f7761fc3505c4f885653ff8121f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6819f7761fc3505c4f885653ff8121f0">&sect;&nbsp;</a></span>SPI_transferCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_transferCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388">SPI_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to cancel SPI transactions. </p>
<p>In <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a>, SPI_transferCancel has no effect.</p>
<p>In <a class="el" href="_s_p_i_8h.html#ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>, <a class="el" href="_s_p_i_8h.html#a6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a> will stop an SPI transfer if if one is in progress. If a transaction was in progress, its callback function will be called in context from which this API is called from. The <a class="el" href="_s_p_i_8h.html#a207e2d5a7e7ea5606b6995b6485ca015" title="The definition of a callback function used by the SPI driver when used in SPI_MODE_CALLBACK. ">SPI_CallbackFxn</a> function can determine if the transaction was successful or not by reading the <a class="el" href="_s_p_i_8h.html#a913c57c335166de9caa54b7eb9ad95fb" title="Status codes that are set by the SPI driver. ">SPI_Status</a> status value in the <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a> structure.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_s_p_i_8h.html#afd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a>, <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>, <a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> are called</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_s_p_i_8h.html#a93072bc33543d36c9603198df25ee388" title="A handle that is returned from a SPI_open() call. ">SPI_Handle</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open</a> </dd>
<dd>
<a class="el" href="_s_p_i_8h.html#a989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
