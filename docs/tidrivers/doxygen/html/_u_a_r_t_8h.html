<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>UART.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_1395dc6568e73d67e90e363c4035e4f6.html">tidrivers_msp432</a></li><li class="navelem"><a class="el" href="dir_2ad5680906f12c9eddf121ba68442a90.html">source</a></li><li class="navelem"><a class="el" href="dir_0da705fc44f28017c66964e8e9f342d2.html">ti</a></li><li class="navelem"><a class="el" href="dir_5cee8d03ec8e05f2dc78c474d8f4ba05.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Universal Asynchronous Receiver-Transmitter (UART) Driver. </p>
<hr/>
<p>To use the UART driver, ensure that the correct driver library for your device is linked in and include this header file as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_u_a_r_t_8h.html">ti/drivers/UART.h</a>&gt;</span></div></div><!-- fragment --><p>This module serves as the main interface for applications. Its purpose is to redirect the UART APIs to specific driver implementations which are specified using a pointer to a <a class="el" href="struct_u_a_r_t___fxn_table.html" title="The definition of a UART function table that contains the required set of functions to control a spec...">UART_FxnTable</a>.</p>
<p><a class="anchor" id="ti_drivers_UART_Overview"></a></p><h1>Overview</h1>
<p>A UART is used to translate data between the chip and a serial port. The UART driver simplifies reading and writing to any of the UART peripherals on the board, with multiple modes of operation and performance. These include blocking, non-blocking, and polling, as well as text/binary mode, echo and return characters.</p>
<p>The UART driver interface provides device independent APIs, data types, and macros. The APIs in this driver serve as an interface to a typical RTOS application. The specific peripheral implementations are responsible for creating all the RTOS specific primitives to allow for thread-safe operation.</p>
<hr/>
<p> <a class="anchor" id="ti_drivers_UART_Usage"></a></p><h1>Usage</h1>
<p>This documentation provides a basic <a class="el" href="_u_a_r_t_8h.html#ti_drivers_UART_Synopsis">usage summary</a> and a set of <a class="el" href="_u_a_r_t_8h.html#ti_drivers_UART_Examples">examples</a> in the form of commented code fragments. Detailed descriptions of the APIs are provided in subsequent sections.</p>
<p><a class="anchor" id="ti_drivers_UART_Synopsis"></a></p><h2>Synopsis</h2>
<p><a class="anchor" id="ti_drivers_UART_Synopsis_Code"></a></p><div class="fragment"><div class="line"><span class="comment">// Import the UART driver definitions</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_u_a_r_t_8h.html">ti/drivers/UART.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// One-time initialization of UART driver</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1">UART_init</a>();</div><div class="line"></div><div class="line"><span class="comment">// Initialize UART parameters</span></div><div class="line"><a class="code" href="struct_u_a_r_t___params.html">UART_Params</a> params;</div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#afadb98d0a0ef6e17240bab79306e7828">baudRate</a> = 9600;</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#ab8677572499b3734fcaa00f6431b0e7b">readMode</a> = <a class="code" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>;</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#a53a95d4c2266d6e7ecea6640baf92d40">writeMode</a> = <a class="code" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>;</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#a1a88437b402afc20922a7f90b9449619">readTimeout</a> = <a class="code" href="_u_a_r_t_8h.html#ada620b673241eb6335a71e75da291716">UART_WAIT_FOREVER</a>;</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#a4849aaa2dfa2a010f2361e14b77841d7">writeTimeout</a> = <a class="code" href="_u_a_r_t_8h.html#ada620b673241eb6335a71e75da291716">UART_WAIT_FOREVER</a>;</div><div class="line"></div><div class="line"><span class="comment">// Open the UART</span></div><div class="line"><a class="code" href="struct_u_a_r_t___config__.html">UART_Handle</a> uart;</div><div class="line">uart = <a class="code" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030">UART_open</a>(CONFIG_UART0, &amp;params);</div><div class="line"></div><div class="line"><span class="comment">// Read from the UART</span></div><div class="line">int32_t readCount;</div><div class="line">uint8_t buffer[BUFSIZE];</div><div class="line">readCount = <a class="code" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135">UART_read</a>(uart, buffer, BUFSIZE);</div><div class="line"></div><div class="line"><span class="comment">// Write to the UART</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f">UART_write</a>(uart, buffer, BUFSIZE);</div><div class="line"></div><div class="line"><span class="comment">// Close the UART</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d">UART_close</a>(uart);</div></div><!-- fragment --><hr/>
<p> <a class="anchor" id="ti_drivers_UART_Examples"></a></p><h1>Examples</h1>
<p>The following code example opens a UART instance, reads a byte from the UART, and then writes the byte back to the UART.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>        input;</div><div class="line"><a class="code" href="struct_u_a_r_t___config__.html">UART_Handle</a> uart;</div><div class="line"><a class="code" href="struct_u_a_r_t___params.html">UART_Params</a> uartParams;</div><div class="line"></div><div class="line"><span class="comment">// Initialize the UART driver.  UART_init() must be called before</span></div><div class="line"><span class="comment">// calling any other UART APIs.</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1">UART_init</a>();</div><div class="line"></div><div class="line"><span class="comment">// Create a UART with data processing off.</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a>(&amp;uartParams);</div><div class="line">uartParams.<a class="code" href="struct_u_a_r_t___params.html#a02e8b9127a7d6fa49021f01a7ee69ad2">writeDataMode</a> = <a class="code" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div><div class="line">uartParams.<a class="code" href="struct_u_a_r_t___params.html#a707659dcecb10f490000511ec2de2060">readDataMode</a> = <a class="code" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div><div class="line">uartParams.<a class="code" href="struct_u_a_r_t___params.html#a47382bd027b944868ce873ad71d29d0e">readReturnMode</a> = <a class="code" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a>;</div><div class="line">uartParams.<a class="code" href="struct_u_a_r_t___params.html#a61642ef82bbcfc98494739a98afff58a">readEcho</a> = <a class="code" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a>;</div><div class="line">uartParams.<a class="code" href="struct_u_a_r_t___params.html#afadb98d0a0ef6e17240bab79306e7828">baudRate</a> = 115200;</div><div class="line"></div><div class="line"><span class="comment">// Open an instance of the UART drivers</span></div><div class="line">uart = <a class="code" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030">UART_open</a>(CONFIG_UART0, &amp;uartParams);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (uart == NULL) {</div><div class="line">    <span class="comment">// UART_open() failed</span></div><div class="line">    <span class="keywordflow">while</span> (1);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Loop forever echoing</span></div><div class="line"><span class="keywordflow">while</span> (1) {</div><div class="line">    <a class="code" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135">UART_read</a>(uart, &amp;input, 1);</div><div class="line">    <a class="code" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f">UART_write</a>(uart, &amp;input, 1);</div><div class="line">}</div></div><!-- fragment --><p>Details for the example code above are described in the following subsections.</p>
<h3>Opening the UART Driver</h3>
<p>Opening a UART requires four steps:</p><ol type="1">
<li>Create and initialize a <a class="el" href="struct_u_a_r_t___params.html" title="UART Parameters. ">UART_Params</a> structure.</li>
<li>Fill in the desired parameters.</li>
<li>Call <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>, passing the index of the UART in the UART_config structure, and the address of the <a class="el" href="struct_u_a_r_t___params.html" title="UART Parameters. ">UART_Params</a> structure. The UART instance is specified by the index in the UART_config structure.</li>
<li>Check that the UART handle returned by <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> is non-NULL, and save it. The handle will be used to read and write to the UART you just opened.</li>
</ol>
<p>Only one UART index can be used at a time; calling <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> a second time with the same index previosly passed to <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> will result in an error. You can, though, re-use the index if the instance is closed via <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a>. In the example code, CONFIG_UART0 is passed to <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. This macro is defined in the example's ti_drivers_config.h file.</p>
<h3>Modes of Operation</h3>
<p>The UART driver can operate in blocking mode or callback mode, by setting the writeMode and readMode parameters passed to <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. If these parameters are not set, as in the example code, the UART driver defaults to blocking mode. Options for the writeMode and readMode parameters are <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a> and <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>:</p>
<ul>
<li><a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a> uses a semaphore to block while data is being sent. The context of calling <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> or <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> must be a Task when using <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>. The <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> or <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> call will block until all data is sent or received, or the write timeout or read timeout expires, whichever happens first.</li>
<li><a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> is non-blocking and <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> and <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> will return while data is being sent in the context of a hardware interrupt. When the read or write finishes, the UART driver will call the user's callback function. In some cases, the UART data transfer may have been canceled, or a newline may have been received, so the number of bytes sent/received are passed to the callback function. Your implementation of the callback function can use this information as needed. Since the user's callback may be called in the context of an ISR, the callback function must not make any RTOS blocking calls. The buffer passed to <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> is not copied. The buffer must remain coherent until all the characters have been sent (ie until the tx callback has been called with a byte count equal to that passed to <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a>).</li>
</ul>
<p>The example sets the writeDataMode and readDataMode parameters to <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>. Options for these parameters are <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a> and <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a>:</p>
<ul>
<li><a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>: The data is passed as is, without processing.</li>
<li><a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a>: Write actions add a carriage return before a newline character, and read actions replace a return with a newline. This effectively treats all device line endings as LF and all host PC line endings as CRLF.</li>
</ul>
<p>Other parameters set by the example are readReturnMode and readEcho. Options for the readReturnMode parameter are <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a> and <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76">UART_RETURN_NEWLINE</a>:</p>
<ul>
<li><a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a>: The read action unblocks or returns when the buffer is full.</li>
<li><a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76">UART_RETURN_NEWLINE</a>: The read action unblocks or returns when a newline character is read, before the buffer is full.</li>
</ul>
<p>Options for the readEcho parameter are <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a> and <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a6c4d8a2d4e30c22cf9fa45cd1bf79306">UART_ECHO_ON</a>. This parameter determines whether the driver echoes data back to the UART. When echo is turned on, each character that is read by the target is written back, independent of any write operations. If data is received in the middle of a write and echo is turned on, the echoed characters will be mixed in with the write data.</p>
<h3>Reading and Writing data</h3>
<p>The example code reads one byte frome the UART instance, and then writes one byte back to the same instance:</p>
<div class="fragment"><div class="line"><a class="code" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135">UART_read</a>(uart, &amp;input, 1);</div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f">UART_write</a>(uart, &amp;input, 1);</div></div><!-- fragment --><p>The UART driver allows full duplex data transfers. Therefore, it is possible to call <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> and <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> at the same time (for either blocking or callback modes). It is not possible, however, to issue multiple concurrent operations in the same direction. For example, if one thread calls UART_read(uart0, buffer0...), any other thread attempting UART_read(uart0, buffer1...) will result in an error of UART_STATUS_ERROR, until all the data from the first <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> has been transferred to buffer0. This applies to both blocking and and callback modes. So applications must either synchronize <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> (or <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a>) calls that use the same UART handle, or check for the UART_STATUS_ERROR return code indicating that a transfer is still ongoing.</p>
<hr/>
<p> <a class="anchor" id="ti_drivers_UART_Configuration"></a></p><h1>Configuration</h1>
<p>Refer to the <a class="el" href="index.html#driver_configuration">Driver's Configuration</a> section for driver configuration information. </p><hr/>
 <hr/>
</div><div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for UART.h:</div>
<div class="dyncontent">
<div class="center"><img src="_u_a_r_t_8h__incl.png" border="0" usemap="#_u_a_r_t_8h" alt=""/></div>
<map name="_u_a_r_t_8h" id="_u_a_r_t_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_u_a_r_t_8h__dep__incl.png" border="0" usemap="#_u_a_r_t_8hdep" alt=""/></div>
<map name="_u_a_r_t_8hdep" id="_u_a_r_t_8hdep">
<area shape="rect" id="node2" href="_u_a_r_t_m_s_p432_8h.html" title="UART driver implementation for a EUSCIA peripheral for MSP432. " alt="" coords="5,80,125,107"/>
<area shape="rect" id="node3" href="_display_uart_8h.html" title="Display.h implementation for UART output. " alt="" coords="150,80,253,107"/>
</map>
</div>
</div>
<p><a href="_u_a_r_t_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Parameters.  <a href="struct_u_a_r_t___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___fxn_table.html">UART_FxnTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation.  <a href="struct_u_a_r_t___fxn_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="struct_u_a_r_t___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0f5a809e0884da33fef102236eb51644"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_o_n_t_r_o_l.html#ga0f5a809e0884da33fef102236eb51644">UART_CMD_RESERVED</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="separator:ga0f5a809e0884da33fef102236eb51644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f35027907fbab6a9ee302d2ee52a879"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_o_n_t_r_o_l.html#ga8f35027907fbab6a9ee302d2ee52a879">UART_STATUS_RESERVED</a>&#160;&#160;&#160;(-32)</td></tr>
<tr class="separator:ga8f35027907fbab6a9ee302d2ee52a879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga101b7761f89b3ec49f0c6726669acfed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed">UART_STATUS_SUCCESS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga101b7761f89b3ec49f0c6726669acfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code returned by <a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a>.  <a href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed">More...</a><br /></td></tr>
<tr class="separator:ga101b7761f89b3ec49f0c6726669acfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae076f4aae13ca8e2aea674207df0ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad">UART_STATUS_ERROR</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:ga2ae076f4aae13ca8e2aea674207df0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code returned by <a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a>.  <a href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad">More...</a><br /></td></tr>
<tr class="separator:ga2ae076f4aae13ca8e2aea674207df0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61125a2eb8059fd8b96ad95edc68ac2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga61125a2eb8059fd8b96ad95edc68ac2b">UART_STATUS_UNDEFINEDCMD</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:ga61125a2eb8059fd8b96ad95edc68ac2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned by <a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> for undefined command codes.  <a href="group___u_a_r_t___s_t_a_t_u_s.html#ga61125a2eb8059fd8b96ad95edc68ac2b">More...</a><br /></td></tr>
<tr class="separator:ga61125a2eb8059fd8b96ad95edc68ac2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942596a37cb2109ae021f88f3d907bdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#ga942596a37cb2109ae021f88f3d907bdc">UART_CMD_PEEK</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga942596a37cb2109ae021f88f3d907bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> to read the next unsigned char.  <a href="group___u_a_r_t___c_m_d.html#ga942596a37cb2109ae021f88f3d907bdc">More...</a><br /></td></tr>
<tr class="separator:ga942596a37cb2109ae021f88f3d907bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5be6db621c5b048637dc93b26797693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#gaf5be6db621c5b048637dc93b26797693">UART_CMD_ISAVAILABLE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gaf5be6db621c5b048637dc93b26797693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> to determine if the read buffer is empty.  <a href="group___u_a_r_t___c_m_d.html#gaf5be6db621c5b048637dc93b26797693">More...</a><br /></td></tr>
<tr class="separator:gaf5be6db621c5b048637dc93b26797693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470321cbd9eccf137ffbe6553ae7f35f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#ga470321cbd9eccf137ffbe6553ae7f35f">UART_CMD_GETRXCOUNT</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:ga470321cbd9eccf137ffbe6553ae7f35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> to determine how many unsigned chars are in the read buffer.  <a href="group___u_a_r_t___c_m_d.html#ga470321cbd9eccf137ffbe6553ae7f35f">More...</a><br /></td></tr>
<tr class="separator:ga470321cbd9eccf137ffbe6553ae7f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67d01fa376f25bb28141d819647e8d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#gad67d01fa376f25bb28141d819647e8d3">UART_CMD_RXENABLE</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:gad67d01fa376f25bb28141d819647e8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> to enable data receive by the UART.  <a href="group___u_a_r_t___c_m_d.html#gad67d01fa376f25bb28141d819647e8d3">More...</a><br /></td></tr>
<tr class="separator:gad67d01fa376f25bb28141d819647e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b19ce2fa9f43d3fe255bcdbd3cda7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#gac0b19ce2fa9f43d3fe255bcdbd3cda7b">UART_CMD_RXDISABLE</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:gac0b19ce2fa9f43d3fe255bcdbd3cda7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> to disable data received by the UART.  <a href="group___u_a_r_t___c_m_d.html#gac0b19ce2fa9f43d3fe255bcdbd3cda7b">More...</a><br /></td></tr>
<tr class="separator:gac0b19ce2fa9f43d3fe255bcdbd3cda7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3562e7931cf51b41a32d8109072251"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a7e3562e7931cf51b41a32d8109072251">UART_ERROR</a>&#160;&#160;&#160;(<a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad">UART_STATUS_ERROR</a>)</td></tr>
<tr class="separator:a7e3562e7931cf51b41a32d8109072251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada620b673241eb6335a71e75da291716"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ada620b673241eb6335a71e75da291716">UART_WAIT_FOREVER</a>&#160;&#160;&#160;(~(0U))</td></tr>
<tr class="memdesc:ada620b673241eb6335a71e75da291716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait forever define.  <a href="#ada620b673241eb6335a71e75da291716">More...</a><br /></td></tr>
<tr class="separator:ada620b673241eb6335a71e75da291716"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab69886c7119a5054a972d8c735f15928"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a></td></tr>
<tr class="memdesc:ab69886c7119a5054a972d8c735f15928"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> call.  <a href="#ab69886c7119a5054a972d8c735f15928">More...</a><br /></td></tr>
<tr class="separator:ab69886c7119a5054a972d8c735f15928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d43bd8997e9153ce790bc81467ec935"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a5d43bd8997e9153ce790bc81467ec935">UART_Callback</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t count)</td></tr>
<tr class="memdesc:a5d43bd8997e9153ce790bc81467ec935"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the UART driver when used in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> The callback can occur in task or HWI context.  <a href="#a5d43bd8997e9153ce790bc81467ec935">More...</a><br /></td></tr>
<tr class="separator:a5d43bd8997e9153ce790bc81467ec935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6">UART_CloseFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn(). ">UART_CloseFxn()</a>.  <a href="#ae08ff15291bd6b21cb4e2eb1fce164a6">More...</a><br /></td></tr>
<tr class="separator:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583c5e0b34e5806ec225f61d0daed0d6"><td class="memItemLeft" align="right" valign="top">typedef int_fast16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a583c5e0b34e5806ec225f61d0daed0d6">UART_ControlFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, uint_fast16_t cmd, void *arg)</td></tr>
<tr class="memdesc:a583c5e0b34e5806ec225f61d0daed0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a583c5e0b34e5806ec225f61d0daed0d6" title="A function pointer to a driver specific implementation of UART_ControlFxn(). ">UART_ControlFxn()</a>.  <a href="#a583c5e0b34e5806ec225f61d0daed0d6">More...</a><br /></td></tr>
<tr class="separator:a583c5e0b34e5806ec225f61d0daed0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e89df3065fffb47e7354067c14d1b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b">UART_InitFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a2b3e89df3065fffb47e7354067c14d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b" title="A function pointer to a driver specific implementation of UART_InitFxn(). ">UART_InitFxn()</a>.  <a href="#a2b3e89df3065fffb47e7354067c14d1b">More...</a><br /></td></tr>
<tr class="separator:a2b3e89df3065fffb47e7354067c14d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e21ac60f24eb9ce32286e21de713d1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1">UART_OpenFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:a39e21ac60f24eb9ce32286e21de713d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1" title="A function pointer to a driver specific implementation of UART_OpenFxn(). ">UART_OpenFxn()</a>.  <a href="#a39e21ac60f24eb9ce32286e21de713d1">More...</a><br /></td></tr>
<tr class="separator:a39e21ac60f24eb9ce32286e21de713d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d454c210267a4d04ecce802947633c"><td class="memItemLeft" align="right" valign="top">typedef int_fast32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ad1d454c210267a4d04ecce802947633c">UART_ReadFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:ad1d454c210267a4d04ecce802947633c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ad1d454c210267a4d04ecce802947633c" title="A function pointer to a driver specific implementation of UART_ReadFxn(). ">UART_ReadFxn()</a>.  <a href="#ad1d454c210267a4d04ecce802947633c">More...</a><br /></td></tr>
<tr class="separator:ad1d454c210267a4d04ecce802947633c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c6ef4189723f6ac960a82e6a232b35"><td class="memItemLeft" align="right" valign="top">typedef int_fast32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a96c6ef4189723f6ac960a82e6a232b35">UART_ReadPollingFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a96c6ef4189723f6ac960a82e6a232b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a96c6ef4189723f6ac960a82e6a232b35" title="A function pointer to a driver specific implementation of UART_ReadPollingFxn(). ">UART_ReadPollingFxn()</a>.  <a href="#a96c6ef4189723f6ac960a82e6a232b35">More...</a><br /></td></tr>
<tr class="separator:a96c6ef4189723f6ac960a82e6a232b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46296acc2c197a775d44458e1eca197"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197">UART_ReadCancelFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:aa46296acc2c197a775d44458e1eca197"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197" title="A function pointer to a driver specific implementation of UART_ReadCancelFxn(). ">UART_ReadCancelFxn()</a>.  <a href="#aa46296acc2c197a775d44458e1eca197">More...</a><br /></td></tr>
<tr class="separator:aa46296acc2c197a775d44458e1eca197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6b880dc397d9454038b383d6b821c8"><td class="memItemLeft" align="right" valign="top">typedef int_fast32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aad6b880dc397d9454038b383d6b821c8">UART_WriteFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:aad6b880dc397d9454038b383d6b821c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aad6b880dc397d9454038b383d6b821c8" title="A function pointer to a driver specific implementation of UART_WriteFxn(). ">UART_WriteFxn()</a>.  <a href="#aad6b880dc397d9454038b383d6b821c8">More...</a><br /></td></tr>
<tr class="separator:aad6b880dc397d9454038b383d6b821c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f14597bf561bf987ce6a48dac08076"><td class="memItemLeft" align="right" valign="top">typedef int_fast32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aa6f14597bf561bf987ce6a48dac08076">UART_WritePollingFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:aa6f14597bf561bf987ce6a48dac08076"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aa6f14597bf561bf987ce6a48dac08076" title="A function pointer to a driver specific implementation of UART_WritePollingFxn(). ...">UART_WritePollingFxn()</a>.  <a href="#aa6f14597bf561bf987ce6a48dac08076">More...</a><br /></td></tr>
<tr class="separator:aa6f14597bf561bf987ce6a48dac08076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3d974279a2d161746dfbc8ca91774"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774">UART_WriteCancelFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ac5a3d974279a2d161746dfbc8ca91774"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774" title="A function pointer to a driver specific implementation of UART_WriteCancelFxn(). ">UART_WriteCancelFxn()</a>.  <a href="#ac5a3d974279a2d161746dfbc8ca91774">More...</a><br /></td></tr>
<tr class="separator:ac5a3d974279a2d161746dfbc8ca91774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be81b9ce429a5e5c3ac02d285dbd3b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a68be81b9ce429a5e5c3ac02d285dbd3b">UART_Config</a></td></tr>
<tr class="memdesc:a68be81b9ce429a5e5c3ac02d285dbd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="#a68be81b9ce429a5e5c3ac02d285dbd3b">More...</a><br /></td></tr>
<tr class="separator:a68be81b9ce429a5e5c3ac02d285dbd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2507a620dba95cd20885c52494d19e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">UART_Mode</a> { <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, 
<a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>
 }<tr class="memdesc:a2507a620dba95cd20885c52494d19e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART mode settings.  <a href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2507a620dba95cd20885c52494d19e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5a82843435a1b5d51b6c27028d914f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a> { <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a>, 
<a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76">UART_RETURN_NEWLINE</a>
 }<tr class="memdesc:acb5a82843435a1b5d51b6c27028d914f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART return mode settings.  <a href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acb5a82843435a1b5d51b6c27028d914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694090fdb166f94ac30b809f9cba87b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a> { <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> = 1
 }<tr class="memdesc:a694090fdb166f94ac30b809f9cba87b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data mode settings.  <a href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a694090fdb166f94ac30b809f9cba87b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a> { <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a6c4d8a2d4e30c22cf9fa45cd1bf79306">UART_ECHO_ON</a> = 1
 }<tr class="memdesc:aac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART echo settings.  <a href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf245d5f10db0abcbd8ad62a0d80c694"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a> { <a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694a27d04dd1fa818f764eb9b8e849feb7ff">UART_LEN_5</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694a5bfd5507335d394d826e560930ce2a12">UART_LEN_6</a> = 1, 
<a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694a2ac8467047f55cc1954388bf94c72e35">UART_LEN_7</a> = 2, 
<a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694a31abbaaeaa38a5c66fbe13bfc8ece221">UART_LEN_8</a> = 3
 }<tr class="memdesc:adf245d5f10db0abcbd8ad62a0d80c694"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data length settings.  <a href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adf245d5f10db0abcbd8ad62a0d80c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176b71ca19bc13d7534fa30fc18c2243"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a> { <a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243a9bfa599e95c5da9cfe5f964dab8a9c6c">UART_STOP_ONE</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243a3f41137f3775e7d33fdb250471c0248e">UART_STOP_TWO</a> = 1
 }<tr class="memdesc:a176b71ca19bc13d7534fa30fc18c2243"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit settings.  <a href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a176b71ca19bc13d7534fa30fc18c2243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70b5aa75500b8c45a51ec560deccfc4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a> { <br />
&#160;&#160;<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4a469955a283c95f261990ad07043d5d2d">UART_PAR_NONE</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4a5405c8d842bffa2f76999eef9cee32c3">UART_PAR_EVEN</a> = 1, 
<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4a498f72ae68542763da3072d3e3af6603">UART_PAR_ODD</a> = 2, 
<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4adfb9d17fa33753ea5550e757b323bd46">UART_PAR_ZERO</a> = 3, 
<br />
&#160;&#160;<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4a7ab50a9a14f4c614e875fbab74911afa">UART_PAR_ONE</a> = 4
<br />
 }<tr class="memdesc:ac70b5aa75500b8c45a51ec560deccfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity type settings.  <a href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac70b5aa75500b8c45a51ec560deccfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b49b65f3db709c408dc4db23a68895d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d">UART_close</a> (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a6b49b65f3db709c408dc4db23a68895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a UART peripheral specified by the UART handle.  <a href="#a6b49b65f3db709c408dc4db23a68895d">More...</a><br /></td></tr>
<tr class="separator:a6b49b65f3db709c408dc4db23a68895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce79dc51ddc3ef73e8f08983bfee2c7"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7">UART_control</a> (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, uint_fast16_t cmd, void *arg)</td></tr>
<tr class="memdesc:a5ce79dc51ddc3ef73e8f08983bfee2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a>.  <a href="#a5ce79dc51ddc3ef73e8f08983bfee2c7">More...</a><br /></td></tr>
<tr class="separator:a5ce79dc51ddc3ef73e8f08983bfee2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60a36f7295d704926120d22f806dcd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1">UART_init</a> (void)</td></tr>
<tr class="memdesc:ab60a36f7295d704926120d22f806dcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the UART module.  <a href="#ab60a36f7295d704926120d22f806dcd1">More...</a><br /></td></tr>
<tr class="separator:ab60a36f7295d704926120d22f806dcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d1d6b7b1f9922484f9b8a0f78ed030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030">UART_open</a> (uint_least8_t index, <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:ab6d1d6b7b1f9922484f9b8a0f78ed030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given UART peripheral.  <a href="#ab6d1d6b7b1f9922484f9b8a0f78ed030">More...</a><br /></td></tr>
<tr class="separator:ab6d1d6b7b1f9922484f9b8a0f78ed030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a> (<a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:a40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="struct_u_a_r_t___params.html" title="UART Parameters. ">UART_Params</a> struct to its defaults.  <a href="#a40e5c0823bb7ffd2e8fbf19f9f20b399">More...</a><br /></td></tr>
<tr class="separator:a40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1036c2d5258ff70e9afe6cbfc326544f"><td class="memItemLeft" align="right" valign="top">int_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f">UART_write</a> (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:a1036c2d5258ff70e9afe6cbfc326544f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART with interrupts enabled.  <a href="#a1036c2d5258ff70e9afe6cbfc326544f">More...</a><br /></td></tr>
<tr class="separator:a1036c2d5258ff70e9afe6cbfc326544f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cda326eb3c05ee05950680bee42e5a"><td class="memItemLeft" align="right" valign="top">int_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ad8cda326eb3c05ee05950680bee42e5a">UART_writePolling</a> (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:ad8cda326eb3c05ee05950680bee42e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART, polling the peripheral to wait until new data can be written. Usage of this API is mutually exclusive with usage of <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a>.  <a href="#ad8cda326eb3c05ee05950680bee42e5a">More...</a><br /></td></tr>
<tr class="separator:ad8cda326eb3c05ee05950680bee42e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0482cd0ab9ee7e802c8e785a5754d16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d">UART_writeCancel</a> (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a0482cd0ab9ee7e802c8e785a5754d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> function call.  <a href="#a0482cd0ab9ee7e802c8e785a5754d16d">More...</a><br /></td></tr>
<tr class="separator:a0482cd0ab9ee7e802c8e785a5754d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d77f489566ff9f7c9c28d25e9a0135"><td class="memItemLeft" align="right" valign="top">int_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135">UART_read</a> (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a15d77f489566ff9f7c9c28d25e9a0135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART with interrupt enabled.  <a href="#a15d77f489566ff9f7c9c28d25e9a0135">More...</a><br /></td></tr>
<tr class="separator:a15d77f489566ff9f7c9c28d25e9a0135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac6ed8cfd03b84198ba6adcd8c248e6"><td class="memItemLeft" align="right" valign="top">int_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a3ac6ed8cfd03b84198ba6adcd8c248e6">UART_readPolling</a> (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a3ac6ed8cfd03b84198ba6adcd8c248e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART without interrupts. This API must be used mutually exclusive with <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a>.  <a href="#a3ac6ed8cfd03b84198ba6adcd8c248e6">More...</a><br /></td></tr>
<tr class="separator:a3ac6ed8cfd03b84198ba6adcd8c248e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c">UART_readCancel</a> (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> function call.  <a href="#a51ed7e94d5b409ca1fcb2d65c5a25c3c">More...</a><br /></td></tr>
<tr class="separator:a51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7e3562e7931cf51b41a32d8109072251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3562e7931cf51b41a32d8109072251">&sect;&nbsp;</a></span>UART_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_ERROR&#160;&#160;&#160;(<a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad">UART_STATUS_ERROR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada620b673241eb6335a71e75da291716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada620b673241eb6335a71e75da291716">&sect;&nbsp;</a></span>UART_WAIT_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_WAIT_FOREVER&#160;&#160;&#160;(~(0U))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait forever define. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab69886c7119a5054a972d8c735f15928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69886c7119a5054a972d8c735f15928">&sect;&nbsp;</a></span>UART_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a>* <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from a <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> call. </p>

</div>
</div>
<a id="a5d43bd8997e9153ce790bc81467ec935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d43bd8997e9153ce790bc81467ec935">&sect;&nbsp;</a></span>UART_Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_Callback) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the UART driver when used in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> The callback can occur in task or HWI context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UART_Handle</td><td>UART_Handle</td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to read/write buffer</td></tr>
    <tr><td class="paramname">count</td><td>Number of elements read/written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae08ff15291bd6b21cb4e2eb1fce164a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08ff15291bd6b21cb4e2eb1fce164a6">&sect;&nbsp;</a></span>UART_CloseFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_CloseFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn(). ">UART_CloseFxn()</a>. </p>

</div>
</div>
<a id="a583c5e0b34e5806ec225f61d0daed0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583c5e0b34e5806ec225f61d0daed0d6">&sect;&nbsp;</a></span>UART_ControlFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast16_t(* UART_ControlFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, uint_fast16_t cmd, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a583c5e0b34e5806ec225f61d0daed0d6" title="A function pointer to a driver specific implementation of UART_ControlFxn(). ">UART_ControlFxn()</a>. </p>

</div>
</div>
<a id="a2b3e89df3065fffb47e7354067c14d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3e89df3065fffb47e7354067c14d1b">&sect;&nbsp;</a></span>UART_InitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_InitFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b" title="A function pointer to a driver specific implementation of UART_InitFxn(). ">UART_InitFxn()</a>. </p>

</div>
</div>
<a id="a39e21ac60f24eb9ce32286e21de713d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e21ac60f24eb9ce32286e21de713d1">&sect;&nbsp;</a></span>UART_OpenFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>(* UART_OpenFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1" title="A function pointer to a driver specific implementation of UART_OpenFxn(). ">UART_OpenFxn()</a>. </p>

</div>
</div>
<a id="ad1d454c210267a4d04ecce802947633c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d454c210267a4d04ecce802947633c">&sect;&nbsp;</a></span>UART_ReadFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast32_t(* UART_ReadFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ad1d454c210267a4d04ecce802947633c" title="A function pointer to a driver specific implementation of UART_ReadFxn(). ">UART_ReadFxn()</a>. </p>

</div>
</div>
<a id="a96c6ef4189723f6ac960a82e6a232b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6ef4189723f6ac960a82e6a232b35">&sect;&nbsp;</a></span>UART_ReadPollingFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast32_t(* UART_ReadPollingFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a96c6ef4189723f6ac960a82e6a232b35" title="A function pointer to a driver specific implementation of UART_ReadPollingFxn(). ">UART_ReadPollingFxn()</a>. </p>

</div>
</div>
<a id="aa46296acc2c197a775d44458e1eca197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46296acc2c197a775d44458e1eca197">&sect;&nbsp;</a></span>UART_ReadCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_ReadCancelFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197" title="A function pointer to a driver specific implementation of UART_ReadCancelFxn(). ">UART_ReadCancelFxn()</a>. </p>

</div>
</div>
<a id="aad6b880dc397d9454038b383d6b821c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6b880dc397d9454038b383d6b821c8">&sect;&nbsp;</a></span>UART_WriteFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast32_t(* UART_WriteFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aad6b880dc397d9454038b383d6b821c8" title="A function pointer to a driver specific implementation of UART_WriteFxn(). ">UART_WriteFxn()</a>. </p>

</div>
</div>
<a id="aa6f14597bf561bf987ce6a48dac08076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f14597bf561bf987ce6a48dac08076">&sect;&nbsp;</a></span>UART_WritePollingFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast32_t(* UART_WritePollingFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aa6f14597bf561bf987ce6a48dac08076" title="A function pointer to a driver specific implementation of UART_WritePollingFxn(). ...">UART_WritePollingFxn()</a>. </p>

</div>
</div>
<a id="ac5a3d974279a2d161746dfbc8ca91774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a3d974279a2d161746dfbc8ca91774">&sect;&nbsp;</a></span>UART_WriteCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_WriteCancelFxn) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774" title="A function pointer to a driver specific implementation of UART_WriteCancelFxn(). ">UART_WriteCancelFxn()</a>. </p>

</div>
</div>
<a id="a68be81b9ce429a5e5c3ac02d285dbd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68be81b9ce429a5e5c3ac02d285dbd3b">&sect;&nbsp;</a></span>UART_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a>  <a class="el" href="_u_a_r_t_8h.html#a68be81b9ce429a5e5c3ac02d285dbd3b">UART_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Global configuration. </p>
<p>The UART_Config structure contains a set of pointers used to characterize the UART driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module. ">UART_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module. ">UART_init()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2507a620dba95cd20885c52494d19e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2507a620dba95cd20885c52494d19e90">&sect;&nbsp;</a></span>UART_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">UART_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART mode settings. </p>
<p>This enum defines the read and write modes for the configured UART. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf"></a>UART_MODE_BLOCKING&#160;</td><td class="fielddoc"><p>Uses a semaphore to block while data is being sent. Context of the call must be a Task. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754"></a>UART_MODE_CALLBACK&#160;</td><td class="fielddoc"><p>Non-blocking and will return immediately. When <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> or <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> has finished, the callback function is called from either the caller's context or from an interrupt context. </p>
</td></tr>
</table>

</div>
</div>
<a id="acb5a82843435a1b5d51b6c27028d914f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5a82843435a1b5d51b6c27028d914f">&sect;&nbsp;</a></span>UART_ReturnMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> and <a class="el" href="_u_a_r_t_8h.html#a3ac6ed8cfd03b84198ba6adcd8c248e6" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a>. This mode only functions when in <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> mode.</p>
<p><a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a> unblocks or performs a callback when the read buffer has been filled. <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76">UART_RETURN_NEWLINE</a> unblocks or performs a callback whenever a newline character has been received.</p>
<table class="doxtable">
<tr>
<th>UART operation </th><th>UART_RETURN_FULL </th><th>UART_RETURN_NEWLINE  </th></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> </td><td>Returns when buffer is full </td><td>Returns when buffer is full or newline was read </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> </td><td>Sends data as is </td><td>Sends data with an additional newline at the end </td></tr>
</table>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> mode. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5"></a>UART_RETURN_FULL&#160;</td><td class="fielddoc"><p>Unblock/callback when buffer is full. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76"></a>UART_RETURN_NEWLINE&#160;</td><td class="fielddoc"><p>Unblock/callback when newline character is received. </p>
</td></tr>
</table>

</div>
</div>
<a id="a694090fdb166f94ac30b809f9cba87b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694090fdb166f94ac30b809f9cba87b8">&sect;&nbsp;</a></span>UART_DataMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data mode settings. </p>
<p>This enumeration defines the data mode for reads and writes.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>, data is passed as is, with no processing.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> mode, the driver will examine the <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f" title="UART return mode settings. ">UART_ReturnMode</a> value, to determine whether or not to unblock/callback when a newline is received. Read actions replace a carriage return with a newline, and write actions add a carriage return before a newline. This effectively treats all device line endings as LF, and all host PC line endings as CRLF. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8"></a>UART_DATA_BINARY&#160;</td><td class="fielddoc"><p>Data is not processed </p>
</td></tr>
<tr><td class="fieldname"><a id="a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e"></a>UART_DATA_TEXT&#160;</td><td class="fielddoc"><p>Data is processed according to above </p>
</td></tr>
</table>

</div>
</div>
<a id="aac6a03c2e1d76f53e1d9d923dcdc24f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6a03c2e1d76f53e1d9d923dcdc24f2">&sect;&nbsp;</a></span>UART_Echo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART echo settings. </p>
<p>This enumeration defines if the driver will echo data when uses in <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> mode. This only applies to data received by the UART.</p>
<p><a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a6c4d8a2d4e30c22cf9fa45cd1bf79306">UART_ECHO_ON</a> will echo back characters it received while in <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> mode. <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a> will not echo back characters it received in <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> mode.</p>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> mode. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd"></a>UART_ECHO_OFF&#160;</td><td class="fielddoc"><p>Data is not echoed </p>
</td></tr>
<tr><td class="fieldname"><a id="aac6a03c2e1d76f53e1d9d923dcdc24f2a6c4d8a2d4e30c22cf9fa45cd1bf79306"></a>UART_ECHO_ON&#160;</td><td class="fielddoc"><p>Data is echoed </p>
</td></tr>
</table>

</div>
</div>
<a id="adf245d5f10db0abcbd8ad62a0d80c694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf245d5f10db0abcbd8ad62a0d80c694">&sect;&nbsp;</a></span>UART_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adf245d5f10db0abcbd8ad62a0d80c694a27d04dd1fa818f764eb9b8e849feb7ff"></a>UART_LEN_5&#160;</td><td class="fielddoc"><p>Data length is 5 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="adf245d5f10db0abcbd8ad62a0d80c694a5bfd5507335d394d826e560930ce2a12"></a>UART_LEN_6&#160;</td><td class="fielddoc"><p>Data length is 6 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="adf245d5f10db0abcbd8ad62a0d80c694a2ac8467047f55cc1954388bf94c72e35"></a>UART_LEN_7&#160;</td><td class="fielddoc"><p>Data length is 7 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="adf245d5f10db0abcbd8ad62a0d80c694a31abbaaeaa38a5c66fbe13bfc8ece221"></a>UART_LEN_8&#160;</td><td class="fielddoc"><p>Data length is 8 bits </p>
</td></tr>
</table>

</div>
</div>
<a id="a176b71ca19bc13d7534fa30fc18c2243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176b71ca19bc13d7534fa30fc18c2243">&sect;&nbsp;</a></span>UART_STOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a176b71ca19bc13d7534fa30fc18c2243a9bfa599e95c5da9cfe5f964dab8a9c6c"></a>UART_STOP_ONE&#160;</td><td class="fielddoc"><p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="a176b71ca19bc13d7534fa30fc18c2243a3f41137f3775e7d33fdb250471c0248e"></a>UART_STOP_TWO&#160;</td><td class="fielddoc"><p>Two stop bits </p>
</td></tr>
</table>

</div>
</div>
<a id="ac70b5aa75500b8c45a51ec560deccfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70b5aa75500b8c45a51ec560deccfc4">&sect;&nbsp;</a></span>UART_PAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4a469955a283c95f261990ad07043d5d2d"></a>UART_PAR_NONE&#160;</td><td class="fielddoc"><p>No parity </p>
</td></tr>
<tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4a5405c8d842bffa2f76999eef9cee32c3"></a>UART_PAR_EVEN&#160;</td><td class="fielddoc"><p>Parity bit is even </p>
</td></tr>
<tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4a498f72ae68542763da3072d3e3af6603"></a>UART_PAR_ODD&#160;</td><td class="fielddoc"><p>Parity bit is odd </p>
</td></tr>
<tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4adfb9d17fa33753ea5550e757b323bd46"></a>UART_PAR_ZERO&#160;</td><td class="fielddoc"><p>Parity bit is always zero </p>
</td></tr>
<tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4a7ab50a9a14f4c614e875fbab74911afa"></a>UART_PAR_ONE&#160;</td><td class="fielddoc"><p>Parity bit is always one </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6b49b65f3db709c408dc4db23a68895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b49b65f3db709c408dc4db23a68895d">&sect;&nbsp;</a></span>UART_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a UART peripheral specified by the UART handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> has been called. </dd>
<dd>
Ongoing asynchronous read or write have been canceled using <a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> or <a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a> respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned from <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> </dd></dl>

</div>
</div>
<a id="a5ce79dc51ddc3ef73e8f08983bfee2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce79dc51ddc3ef73e8f08983bfee2c7">&sect;&nbsp;</a></span>UART_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a given <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a>. </p>
<p>Commands for UART_control() can originate from <a class="el" href="_u_a_r_t_8h.html" title="Universal Asynchronous Receiver-Transmitter (UART) Driver. ">UART.h</a> or from implementation specific UART*.h (<em>UARTCC26XX.h</em>, <em><a class="el" href="_u_a_r_t_m_s_p432_8h.html" title="UART driver implementation for a EUSCIA peripheral for MSP432. ">UARTMSP432.h</a></em>, etc.. ) files. While commands from <a class="el" href="_u_a_r_t_8h.html" title="Universal Asynchronous Receiver-Transmitter (UART) Driver. ">UART.h</a> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific UART*.h files add unique driver capabilities but are not API portable across all UART driver implementations.</p>
<p>Commands supported by <a class="el" href="_u_a_r_t_8h.html" title="Universal Asynchronous Receiver-Transmitter (UART) Driver. ">UART.h</a> follow a UART_CMD_&lt;cmd&gt; naming convention.<br />
 Commands supported by UART*.h follow a UART*_CMD_&lt;cmd&gt; naming convention.<br />
 Each control command defines <b>arg</b> differently. The types of <b>arg</b> are documented with each command.</p>
<p>See <a class="el" href="group___u_a_r_t___c_m_d.html">UART_control command codes</a> for command codes.</p>
<p>See <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html">UART_control return status codes</a> for status codes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> has to be called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART handle returned from <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td><a class="el" href="_u_a_r_t_8h.html" title="Universal Asynchronous Receiver-Transmitter (UART) Driver. ">UART.h</a> or UART*.h commands.</td></tr>
    <tr><td class="paramname">arg</td><td>An optional R/W (read/write) command argument accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> </dd></dl>

</div>
</div>
<a id="ab60a36f7295d704926120d22f806dcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60a36f7295d704926120d22f806dcd1">&sect;&nbsp;</a></span>UART_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the UART module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The UART_config structure must exist and be persistent before this function can be called. This function must also be called before any other UART driver APIs. </dd></dl>

</div>
</div>
<a id="ab6d1d6b7b1f9922484f9b8a0f78ed030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d1d6b7b1f9922484f9b8a0f78ed030">&sect;&nbsp;</a></span>UART_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> UART_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize a given UART peripheral. </p>
<p>Function to initialize a given UART peripheral specified by the particular index value.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module. ">UART_init()</a> has been called</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Logical peripheral number for the UART indexed into the UART_config table</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to a parameter block. If NULL, default parameter values will be used. All the fields in this structure are RO (read-only).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> upon success. NULL if an error occurs, or if the indexed UART peripheral is already opened.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module. ">UART_init()</a> </dd>
<dd>
<a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a> </dd></dl>

</div>
</div>
<a id="a40e5c0823bb7ffd2e8fbf19f9f20b399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e5c0823bb7ffd2e8fbf19f9f20b399">&sect;&nbsp;</a></span>UART_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="struct_u_a_r_t___params.html" title="UART Parameters. ">UART_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to <a class="el" href="struct_u_a_r_t___params.html" title="UART Parameters. ">UART_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: readMode = UART_MODE_BLOCKING; writeMode = UART_MODE_BLOCKING; readTimeout = UART_WAIT_FOREVER; writeTimeout = UART_WAIT_FOREVER; readCallback = NULL; writeCallback = NULL; readReturnMode = UART_RETURN_NEWLINE; readDataMode = UART_DATA_TEXT; writeDataMode = UART_DATA_TEXT; readEcho = UART_ECHO_ON; baudRate = 115200; dataLength = UART_LEN_8; stopBits = UART_STOP_ONE; parityType = UART_PAR_NONE; </p>

</div>
</div>
<a id="a1036c2d5258ff70e9afe6cbfc326544f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1036c2d5258ff70e9afe6cbfc326544f">&sect;&nbsp;</a></span>UART_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast32_t UART_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART with interrupts enabled. </p>
<p>UART_write() writes data from a memory buffer to the UART interface. The source is specified by <em>buffer</em> and the number of bytes to write is given by <em>size</em>.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> blocks task execution until all the data in buffer has been written.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>, UART_write() does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t___params.html#a0497d8a55aea66d3ab2118f8966e8e33">UART_Params::writeCallback</a> is called when the transfer is finished. The buffer passed to <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> is not copied. The buffer must remain coherent until all the characters have been sent (ie until the tx callback has been called with a byte count equal to that passed to <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a>). The callback function can occur in the caller's task context or in a HWI or SWI context, depending on the device implementation. An unfinished asynchronous write operation must always be canceled using <a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a> before calling <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a>.</p>
<p>UART_write() is mutually exclusive to <a class="el" href="_u_a_r_t_8h.html#ad8cda326eb3c05ee05950680bee42e5a" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written...">UART_writePolling()</a>. For an opened UART peripheral, either <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> or <a class="el" href="_u_a_r_t_8h.html#ad8cda326eb3c05ee05950680bee42e5a" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written...">UART_writePolling()</a> can be used, but not both.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call UART_write() from its own callback function when in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#ad8cda326eb3c05ee05950680bee42e5a" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written...">UART_writePolling()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A read-only pointer to buffer containing data to be written to the UART</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in the buffer that should be written to the UART</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the UART. If an error occurs, <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad" title="Generic error status code returned by UART_control(). ">UART_STATUS_ERROR</a> is returned. In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> mode, the return value is always 0. </dd></dl>

</div>
</div>
<a id="ad8cda326eb3c05ee05950680bee42e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cda326eb3c05ee05950680bee42e5a">&sect;&nbsp;</a></span>UART_writePolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast32_t UART_writePolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART, polling the peripheral to wait until new data can be written. Usage of this API is mutually exclusive with usage of <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a>. </p>
<p>This function initiates an operation to write data to a UART controller.</p>
<p><a class="el" href="_u_a_r_t_8h.html#ad8cda326eb3c05ee05950680bee42e5a" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written...">UART_writePolling()</a> will not return until all the data was written to the UART (or to its FIFO if applicable).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A read-only pointer to the buffer containing the data to be written to the UART</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in the buffer that should be written to the UART</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the UART. If an error occurs, <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad" title="Generic error status code returned by UART_control(). ">UART_STATUS_ERROR</a> is returned. </dd></dl>

</div>
</div>
<a id="a0482cd0ab9ee7e802c8e785a5754d16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0482cd0ab9ee7e802c8e785a5754d16d">&sect;&nbsp;</a></span>UART_writeCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_writeCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> function call. </p>
<p>This function cancels an asynchronous <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> operation and is only applicable in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>. <a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a> calls the registered TX callback function no matter how many bytes were sent. It is the application's responsibility to check the count argument in the callback function and handle cases where only a subset of the bytes were sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15d77f489566ff9f7c9c28d25e9a0135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d77f489566ff9f7c9c28d25e9a0135">&sect;&nbsp;</a></span>UART_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast32_t UART_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART with interrupt enabled. </p>
<p>UART_read() reads data from a UART controller. The destination is specified by <em>buffer</em> and the number of bytes to read is given by <em>size</em>.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, UART_read() blocks task execution until all the data in buffer has been read.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>, UART_read() does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t___params.html#a5457b86b6793f1c4757457b9b22e379d">UART_Params::readCallback</a> is called when the transfer is finished. The callback function can occur in the caller's context or in HWI or SWI context, depending on the device-specific implementation. An unfinished asynchronous read operation must always be canceled using <a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> before calling <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a>.</p>
<p>UART_read() is mutually exclusive to <a class="el" href="_u_a_r_t_8h.html#a3ac6ed8cfd03b84198ba6adcd8c248e6" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a>. For an opened UART peripheral, either UART_read() or <a class="el" href="_u_a_r_t_8h.html#a3ac6ed8cfd03b84198ba6adcd8c248e6" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a> can be used, but not both.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call UART_read() from its own callback function when in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#a3ac6ed8cfd03b84198ba6adcd8c248e6" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an empty buffer to which received data should be written</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written into buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the UART, <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad" title="Generic error status code returned by UART_control(). ">UART_STATUS_ERROR</a> on an error. </dd></dl>

</div>
</div>
<a id="a3ac6ed8cfd03b84198ba6adcd8c248e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac6ed8cfd03b84198ba6adcd8c248e6">&sect;&nbsp;</a></span>UART_readPolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast32_t UART_readPolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART without interrupts. This API must be used mutually exclusive with <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a>. </p>
<p>This function initiates an operation to read data from a UART peripheral.</p>
<p>UART_readPolling() will not return until size data was read to the UART.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an empty buffer in which received data should be written to</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written into buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the UART, <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad" title="Generic error status code returned by UART_control(). ">UART_STATUS_ERROR</a> on an error. </dd></dl>

</div>
</div>
<a id="a51ed7e94d5b409ca1fcb2d65c5a25c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ed7e94d5b409ca1fcb2d65c5a25c3c">&sect;&nbsp;</a></span>UART_readCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_readCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> function call. </p>
<p>This function cancels an asynchronous <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> operation and is only applicable in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>. <a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> calls the registered RX callback function no matter how many bytes were received. It is the application's responsibility to check the count argument in the callback function and handle cases where only a subset of the bytes were received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
