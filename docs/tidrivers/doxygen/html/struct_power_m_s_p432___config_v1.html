<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>PowerMSP432_ConfigV1 Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">PowerMSP432_ConfigV1 Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Power global configuration (MSP432-specific)  
 <a href="struct_power_m_s_p432___config_v1.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_power_m_s_p432_8h_source.html">PowerMSP432.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for PowerMSP432_ConfigV1:</div>
<div class="dyncontent">
<div class="center"><img src="struct_power_m_s_p432___config_v1__coll__graph.png" border="0" usemap="#_power_m_s_p432___config_v1_coll__map" alt="Collaboration graph"/></div>
<map name="_power_m_s_p432___config_v1_coll__map" id="_power_m_s_p432___config_v1_coll__map">
<area shape="rect" id="node2" href="struct_power_m_s_p432___perf_level.html" title="Structure defining a performance level. " alt="" coords="5,5,176,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a63f02b72038cd340fd3e3bd634c11035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_power_8h.html#a435fdeb71d13ea6be86f599c9b6a0d78">Power_PolicyInitFxn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a63f02b72038cd340fd3e3bd634c11035">policyInitFxn</a></td></tr>
<tr class="memdesc:a63f02b72038cd340fd3e3bd634c11035"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Power Policy's initialization function.  <a href="#a63f02b72038cd340fd3e3bd634c11035">More...</a><br /></td></tr>
<tr class="separator:a63f02b72038cd340fd3e3bd634c11035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2c8cb5a370da047f71df03b57675ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_power_8h.html#a333038d1e9cd5f93dda7b83f8a1afa8b">Power_PolicyFxn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a1e2c8cb5a370da047f71df03b57675ca">policyFxn</a></td></tr>
<tr class="memdesc:a1e2c8cb5a370da047f71df03b57675ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Power Policy function.  <a href="#a1e2c8cb5a370da047f71df03b57675ca">More...</a><br /></td></tr>
<tr class="separator:a1e2c8cb5a370da047f71df03b57675ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab800db7539de6ba4453f8446ae373a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#aaab800db7539de6ba4453f8446ae373a">initialPerfLevel</a></td></tr>
<tr class="memdesc:aaab800db7539de6ba4453f8446ae373a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial performance level to be established during Power Manager initialization.  <a href="#aaab800db7539de6ba4453f8446ae373a">More...</a><br /></td></tr>
<tr class="separator:aaab800db7539de6ba4453f8446ae373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43c45bb9070d3ca7278d5f9196820d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#aa43c45bb9070d3ca7278d5f9196820d0">enablePolicy</a></td></tr>
<tr class="memdesc:aa43c45bb9070d3ca7278d5f9196820d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if the Power Policy function is enabled.  <a href="#aa43c45bb9070d3ca7278d5f9196820d0">More...</a><br /></td></tr>
<tr class="separator:aa43c45bb9070d3ca7278d5f9196820d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b988b4449d135f852daafad190a746d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a7b988b4449d135f852daafad190a746d">enablePerf</a></td></tr>
<tr class="memdesc:a7b988b4449d135f852daafad190a746d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if performance scaling is enabled.  <a href="#a7b988b4449d135f852daafad190a746d">More...</a><br /></td></tr>
<tr class="separator:a7b988b4449d135f852daafad190a746d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8d9d7952363165a73b8679e56926f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#aae8d9d7952363165a73b8679e56926f5">enableParking</a></td></tr>
<tr class="memdesc:aae8d9d7952363165a73b8679e56926f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if pull resistors should be automatically applied to input pins during <a class="el" href="_power_m_s_p432_8h.html#a2a4fd7bba646587655e8de0fdfda82d9">PowerMSP432_DEEPSLEEP_0</a> and <a class="el" href="_power_m_s_p432_8h.html#a13c3fb19e15734f5da0cb39c1f11c59c">PowerMSP432_DEEPSLEEP_1</a>.  <a href="#aae8d9d7952363165a73b8679e56926f5">More...</a><br /></td></tr>
<tr class="separator:aae8d9d7952363165a73b8679e56926f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d02c6b0e9cf8d76f7b07cf6d72487e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#ad2d02c6b0e9cf8d76f7b07cf6d72487e">resumeShutdownHookFxn</a> )(void)</td></tr>
<tr class="memdesc:ad2d02c6b0e9cf8d76f7b07cf6d72487e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function called when resuming from a SHUTDOWN state.  <a href="#ad2d02c6b0e9cf8d76f7b07cf6d72487e">More...</a><br /></td></tr>
<tr class="separator:ad2d02c6b0e9cf8d76f7b07cf6d72487e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061adc62566f040e61f06b5e690a0f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_power_m_s_p432___perf_level.html">PowerMSP432_PerfLevel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a0061adc62566f040e61f06b5e690a0f1">customPerfLevels</a></td></tr>
<tr class="memdesc:a0061adc62566f040e61f06b5e690a0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an optional array of custom performance levels.  <a href="#a0061adc62566f040e61f06b5e690a0f1">More...</a><br /></td></tr>
<tr class="separator:a0061adc62566f040e61f06b5e690a0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cc1453617468264d219b323d6881d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a73cc1453617468264d219b323d6881d0">numCustom</a></td></tr>
<tr class="memdesc:a73cc1453617468264d219b323d6881d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of custom performance levels.  <a href="#a73cc1453617468264d219b323d6881d0">More...</a><br /></td></tr>
<tr class="separator:a73cc1453617468264d219b323d6881d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4ce1856651b1ff374990c7340e22a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#aaf4ce1856651b1ff374990c7340e22a3">useExtendedPerf</a></td></tr>
<tr class="memdesc:aaf4ce1856651b1ff374990c7340e22a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if extended performance scaling features are to be supported.  <a href="#aaf4ce1856651b1ff374990c7340e22a3">More...</a><br /></td></tr>
<tr class="separator:aaf4ce1856651b1ff374990c7340e22a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cb76813f92d7d01a201489c9622736"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a76cb76813f92d7d01a201489c9622736">HFXTFREQ</a></td></tr>
<tr class="memdesc:a76cb76813f92d7d01a201489c9622736"><td class="mdescLeft">&#160;</td><td class="mdescRight">The high frequency crystal (HFXT) frequency.  <a href="#a76cb76813f92d7d01a201489c9622736">More...</a><br /></td></tr>
<tr class="separator:a76cb76813f92d7d01a201489c9622736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f74c7e5824a2dae49038a0358d76d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#ab15f74c7e5824a2dae49038a0358d76d">LFXTDRIVE</a></td></tr>
<tr class="memdesc:ab15f74c7e5824a2dae49038a0358d76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The low frequency crystal (LFXT) drive level.  <a href="#ab15f74c7e5824a2dae49038a0358d76d">More...</a><br /></td></tr>
<tr class="separator:ab15f74c7e5824a2dae49038a0358d76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e499bec4c23efaf82038fd5e5b59db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#aa3e499bec4c23efaf82038fd5e5b59db">configurePinHFXT</a></td></tr>
<tr class="memdesc:aa3e499bec4c23efaf82038fd5e5b59db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if the HFXT pin should be configured for HFXT function.  <a href="#aa3e499bec4c23efaf82038fd5e5b59db">More...</a><br /></td></tr>
<tr class="separator:aa3e499bec4c23efaf82038fd5e5b59db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5818485fe078c4e6ab9e44bf825d67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a3c5818485fe078c4e6ab9e44bf825d67">bypassHFXT</a></td></tr>
<tr class="memdesc:a3c5818485fe078c4e6ab9e44bf825d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if the HFXT pin should be configured for HFXT bypass.  <a href="#a3c5818485fe078c4e6ab9e44bf825d67">More...</a><br /></td></tr>
<tr class="separator:a3c5818485fe078c4e6ab9e44bf825d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e39077e80ff90b3cfbb314dcea5149"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#af4e39077e80ff90b3cfbb314dcea5149">configurePinLFXT</a></td></tr>
<tr class="memdesc:af4e39077e80ff90b3cfbb314dcea5149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if the LFXT pin should be configured for LFXT function.  <a href="#af4e39077e80ff90b3cfbb314dcea5149">More...</a><br /></td></tr>
<tr class="separator:af4e39077e80ff90b3cfbb314dcea5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0365ac9ecab7c32b6aae9ccb9a6dac13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a0365ac9ecab7c32b6aae9ccb9a6dac13">bypassLFXT</a></td></tr>
<tr class="memdesc:a0365ac9ecab7c32b6aae9ccb9a6dac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if the LFXT pin should be configured for LFXT bypass.  <a href="#a0365ac9ecab7c32b6aae9ccb9a6dac13">More...</a><br /></td></tr>
<tr class="separator:a0365ac9ecab7c32b6aae9ccb9a6dac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6e54d58c9f297e9dcef1b666dd8df3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#aeb6e54d58c9f297e9dcef1b666dd8df3">enableInterruptsCS</a></td></tr>
<tr class="memdesc:aeb6e54d58c9f297e9dcef1b666dd8df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if interrupts from the Clock System (CS) should be enabled for catching clock and oscillator fault conditions.  <a href="#aeb6e54d58c9f297e9dcef1b666dd8df3">More...</a><br /></td></tr>
<tr class="separator:aeb6e54d58c9f297e9dcef1b666dd8df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9f17e1e6b344e08c057870cc363c42"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a0a9f17e1e6b344e08c057870cc363c42">priorityInterruptsCS</a></td></tr>
<tr class="memdesc:a0a9f17e1e6b344e08c057870cc363c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interrupt priority to be configured for CS interrupts.  <a href="#a0a9f17e1e6b344e08c057870cc363c42">More...</a><br /></td></tr>
<tr class="separator:a0a9f17e1e6b344e08c057870cc363c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e983faf2c1d8bd65bba5320c3a03019"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_m_s_p432___config_v1.html#a8e983faf2c1d8bd65bba5320c3a03019">isrCS</a> )(void)</td></tr>
<tr class="memdesc:a8e983faf2c1d8bd65bba5320c3a03019"><td class="mdescLeft">&#160;</td><td class="mdescRight">The application-provided interrupt service routine that should be configured for handling CS interrupts.  <a href="#a8e983faf2c1d8bd65bba5320c3a03019">More...</a><br /></td></tr>
<tr class="separator:a8e983faf2c1d8bd65bba5320c3a03019"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Power global configuration (MSP432-specific) </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a63f02b72038cd340fd3e3bd634c11035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f02b72038cd340fd3e3bd634c11035">&sect;&nbsp;</a></span>policyInitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_power_8h.html#a435fdeb71d13ea6be86f599c9b6a0d78">Power_PolicyInitFxn</a> PowerMSP432_ConfigV1::policyInitFxn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Power Policy's initialization function. </p>
<p>If the policy does not have an initialization function, 'NULL' should be specified. </p>

</div>
</div>
<a id="a1e2c8cb5a370da047f71df03b57675ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2c8cb5a370da047f71df03b57675ca">&sect;&nbsp;</a></span>policyFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_power_8h.html#a333038d1e9cd5f93dda7b83f8a1afa8b">Power_PolicyFxn</a> PowerMSP432_ConfigV1::policyFxn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Power Policy function. </p>
<p>When enabled, this function is invoked in the idle loop, to opportunistically select and activate sleep states.</p>
<p>Two reference policies are provided:</p>
<p><a class="el" href="_power_m_s_p432_8h.html#ab75793914213da623d441edab4ad4d7b" title="The SLEEP Power Policy. ">PowerMSP432_sleepPolicy()</a> - a simple policy that will put the device in either the PowerMSP432_SLEEP state (unless there is a constraint prohibiting this), or CPU wait for interrupt (WFI)</p>
<p><a class="el" href="_power_m_s_p432_8h.html#a2d7baf3841bd309a52acabd6b5dbc5ec" title="The DEEPSLEEP Power Policy. ">PowerMSP432_deepSleepPolicy()</a> - a more agressive policy that checks constraints and optionally chooses PowerMSP432_DEEPSLEEP_1, PowerMSP432_DEEPSLEEP_0, PowerMSP432_SLEEP, or WFI, in that order of preference.</p>
<p>Custom policies can be written, and specified via this function pointer.</p>
<p>In addition to this static selection, the Power Policy can be dynamically changed at runtime, via the <a class="el" href="_power_8h.html#aa4af0d238813058bf6146df6021df8cc" title="Set a new Power policy. ">Power_setPolicy()</a> API. </p>

</div>
</div>
<a id="aaab800db7539de6ba4453f8446ae373a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab800db7539de6ba4453f8446ae373a">&sect;&nbsp;</a></span>initialPerfLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int PowerMSP432_ConfigV1::initialPerfLevel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial performance level to be established during Power Manager initialization. </p>
<p>The performance level is identified by a numeric index into the table of available performance levels.</p>
<p>This performance level will be activated during initialization only when performance scaling is enabled (below, via specification of enablePerf). </p>

</div>
</div>
<a id="aa43c45bb9070d3ca7278d5f9196820d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43c45bb9070d3ca7278d5f9196820d0">&sect;&nbsp;</a></span>enablePolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::enablePolicy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if the Power Policy function is enabled. </p>
<p>If 'true', the policy function will be invoked once for each pass of the idle loop.</p>
<p>If 'false', the policy will not be invoked.</p>
<p>In addition to this static setting, the Power Policy can be dynamically enabled and disabled at runtime, via the <a class="el" href="_power_8h.html#ae8d6092a8fb35b6db52a69a35fcc327f" title="Enable the configured power policy to run when the CPU is idle. ">Power_enablePolicy()</a> and <a class="el" href="_power_8h.html#acf9706c39bd0fa07ec977dd643e5dd2a" title="Disable the configured power policy from running when the CPU is idle. ">Power_disablePolicy()</a> functions, respectively. </p>

</div>
</div>
<a id="a7b988b4449d135f852daafad190a746d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b988b4449d135f852daafad190a746d">&sect;&nbsp;</a></span>enablePerf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::enablePerf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if performance scaling is enabled. </p>
<p>If 'true', the performance scaling feature will be enabled for the application. And, the initial performance level (specified above, via initialPerfLevel) will be established during Power Manager initialization.</p>
<p>If 'false', performance scaling is disabled for the application. </p>

</div>
</div>
<a id="aae8d9d7952363165a73b8679e56926f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8d9d7952363165a73b8679e56926f5">&sect;&nbsp;</a></span>enableParking</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::enableParking</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if pull resistors should be automatically applied to input pins during <a class="el" href="_power_m_s_p432_8h.html#a2a4fd7bba646587655e8de0fdfda82d9">PowerMSP432_DEEPSLEEP_0</a> and <a class="el" href="_power_m_s_p432_8h.html#a13c3fb19e15734f5da0cb39c1f11c59c">PowerMSP432_DEEPSLEEP_1</a>. </p>
<p>Leaving an input pin floating during a device deepsleep state will result in an increase in power consumption. The Power Manager provides an option to automatically apply pull resistors to input pins during deepsleep, so that none are left floating. The type of pull (pull-up or pull-down) is determined by the current state sensed for each input pin, as the device is transitioning into deepsleep. This feature is referred to as 'automatic pin parking', and is enabled with this enableParking configuration parameter.</p>
<p>If 'true', before completing a transition into deepsleep, pull resistors will be applied to all pins configured as input, with General Purpose I/O (GPIO) function (as configured in the PxSEL1 and PxSEL0 registers). On wake from deepsleep, the pull resistor settings will be restored to those in effect prior to deepsleep.</p>
<p>If 'false', pull resistors will not be automatically applied during deepsleep states.</p>
<dl class="section note"><dt>Note</dt><dd>When auto pin parking is enabled special attention must be paid to the interrupt trigger selection for GPIO pins that are expected to wake the device from deepsleep. Specifically, the interrupt should be triggered on the leading edge of the signal transition.</dd></dl>
<p>As an example, consider a pin that is connected via a debounced button switch to ground. An internal pull-up resistor is used versus an external pull-up resistor. The <a class="el" href="_g_p_i_o_8h.html">GPIO.h</a> driver is used to manage this pin, with the following entry in the pin configuration array: </p><div class="fragment"><div class="line"><a class="code" href="group___g_p_i_o_m_s_p432___pin_config_ids.html#ga2e016b6a957dbe75189b88cf6b46dab7">GPIOMSP432_P1_1</a> | <a class="code" href="group___g_p_i_o___pin_config_settings.html#ga4fb7b60751481b6988049fe8fa94a7d7">GPIO_CFG_IN_PU</a> | <a class="code" href="group___g_p_i_o___pin_config_settings.html#ga7a69ee26049dc2f8b5059b00a24b9f74">GPIO_CFG_IN_INT_FALLING</a>,</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="group___g_p_i_o___pin_config_settings.html#ga7a69ee26049dc2f8b5059b00a24b9f74">GPIO_CFG_IN_INT_FALLING</a> is specifically selected so that the interrupt triggers immediately upon a button press.</dd></dl>
<p>If <a class="el" href="group___g_p_i_o___pin_config_settings.html#ga4a9f53e525d1f1659b485274d08ff91f">GPIO_CFG_IN_INT_RISING</a> were selected, in certain situations there may be a problem with this pin being able to trigger a wakeup from deepsleep. For example, consider the case where there is an additional mechanism to wake the device from deepsleep, for example, the watchdog timer is programmed in interval timer mode, to periodically wake the device every 250ms. If the button is not pressed, when the device goes to deepsleep the pin state is sensed as high, and a pull-up resistor is automatically applied by the Power driver. At some point the button is pressed, and the pin is pulled to ground. But since "RISING" edge was configured for the interrupt, the interrupt request has not yet been sent to the CPU. Now, while the button is still low, the interval timer wakes the device, the necessary work is done, the power policy runs in the idle loop again, and puts the device back to deepsleep. On this transition to deepsleep, the auto pin parking code runs again, but this time the button pin level is sensed as low (since the button is depressed); so this time, a pull-down resistor is applied to the pin. The device goes to deepsleep, and then eventually the button is released... but the pin is still held low by the internal pull-down resistor, so no rising edge occurs, no interrupt is signalled to the CPU, and the device stays in deesleep.</p>
<p>The above is a hypothetical example, but illustrates the importance of selecting the appropriate interrupt trigger configuration for GPIO pins when auto pin parking is enabled. If a pin is being driven by an external circuit (versus floating with weak pull resistors as in the above example), as long as the external circuit can sufficiently drive the pin to counteract the weak pull resistor, there won't be a similar issue. </p>

</div>
</div>
<a id="ad2d02c6b0e9cf8d76f7b07cf6d72487e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d02c6b0e9cf8d76f7b07cf6d72487e">&sect;&nbsp;</a></span>resumeShutdownHookFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* PowerMSP432_ConfigV1::resumeShutdownHookFxn) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hook function called when resuming from a SHUTDOWN state. </p>
<p>This function is called when the device wakes and resumes from a previous entry into either the SHUTDOWN_0 or SHUTDOWN_1 states. If this function is defined (i.e., this pointer is not NULL), it will be called during <a class="el" href="_power_8h.html#a3c4e1eab2809636848b2758fb201707c" title="Power initialization function. ">Power_init()</a>, right before the Power driver clears the LOCKLPM5 and LOCKBKUP bits in the PMCTL1 register, to unlock I/Os and the backup domain. </p>

</div>
</div>
<a id="a0061adc62566f040e61f06b5e690a0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0061adc62566f040e61f06b5e690a0f1">&sect;&nbsp;</a></span>customPerfLevels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_power_m_s_p432___perf_level.html">PowerMSP432_PerfLevel</a>* PowerMSP432_ConfigV1::customPerfLevels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to an optional array of custom performance levels. </p>
<p>A value of NULL indicates no custom performance levels are defined </p>

</div>
</div>
<a id="a73cc1453617468264d219b323d6881d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cc1453617468264d219b323d6881d0">&sect;&nbsp;</a></span>numCustom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PowerMSP432_ConfigV1::numCustom</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of custom performance levels. </p>

</div>
</div>
<a id="aaf4ce1856651b1ff374990c7340e22a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4ce1856651b1ff374990c7340e22a3">&sect;&nbsp;</a></span>useExtendedPerf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::useExtendedPerf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if extended performance scaling features are to be supported. </p>
<p>If 'true', the following configuration parameters for crystal oscillator support are enabled.</p>
<p>If 'false', the extended configuration parameters are not suppored.</p>
<p>This Boolean is used to maintain backwards compatibility with previous releases. Older board files won't include the extended configuration parameters, and by default, crystal oscillators won't be supported in those applications. New board files can include the extended configuration parameters, and by including and setting this Boolean to true, the extended support with crystals will be enabled. </p>

</div>
</div>
<a id="a76cb76813f92d7d01a201489c9622736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cb76813f92d7d01a201489c9622736">&sect;&nbsp;</a></span>HFXTFREQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int PowerMSP432_ConfigV1::HFXTFREQ</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The high frequency crystal (HFXT) frequency. </p>
<p>The source is specified via an enumerated value from cs.h, for example: CS_48MHZ, CS_24MHZ, etc. </p>

</div>
</div>
<a id="ab15f74c7e5824a2dae49038a0358d76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15f74c7e5824a2dae49038a0358d76d">&sect;&nbsp;</a></span>LFXTDRIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int PowerMSP432_ConfigV1::LFXTDRIVE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The low frequency crystal (LFXT) drive level. </p>
<p>The source is specified via an enumerated value from cs.h, for example: CS_LFXT_DRIVE3, CS_LFXT_DRIVE2, etc. </p>

</div>
</div>
<a id="aa3e499bec4c23efaf82038fd5e5b59db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e499bec4c23efaf82038fd5e5b59db">&sect;&nbsp;</a></span>configurePinHFXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::configurePinHFXT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if the HFXT pin should be configured for HFXT function. </p>
<p>If 'true', the HFXT pin will be configured for HFXT function.</p>
<p>If 'false', the pin will not be configured. </p>

</div>
</div>
<a id="a3c5818485fe078c4e6ab9e44bf825d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5818485fe078c4e6ab9e44bf825d67">&sect;&nbsp;</a></span>bypassHFXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::bypassHFXT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if the HFXT pin should be configured for HFXT bypass. </p>
<p>If 'true', the HFXT pin will be configured for HFXT bypass.</p>
<p>If 'false', the pin will not be configured for HFXT bypass. </p>

</div>
</div>
<a id="af4e39077e80ff90b3cfbb314dcea5149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e39077e80ff90b3cfbb314dcea5149">&sect;&nbsp;</a></span>configurePinLFXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::configurePinLFXT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if the LFXT pin should be configured for LFXT function. </p>
<p>If 'true', the LFXT pin will be configured for LFXT function.</p>
<p>If 'false', the pin will not be configured. </p>

</div>
</div>
<a id="a0365ac9ecab7c32b6aae9ccb9a6dac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0365ac9ecab7c32b6aae9ccb9a6dac13">&sect;&nbsp;</a></span>bypassLFXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::bypassLFXT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if the LFXT pin should be configured for LFXT bypass. </p>
<p>If 'true', the LFXT pin will be configured for LFXT bypass.</p>
<p>If 'false', the pin will not be configured for LFXT bypass. </p>

</div>
</div>
<a id="aeb6e54d58c9f297e9dcef1b666dd8df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6e54d58c9f297e9dcef1b666dd8df3">&sect;&nbsp;</a></span>enableInterruptsCS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerMSP432_ConfigV1::enableInterruptsCS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if interrupts from the Clock System (CS) should be enabled for catching clock and oscillator fault conditions. </p>
<p>If 'true', an application-provided interrupt service routine will be configured for catching CS interrupts.</p>
<p>If 'false', interrupts from the CS will not be enabled.</p>
<p>When a performance level is activated that uses HFXT and/or LFXT, and this Boolean is true, the corresponding interrupt sources (HFXTIE and/or LFXTIE) will be enabled at the CS. If HFXT and/or LFXT are later disabled, the corresponding interrupt sources will likewise be disabled. </p>

</div>
</div>
<a id="a0a9f17e1e6b344e08c057870cc363c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9f17e1e6b344e08c057870cc363c42">&sect;&nbsp;</a></span>priorityInterruptsCS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int PowerMSP432_ConfigV1::priorityInterruptsCS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The interrupt priority to be configured for CS interrupts. </p>

</div>
</div>
<a id="a8e983faf2c1d8bd65bba5320c3a03019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e983faf2c1d8bd65bba5320c3a03019">&sect;&nbsp;</a></span>isrCS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* PowerMSP432_ConfigV1::isrCS) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The application-provided interrupt service routine that should be configured for handling CS interrupts. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_power_m_s_p432_8h_source.html">PowerMSP432.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
