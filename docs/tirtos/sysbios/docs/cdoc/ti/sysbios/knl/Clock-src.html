<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.knl.Clock</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2013-2018, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Clock.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> *
</span>    36    <span class="comment"> */</span>
    37    
    38    <span class=key>package</span> ti.sysbios.knl;
    39    
    40    import xdc.rov.ViewInfo;
    41    
    42    import xdc.runtime.Assert;
    43    import xdc.runtime.Diags;
    44    import xdc.runtime.Log;
    45    
    46    <span class="xdoc">/*!
</span>    47    <span class="xdoc"> *  ======== Clock ========
</span>    48    <span class="xdoc"> *  System Clock Manager
</span>    49    <span class="xdoc"> *
</span>    50    <span class="xdoc"> *  The System Clock Manager is responsible for all timing services in
</span>    51    <span class="xdoc"> *  SYS/BIOS.
</span>    52    <span class="xdoc"> *  It generates the periodic system tick. The tick period is configurable.
</span>    53    <span class="xdoc"> *  The timeout and period for all Clock Instances and timeout values in
</span>    54    <span class="xdoc"> *  other SYS/BIOS modules are specified in terms of Clock ticks.
</span>    55    <span class="xdoc"> *
</span>    56    <span class="xdoc"> *  The Clock Manager supports two tick "modes": a periodic mode with an
</span>    57    <span class="xdoc"> *  interrupt on each tick (TickMode_PERIODIC), and a tick suppression
</span>    58    <span class="xdoc"> *  mode (TickMode_DYNAMIC), which reduces the number of timer interrupts to
</span>    59    <span class="xdoc"> *  the minimum required to support the scheduled timeouts.  For devices that
</span>    60    <span class="xdoc"> *  support it (e.g., CC13xx/CC26xx devices), TickMode_DYNAMIC may be the default
</span>    61    <span class="xdoc"> *  mode if one is not specified in the application configuration; otherwise,
</span>    62    <span class="xdoc"> *  the default mode will be TickMode_PERIODIC.  The following example shows
</span>    63    <span class="xdoc"> *  how the tick mode  can be specified in the application configuration:
</span>    64    <span class="xdoc"> *
</span>    65    <span class="xdoc"> *  <b>@p(code)</b>
</span>    66    <span class="xdoc"> *  var Clock = xdc.useModule('ti.sysbios.knl.Clock');
</span>    67    <span class="xdoc"> *
</span>    68    <span class="xdoc"> *  // Tell the Clock module to use TickMode_PERIODIC
</span>    69    <span class="xdoc"> *  Clock.tickMode = Clock.TickMode_PERIODIC;
</span>    70    <span class="xdoc"> *  <b>@p</b>
</span>    71    <span class="xdoc"> *
</span>    72    <span class="xdoc"> *  Clock objects contain functions that can be scheduled to run after a
</span>    73    <span class="xdoc"> *  certain number of Clock ticks.
</span>    74    <span class="xdoc"> *  Clock objects are either one-shot or periodic. Instances are started
</span>    75    <span class="xdoc"> *  when created or they are started later using the Clock_start() function.
</span>    76    <span class="xdoc"> *  Instances can be stopped using the Clock_stop() function. All Clock
</span>    77    <span class="xdoc"> *  Instances are executed when they expire in the context of a software
</span>    78    <span class="xdoc"> *  interrupt.
</span>    79    <span class="xdoc"> *
</span>    80    <span class="xdoc"> *  Clock objects are placed in the Clock object service list when
</span>    81    <span class="xdoc"> *  created/constructed and remain there until deleted/destructed.
</span>    82    <span class="xdoc"> *  To minimize processing overhead, unused or expired Clock objects
</span>    83    <span class="xdoc"> *  should be deleted or destructed.
</span>    84    <span class="xdoc"> *
</span>    85    <span class="xdoc"> *  By default, all Clock functions run in the context of a Swi.
</span>    86    <span class="xdoc"> *  That is, the Clock module automatically creates a Swi for
</span>    87    <span class="xdoc"> *  its use and runs the Clock functions within that Swi.
</span>    88    <span class="xdoc"> *  The priority of the Swi used by Clock can be changed
</span>    89    <span class="xdoc"> *  by configuring {<b>@link</b> #swiPriority Clock.swiPriority}.
</span>    90    <span class="xdoc"> *
</span>    91    <span class="xdoc"> *  If Swis are disabled in an application
</span>    92    <span class="xdoc"> *  (ie {<b>@link</b> ti.sysbios.BIOS#swiEnabled BIOS.swiEnabled} = false),
</span>    93    <span class="xdoc"> *  then all Clock functions are executed within the context of
</span>    94    <span class="xdoc"> *  a Timer Hwi.
</span>    95    <span class="xdoc"> *
</span>    96    <span class="xdoc"> *  <b>@a(Note)</b>
</span>    97    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    98    <span class="xdoc"> *  As Clock functions execute in either a Swi or Hwi context, they
</span>    99    <span class="xdoc"> *  are not permitted to call blocking APIs.
</span>   100    <span class="xdoc"> *  <b>@p</b>
</span>   101    <span class="xdoc"> *  <b>@a</b>
</span>   102    <span class="xdoc"> *
</span>   103    <span class="xdoc"> *  The getTicks() function returns number of clock ticks since startup.
</span>   104    <span class="xdoc"> *
</span>   105    <span class="xdoc"> *  By default, the Timer module defined by {<b>@link</b> #TimerProxy} is used to
</span>   106    <span class="xdoc"> *  statically create a timer instance that provides a periodic 1 ms 
</span>   107    <span class="xdoc"> *  tick interrupt.
</span>   108    <span class="xdoc"> *
</span>   109    <span class="xdoc"> *  If you want to use a custom configured timer for the Clock module's
</span>   110    <span class="xdoc"> *  tick source, use the following example configuration as a guide:
</span>   111    <span class="xdoc"> *
</span>   112    <span class="xdoc"> *  <b>@p(code)</b>
</span>   113    <span class="xdoc"> *  var Clock = xdc.useModule('ti.sysbios.knl.Clock');
</span>   114    <span class="xdoc"> *
</span>   115    <span class="xdoc"> *  // Tell the Clock module that YOU are providing the periodic interrupt
</span>   116    <span class="xdoc"> *  Clock.tickSource = Clock.TickSource_USER;
</span>   117    <span class="xdoc"> *
</span>   118    <span class="xdoc"> *  // this example uses the ti.sysbios.timers.dmtimer.Timer module
</span>   119    <span class="xdoc"> *  var Timer = xdc.useModule('ti.sysbios.timers.dmtimer.Timer');
</span>   120    <span class="xdoc"> *
</span>   121    <span class="xdoc"> *  // Change Timer 3 frequency to 24 Mhz from default if necessary
</span>   122    <span class="xdoc"> *  Timer.intFreqs[3] = { hi:0, lo:24000000 };
</span>   123    <span class="xdoc"> *
</span>   124    <span class="xdoc"> *  // create a dmtimer config parameter object
</span>   125    <span class="xdoc"> *  var timerParams = new Timer.Params();
</span>   126    <span class="xdoc"> *
</span>   127    <span class="xdoc"> *  // make sure you set the period to 1000 us (1ms)
</span>   128    <span class="xdoc"> *  timerParams.period = 1000;
</span>   129    <span class="xdoc"> *
</span>   130    <span class="xdoc"> *  // custom dmtimer config parameters here...
</span>   131    <span class="xdoc"> *  timerParams.twer.ovf_wup_ena = 1;
</span>   132    <span class="xdoc"> *
</span>   133    <span class="xdoc"> *  // Create the timer.
</span>   134    <span class="xdoc"> *  // This example uses timer id 3.
</span>   135    <span class="xdoc"> *  // Provide your own timer interrupt handler function.
</span>   136    <span class="xdoc"> *  Timer.create(3, '&amp;myTimerTick', timerParams);
</span>   137    <span class="xdoc"> *  <b>@p</b>
</span>   138    <span class="xdoc"> *
</span>   139    <span class="xdoc"> *  In your 'C' code, add your timer interrupt handler and have it
</span>   140    <span class="xdoc"> *  call Clock_tick(), which will perform all of the Clock module
</span>   141    <span class="xdoc"> *  tick duties:
</span>   142    <span class="xdoc"> *
</span>   143    <span class="xdoc"> *  <b>@p(code)</b>
</span>   144    <span class="xdoc"> *  #include &lt;ti/sysbios/knl/Clock.h&gt;
</span>   145    <span class="xdoc"> *
</span>   146    <span class="xdoc"> *  Void myTimerTick(UArg arg)
</span>   147    <span class="xdoc"> *  {
</span>   148    <span class="xdoc"> *       Clock_tick();
</span>   149    <span class="xdoc"> *       ...
</span>   150    <span class="xdoc"> *  }
</span>   151    <span class="xdoc"> *  <b>@p</b>
</span>   152    <span class="xdoc"> *
</span>   153    <span class="xdoc"> *  <b>@p(html)</b>
</span>   154    <span class="xdoc"> *  &lt;h3&gt; Calling Context &lt;/h3&gt;
</span>   155    <span class="xdoc"> *  &lt;table border="1" cellpadding="3"&gt;
</span>   156    <span class="xdoc"> *    &lt;colgroup span="1"&gt;&lt;/colgroup&gt; &lt;colgroup span="5" align="center"&gt;
</span>   157    <span class="xdoc"> *    &lt;/colgroup&gt;
</span>   158    <span class="xdoc"> *
</span>   159    <span class="xdoc"> *    &lt;tr&gt;&lt;th&gt; Function                &lt;/th&gt;&lt;th&gt;  Hwi   &lt;/th&gt;&lt;th&gt;  Swi   &lt;/th&gt;
</span>   160    <span class="xdoc"> *    &lt;th&gt;  Task  &lt;/th&gt;&lt;th&gt;  Main  &lt;/th&gt;&lt;th&gt;  Startup  &lt;/th&gt;&lt;/tr&gt;
</span>   161    <span class="xdoc"> *    &lt;!--                                                                --&gt;
</span>   162    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #construct}      &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   163    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   164    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #create}         &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   165    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   166    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #delete}         &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   167    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   168    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #destruct}       &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   169    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   170    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTicks}       &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   171    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   172    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTimerHandle} &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   173    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   174    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #Params_init}    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   175    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   176    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tick}           &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   177    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   178    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickReconfig}   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   179    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   180    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickStart}      &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   181    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   182    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickStop}       &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   183    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   184    <span class="xdoc"> *
</span>   185    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTimeout}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   186    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   187    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #isActive}       &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   188    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   189    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setFunc}        &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   190    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   191    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setPeriod}      &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   192    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   193    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setTimeout}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   194    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   195    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #start}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   196    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   197    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #stop}           &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   198    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   199    <span class="xdoc"> *    &lt;tr&gt;&lt;td colspan="6"&gt; Definitions: &lt;br /&gt;
</span>   200    <span class="xdoc"> *       &lt;ul&gt;
</span>   201    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Hwi&lt;/b&gt;: API is callable from a Hwi thread. &lt;/li&gt;
</span>   202    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Swi&lt;/b&gt;: API is callable from a Swi thread. &lt;/li&gt;
</span>   203    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Task&lt;/b&gt;: API is callable from a Task thread. &lt;/li&gt;
</span>   204    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Main&lt;/b&gt;: API is callable during any of these phases: &lt;/li&gt;
</span>   205    <span class="xdoc"> *           &lt;ul&gt;
</span>   206    <span class="xdoc"> *             &lt;li&gt; In your module startup after this module is started
</span>   207    <span class="xdoc"> *    (e.g. Clock_Module_startupDone() returns TRUE). &lt;/li&gt;
</span>   208    <span class="xdoc"> *             &lt;li&gt; During
</span>   209    <span class="xdoc"> *    {<b>@link</b> xdc.runtime.Startup#lastFxns Startup.lastFxns}. &lt;/li&gt;
</span>   210    <span class="xdoc"> *             &lt;li&gt; During main().&lt;/li&gt;
</span>   211    <span class="xdoc"> *             &lt;li&gt; During
</span>   212    <span class="xdoc"> *    {<b>@link</b> ti.sysbios.BIOS#startupFxns BIOS.startupFxns}.&lt;/li&gt;
</span>   213    <span class="xdoc"> *           &lt;/ul&gt;
</span>   214    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Startup&lt;/b&gt;: API is callable during any of these phases:&lt;/li&gt;
</span>   215    <span class="xdoc"> *           &lt;ul&gt;
</span>   216    <span class="xdoc"> *             &lt;li&gt; During
</span>   217    <span class="xdoc"> *    {<b>@link</b> xdc.runtime.Startup#firstFxns Startup.firstFxns}.&lt;/li&gt;
</span>   218    <span class="xdoc"> *             &lt;li&gt; In your module startup before this module is started
</span>   219    <span class="xdoc"> *    (e.g. Clock_Module_startupDone() returns FALSE).&lt;/li&gt;
</span>   220    <span class="xdoc"> *           &lt;/ul&gt;
</span>   221    <span class="xdoc"> *       &lt;/ul&gt;
</span>   222    <span class="xdoc"> *    &lt;/td&gt;&lt;/tr&gt;
</span>   223    <span class="xdoc"> *
</span>   224    <span class="xdoc"> *  &lt;/table&gt;
</span>   225    <span class="xdoc"> *  <b>@p</b>
</span>   226    <span class="xdoc"> */</span>
   227    
   228    @DirectCall
   229    @ModuleStartup
   230    @InstanceInitStatic <span class="comment">/* Construct/Destruct CAN becalled at runtime */</span>
   231    @InstanceFinalize   <span class="comment">/* generate call to Clock_Instance_finalize on delete */</span>
   232    @Template(<span class="string">"./Clock.xdt"</span>)
   233    
   234    <span class=key>module</span> Clock
   235    {
   236        <span class="xdoc">/*!
</span>   237    <span class="xdoc">     *  ======== TickSource ========
</span>   238    <span class="xdoc">     *  Clock tick source
</span>   239    <span class="xdoc">     *
</span>   240    <span class="xdoc">     *  <b>@field(TickSource_TIMER)</b> The Clock module automatically configures a
</span>   241    <span class="xdoc">     *  a Timer instance (see {<b>@link</b> #TimerProxy}) to drive the Clock tick.
</span>   242    <span class="xdoc">     *  The specific timer and its period can be controlled via
</span>   243    <span class="xdoc">     *  {<b>@link</b> #timerId} and {<b>@link</b> #tickPeriod}.
</span>   244    <span class="xdoc">     *
</span>   245    <span class="xdoc">     *  <b>@field(TickSource_USER)</b> The Application is responsible for calling
</span>   246    <span class="xdoc">     *  {<b>@link</b> #tick Clock_tick()} periodically. Make sure {<b>@link</b> #tickPeriod
</span>   247    <span class="xdoc">     *  Clock.tickPeriod} is set to the period that Clock_tick() is called.
</span>   248    <span class="xdoc">     *
</span>   249    <span class="xdoc">     *  Like most other module configuration parameters, the Clock.tickPeriod
</span>   250    <span class="xdoc">     *  config parameter value is accessible in runtime C code as
</span>   251    <span class="xdoc">     *  "Clock_tickPeriod".
</span>   252    <span class="xdoc">     *
</span>   253    <span class="xdoc">     *  <b>@field(TickSource_NULL)</b> The Clock module is disabled.
</span>   254    <span class="xdoc">     *  In this case, it is an error for the application to ever call
</span>   255    <span class="xdoc">     *  Clock_tick().
</span>   256    <span class="xdoc">     *
</span>   257    <span class="xdoc">     *  <b>@see</b> #tickPeriod
</span>   258    <span class="xdoc">     *  <b>@see</b> #timerId
</span>   259    <span class="xdoc">     */</span>
   260        <span class=key>enum</span>  TickSource {
   261            TickSource_TIMER,   <span class="xdoc">/*! Internally configure a Timer to periodically call Clock_tick() */</span>
   262            TickSource_USER,    <span class="xdoc">/*! Application code calls Clock_tick() */</span>
   263            TickSource_NULL     <span class="xdoc">/*! The Clock module is disabled */</span>
   264        };
   265    
   266        <span class="xdoc">/*!
</span>   267    <span class="xdoc">     *  ======== TickMode ========
</span>   268    <span class="xdoc">     *  Clock Tick Mode
</span>   269    <span class="xdoc">     */</span>
   270        <span class=key>enum</span>  TickMode {
   271            TickMode_PERIODIC,  <span class="xdoc">/*! Timer will interrupt every period */</span>
   272            TickMode_DYNAMIC    <span class="xdoc">/*! Unnecessary timer ticks will be suppressed */</span>
   273        };
   274    
   275        <span class="xdoc">/*!
</span>   276    <span class="xdoc">     *  ======== BasicView ========
</span>   277    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   278    <span class="xdoc">     */</span>
   279        <span class=key>metaonly</span> <span class=key>struct</span> BasicView {
   280            String          label;
   281            UInt32          timeout;
   282            UInt            period;
   283            String          fxn[];
   284            UArg            arg;
   285            Bool            started;        <span class="comment">/* Instance running? */</span>
   286            String          tRemaining;     <span class="comment">/* Remaining timeout */</span>
   287            Bool            periodic;       <span class="comment">/* Periodic? (vs. one-shot) */</span>
   288        }
   289    
   290        <span class="xdoc">/*!
</span>   291    <span class="xdoc">     *  ======== ModuleView ========
</span>   292    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   293    <span class="xdoc">     */</span>
   294        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   295            String          ticks;
   296            String          tickSource;
   297            String          tickMode;
   298            String          timerHandle;
   299            UInt            timerId;
   300            UInt            swiPriority;
   301            UInt32          tickPeriod;
   302            volatile UInt   nSkip;
   303        }
   304    
   305        <span class="comment">/*
</span>   306    <span class="comment">     *  ======== rovViewInfo ========
</span>   307    <span class="comment">     *  @_nodoc
</span>   308    <span class="comment">     */</span>
   309        @Facet
   310        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo =
   311            ViewInfo.create({
   312                viewMap: [
   313                  [<span class="string">'Basic'</span>,    {type: ViewInfo.INSTANCE, viewInitFxn: <span class="string">'viewInitBasic'</span>,  structName: <span class="string">'BasicView'</span>}],
   314                  [<span class="string">'Module'</span>,   {type: ViewInfo.MODULE,   viewInitFxn: <span class="string">'viewInitModule'</span>, structName: <span class="string">'ModuleView'</span>}],
   315                ]
   316            });
   317    
   318        <span class="xdoc">/*!
</span>   319    <span class="xdoc">     *  ======== FuncPtr ========
</span>   320    <span class="xdoc">     * Instance function prototype
</span>   321    <span class="xdoc">     */</span>
   322        <span class=key>typedef</span> Void (*FuncPtr)(UArg);
   323    
   324        <span class="xdoc">/*! 
</span>   325    <span class="xdoc">     *  ======== TimerProxy ========
</span>   326    <span class="xdoc">     *  target/device-specific Timer implementation.
</span>   327    <span class="xdoc">     *
</span>   328    <span class="xdoc">     *  The Timer module used by the Clock module to
</span>   329    <span class="xdoc">     *  create a Timer instance when Clock.tickSource_TIMER is configured.
</span>   330    <span class="xdoc">     *
</span>   331    <span class="xdoc">     *  By default, a target specific Timer module is internally selected 
</span>   332    <span class="xdoc">     *  for this purpose. If the user wishes to use a different Timer module
</span>   333    <span class="xdoc">     *  then the following configuration script will serve as an example for
</span>   334    <span class="xdoc">     *  achieving that:
</span>   335    <span class="xdoc">     *
</span>   336    <span class="xdoc">     *  <b>@p(code)</b>
</span>   337    <span class="xdoc">     *  var Clock = xdc.useModule('ti.sysbios.knl.Clock');
</span>   338    <span class="xdoc">     *
</span>   339    <span class="xdoc">     *  // Use a dmtimer Timer instance
</span>   340    <span class="xdoc">     *  Clock.TimerProxy = xdc.useModule('ti.sysbios.timers.dmtimer.Timer');
</span>   341    <span class="xdoc">     *  <b>@p</b>
</span>   342    <span class="xdoc">     *
</span>   343    <span class="xdoc">     */</span>
   344        <span class=key>proxy</span> TimerProxy <span class=key>inherits</span> ti.sysbios.interfaces.ITimer;
   345    
   346        <span class="xdoc">/*!
</span>   347    <span class="xdoc">     *  ======== LW_delayed ========
</span>   348    <span class="xdoc">     *  Logged if Clock Swi delayed by &gt;= 1 tick
</span>   349    <span class="xdoc">     */</span>
   350        <span class=key>config</span> Log.Event LW_delayed = {
   351            mask: Diags.USER3,
   352            msg: <span class="string">"LW_delayed: delay: %d"</span>
   353        };
   354    
   355        <span class="xdoc">/*!
</span>   356    <span class="xdoc">     *  ======== LM_tick ========
</span>   357    <span class="xdoc">     *  Logged in every Clock tick interrupt
</span>   358    <span class="xdoc">     */</span>
   359        <span class=key>config</span> Log.Event LM_tick = {
   360            mask: Diags.USER1 | Diags.USER2,
   361            msg: <span class="string">"LM_tick: tick: %d"</span>
   362        };
   363    
   364        <span class="xdoc">/*!
</span>   365    <span class="xdoc">     *  ======== LM_begin ========
</span>   366    <span class="xdoc">     *  Logged just prior to calling each Clock function
</span>   367    <span class="xdoc">     */</span>
   368        <span class=key>config</span> Log.Event LM_begin = {
   369            mask: Diags.USER1 | Diags.USER2,
   370            msg: <span class="string">"LM_begin: clk: 0x%x, func: 0x%x"</span>
   371        };
   372    
   373        <span class="xdoc">/*!
</span>   374    <span class="xdoc">     *  ======== A_clockDisabled ========
</span>   375    <span class="xdoc">     *  Asserted in Clock_create()
</span>   376    <span class="xdoc">     */</span>
   377        <span class=key>config</span> Assert.Id A_clockDisabled = {
   378            msg: <span class="string">"A_clockDisabled: Cannot create a clock instance when BIOS.clockEnabled is false."</span>
   379        };
   380    
   381        <span class="xdoc">/*!
</span>   382    <span class="xdoc">     *  ======== A_badThreadType ========
</span>   383    <span class="xdoc">     *  Asserted in Clock_create and Clock_delete
</span>   384    <span class="xdoc">     */</span>
   385        <span class=key>config</span> Assert.Id A_badThreadType = {
   386            msg: <span class="string">"A_badThreadType: Cannot create/delete a Clock from Hwi or Swi thread."</span>
   387        };
   388    
   389        <span class="xdoc">/*!
</span>   390    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   391    <span class="xdoc">     *  !!! Do not delete. Required for ROM compatibility !!!
</span>   392    <span class="xdoc">     */</span>
   393        <span class=key>config</span> UInt32 serviceMargin = 0;
   394    
   395        <span class="xdoc">/*!
</span>   396    <span class="xdoc">     *  ======== tickSource ========
</span>   397    <span class="xdoc">     *  Source of clock ticks
</span>   398    <span class="xdoc">     *
</span>   399    <span class="xdoc">     *  If this parameter is not set to TickSource_TIMER,
</span>   400    <span class="xdoc">     *  {<b>@link</b> #tickStart Clock_tickStart()},
</span>   401    <span class="xdoc">     *  {<b>@link</b> #tickStop Clock_tickStop()}, and
</span>   402    <span class="xdoc">     *  {<b>@link</b> #tickReconfig Clock_tickReconfig()}, have no effect.
</span>   403    <span class="xdoc">     *
</span>   404    <span class="xdoc">     *  The default is TickSource_TIMER.
</span>   405    <span class="xdoc">     */</span>
   406        <span class=key>config</span> TickSource tickSource = TickSource_TIMER;
   407    
   408        <span class="xdoc">/*!
</span>   409    <span class="xdoc">     *  ======== tickMode ========
</span>   410    <span class="xdoc">     *  Timer tick mode
</span>   411    <span class="xdoc">     *
</span>   412    <span class="xdoc">     *  This parameter specifies the tick mode to be used by the underlying
</span>   413    <span class="xdoc">     *  Timer.
</span>   414    <span class="xdoc">     *
</span>   415    <span class="xdoc">     *  With TickMode_PERIODIC the timer will interrupt the CPU at
</span>   416    <span class="xdoc">     *  a fixed rate, defined by the tickPeriod.
</span>   417    <span class="xdoc">     *
</span>   418    <span class="xdoc">     *  With TickMode_DYNAMIC the timer can be dynamically reprogrammed by
</span>   419    <span class="xdoc">     *  Clock, to interrupt the CPU when the next tick is actually needed for
</span>   420    <span class="xdoc">     *  a scheduled timeout. TickMode_DYNAMIC is not supported on all devices,
</span>   421    <span class="xdoc">     *  and may have some application constraints.
</span>   422    <span class="xdoc">     */</span>
   423        <span class=key>config</span> TickMode tickMode;
   424    
   425        <span class="xdoc">/*!
</span>   426    <span class="xdoc">     *  ======== timerId ========
</span>   427    <span class="xdoc">     *  Timer Id used to create a Timer instance
</span>   428    <span class="xdoc">     *
</span>   429    <span class="xdoc">     *  If {<b>@link</b> #tickSource Clock.tickSource} is set to TickSource_TIMER,
</span>   430    <span class="xdoc">     *  the Clock module internally creates a
</span>   431    <span class="xdoc">     *  static Timer instance (see {<b>@link</b> #TimerProxy}) that automatically calls
</span>   432    <span class="xdoc">     *  Clock_doTick() on a periodic basis (as specified by
</span>   433    <span class="xdoc">     *  {<b>@link</b> #tickPeriod tickPeriod} and {<b>@link</b> #periodType periodType}.)
</span>   434    <span class="xdoc">     *
</span>   435    <span class="xdoc">     *  This configuration parameter allows you to control which timer is
</span>   436    <span class="xdoc">     *  used to drive the Clock module.
</span>   437    <span class="xdoc">     *
</span>   438    <span class="xdoc">     *  The default value is {<b>@link</b> ti.sysbios.hal.Timer#ANY Timer.ANY} (~0)
</span>   439    <span class="xdoc">     *  and the maximum timerId possible is family and device specific.
</span>   440    <span class="xdoc">     */</span>
   441        <span class=key>config</span> UInt timerId = ~0;
   442    
   443        <span class="xdoc">/*!
</span>   444    <span class="xdoc">     *  ======== swiPriority ========
</span>   445    <span class="xdoc">     *  The priority of Swi used by Clock to process its instances
</span>   446    <span class="xdoc">     *
</span>   447    <span class="xdoc">     *  All Clock instances are executed in the context of a single
</span>   448    <span class="xdoc">     *  {<b>@link</b> Swi}.  This parameter allows you to control the priority of
</span>   449    <span class="xdoc">     *  that Swi.
</span>   450    <span class="xdoc">     *
</span>   451    <span class="xdoc">     *  The default value of this parameter is Swi.numPriorities - 1; i.e.,
</span>   452    <span class="xdoc">     *  the maximum Swi priority.
</span>   453    <span class="xdoc">     *
</span>   454    <span class="xdoc">     *  <b>@see</b> ti.sysbios.knl.Swi#numPriorities
</span>   455    <span class="xdoc">     */</span>
   456        <span class=key>metaonly</span> <span class=key>config</span> UInt swiPriority;
   457    
   458        <span class="xdoc">/*!
</span>   459    <span class="xdoc">     *  ======== tickPeriod ========
</span>   460    <span class="xdoc">     *  Tick period specified in microseconds
</span>   461    <span class="xdoc">     *
</span>   462    <span class="xdoc">     *  Default value is family dependent. For example, Linux systems often
</span>   463    <span class="xdoc">     *  only support a minimum period of 10000 us and multiples of 10000 us.
</span>   464    <span class="xdoc">     *  TI platforms have a default of 1000 us.
</span>   465    <span class="xdoc">     *
</span>   466    <span class="xdoc">     *  Like most other module configuration parameters, the Clock.tickPeriod
</span>   467    <span class="xdoc">     *  config parameter value is accessible in runtime C code as
</span>   468    <span class="xdoc">     *  "Clock_tickPeriod".
</span>   469    <span class="xdoc">     */</span>
   470        <span class=key>config</span> UInt32 tickPeriod;
   471    
   472        <span class="xdoc">/*!
</span>   473    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   474    <span class="xdoc">     *  ======== stopCheckNext ========
</span>   475    <span class="xdoc">     *  Boolean to control whether a check is made upon each Clock_stop() call
</span>   476    <span class="xdoc">     *  to determine if the Clock object being stopped is due to timeout on the
</span>   477    <span class="xdoc">     *  next scheduled tick.  If this feature is enabled, and the timeout
</span>   478    <span class="xdoc">     *  coincides with the next scheduled tick, then a special 'trigger' Clock
</span>   479    <span class="xdoc">     *  will be started to force a reschedule of the next tick, as soon as
</span>   480    <span class="xdoc">     *  possible. This feature is only applicable for Clock.TickMode_DYNAMIC.
</span>   481    <span class="xdoc">     *
</span>   482    <span class="xdoc">     *  For most use cases it is most efficient to simply stop
</span>   483    <span class="xdoc">     *  a Clock object, and then let the next scheduled tick occur naturally.
</span>   484    <span class="xdoc">     *  But some low power application use cases (that routinely stop the next
</span>   485    <span class="xdoc">     *  expiring Clock object) can benefit by scheduling an immediate tick, to
</span>   486    <span class="xdoc">     *  suppress the next scheduled tick.  The default value for most
</span>   487    <span class="xdoc">     *  targets is 'false', for cc26xx/cc13xx it is 'true'.  The default is
</span>   488    <span class="xdoc">     *  established in Clock.xs, if the application has not explicitly
</span>   489    <span class="xdoc">     *  specified a value.
</span>   490    <span class="xdoc">     */</span>
   491        <span class=key>metaonly</span> <span class=key>config</span> Bool stopCheckNext;
   492    
   493        <span class="xdoc">/*!
</span>   494    <span class="xdoc">     *  ======== getTicks ========
</span>   495    <span class="xdoc">     *  Time in Clock ticks
</span>   496    <span class="xdoc">     *
</span>   497    <span class="xdoc">     *  The value returned will wrap back to zero after it reaches the max
</span>   498    <span class="xdoc">     *  value that can be stored in 32 bits.
</span>   499    <span class="xdoc">     *
</span>   500    <span class="xdoc">     *  <b>@b(returns)</b>     time in clock ticks
</span>   501    <span class="xdoc">     */</span>
   502        UInt32 getTicks();
   503    
   504        <span class="xdoc">/*!
</span>   505    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   506    <span class="xdoc">     *  ======== getTimerHandle ========
</span>   507    <span class="xdoc">     *  Get timer Handle
</span>   508    <span class="xdoc">     *
</span>   509    <span class="xdoc">     *  Used when it is necessary to change family
</span>   510    <span class="xdoc">     *  specific options for the timer and its Hwi Object.
</span>   511    <span class="xdoc">     *
</span>   512    <span class="xdoc">     *  <b>@b(returns)</b>     Timer Handle
</span>   513    <span class="xdoc">     */</span>
   514        TimerProxy.Handle getTimerHandle();
   515    
   516        <span class="xdoc">/*!
</span>   517    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   518    <span class="xdoc">     *  ======== setTicks ========
</span>   519    <span class="xdoc">     *  Set the internal Clock tick counter
</span>   520    <span class="xdoc">     *
</span>   521    <span class="xdoc">     *  Used internally by Power modules. Only applicable for
</span>   522    <span class="xdoc">     *  Clock.TickMode_PERIODIC
</span>   523    <span class="xdoc">     */</span>
   524        Void setTicks(UInt32 ticks);
   525    
   526        <span class="xdoc">/*!
</span>   527    <span class="xdoc">     *  ======== tickStop ========
</span>   528    <span class="xdoc">     *  Stop clock for reconfiguration
</span>   529    <span class="xdoc">     *
</span>   530    <span class="xdoc">     *  This function is used to stop the timer used for generation of
</span>   531    <span class="xdoc">     *  clock ticks. It is used along with Clock_tickStart() and
</span>   532    <span class="xdoc">     *  Clock_tickReconfig() to allow reconfiguration of timer at runtime.
</span>   533    <span class="xdoc">     *
</span>   534    <span class="xdoc">     *  Stopping the timer may not be supported for some types of timers, and
</span>   535    <span class="xdoc">     *  is not supported for Clock.TickMode_DYNAMIC; in these cases, this
</span>   536    <span class="xdoc">     *  this function call will have no effect.
</span>   537    <span class="xdoc">     *
</span>   538    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   539    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   540    <span class="xdoc">     *  protect against  re-entrancy.
</span>   541    <span class="xdoc">     */</span>
   542        Void tickStop();
   543    
   544        <span class="xdoc">/*!
</span>   545    <span class="xdoc">     *  ======== tickReconfig ========
</span>   546    <span class="xdoc">     *  Reconfigure clock for new cpu frequency
</span>   547    <span class="xdoc">     *
</span>   548    <span class="xdoc">     *  This function uses the new cpu frequency to reconfigure the timer used
</span>   549    <span class="xdoc">     *  for generation of clock ticks such that tick period is
</span>   550    <span class="xdoc">     *  accurate.  This function is used along with Clock_tickStop() and
</span>   551    <span class="xdoc">     *  Clock_tickStart() to allow reconfiguration of timer at runtime.
</span>   552    <span class="xdoc">     *
</span>   553    <span class="xdoc">     *  Reconfiguration may not be supported for some types of timers, and is
</span>   554    <span class="xdoc">     *  not supported for Clock.TickMode_DYNAMIC; in these cases, this
</span>   555    <span class="xdoc">     *  this function call will have no effect, and will return false.
</span>   556    <span class="xdoc">     *
</span>   557    <span class="xdoc">     *  When calling Clock_tickReconfig outside of main(), you must also call
</span>   558    <span class="xdoc">     *  Clock_tickStop and Clock_tickStart to stop and restart the timer.
</span>   559    <span class="xdoc">     *  Use the following call sequence:
</span>   560    <span class="xdoc">     *
</span>   561    <span class="xdoc">     *  <b>@p(code)</b>
</span>   562    <span class="xdoc">     *  // disable interrupts if an interrupt could lead to
</span>   563    <span class="xdoc">     *  // another call to Clock_tickReconfig or if interrupt
</span>   564    <span class="xdoc">     *  // processing relies on having a running timer
</span>   565    <span class="xdoc">     *  Hwi_disable() or Swi_disable();
</span>   566    <span class="xdoc">     *  BIOS_setCpuFreq(&amp;freq);
</span>   567    <span class="xdoc">     *  Clock_tickStop();
</span>   568    <span class="xdoc">     *  Clock_tickReconfig();
</span>   569    <span class="xdoc">     *  Clock_tickStart();
</span>   570    <span class="xdoc">     *  Hwi_restore() or Swi_enable()
</span>   571    <span class="xdoc">     *  <b>@p</b>
</span>   572    <span class="xdoc">     *
</span>   573    <span class="xdoc">     *  When calling Clock_tickReconfig from main(), the timer has not yet
</span>   574    <span class="xdoc">     *  been started because the timer is started as part of BIOS_start().
</span>   575    <span class="xdoc">     *  As a result, you can use the following simplified call sequence
</span>   576    <span class="xdoc">     *  in main():
</span>   577    <span class="xdoc">     *
</span>   578    <span class="xdoc">     *  <b>@p(code)</b>
</span>   579    <span class="xdoc">     *  BIOS_setCpuFrequency(Types.FreqHz *freq);
</span>   580    <span class="xdoc">     *  Clock_tickReconfig(Void);
</span>   581    <span class="xdoc">     *  <b>@p</b>
</span>   582    <span class="xdoc">     *
</span>   583    <span class="xdoc">     *  The return value is false if the timer cannot support the new
</span>   584    <span class="xdoc">     *  frequency
</span>   585    <span class="xdoc">     *
</span>   586    <span class="xdoc">     *  <b>@b(returns)</b>     true if successful
</span>   587    <span class="xdoc">     *
</span>   588    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   589    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   590    <span class="xdoc">     *  protect against  re-entrancy.
</span>   591    <span class="xdoc">     */</span>
   592        Bool tickReconfig();
   593    
   594        <span class="xdoc">/*!
</span>   595    <span class="xdoc">     *  ======== tickStart ========
</span>   596    <span class="xdoc">     *  Start clock after reconfiguration
</span>   597    <span class="xdoc">     *
</span>   598    <span class="xdoc">     *  This function starts the timer used for generation of clock ticks
</span>   599    <span class="xdoc">     *  It is used along with Clock_tickStop() and Clock_tickReconfig() to
</span>   600    <span class="xdoc">     *  allow reconfiguration of timer at runtime. The new timer configuration
</span>   601    <span class="xdoc">     *  reflects changes caused by a call to reconfig().
</span>   602    <span class="xdoc">     *
</span>   603    <span class="xdoc">     *  Reconfiguration and restart of a timer may not be supported for some
</span>   604    <span class="xdoc">     *  types of timers, and is not supported for Clock.TickMode_DYNAMIC; in
</span>   605    <span class="xdoc">     *  these cases, this function call will have no effect.
</span>   606    <span class="xdoc">     *
</span>   607    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   608    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   609    <span class="xdoc">     *  protect against  re-entrancy.
</span>   610    <span class="xdoc">     */</span>
   611        Void tickStart();
   612    
   613        <span class="xdoc">/*!
</span>   614    <span class="xdoc">     *  ======== tick ========
</span>   615    <span class="xdoc">     *  Advance Clock time by one tick
</span>   616    <span class="xdoc">     *
</span>   617    <span class="xdoc">     *  After incrementing a global tick counter, this function posts a Swi
</span>   618    <span class="xdoc">     *  that processes the clock instances.
</span>   619    <span class="xdoc">     *
</span>   620    <span class="xdoc">     *  This function is automatically called by a timer ISR when
</span>   621    <span class="xdoc">     *  {<b>@link</b> #tickSource} is set to {<b>@link</b> #TickSource_TIMER}.
</span>   622    <span class="xdoc">     *
</span>   623    <span class="xdoc">     *  When {<b>@link</b> #tickSource} is set to
</span>   624    <span class="xdoc">     *  {<b>@link</b> #TickSource_USER}, Clock_tick() must be called by the
</span>   625    <span class="xdoc">     *  application.  Usually, this is done within a user defined {<b>@link</b> ti.sysbios.hal.Hwi Hwi},
</span>   626    <span class="xdoc">     *  {<b>@link</b> Swi}, or {<b>@link</b> Task}.
</span>   627    <span class="xdoc">     *
</span>   628    <span class="xdoc">     *  Note that this function is not re-entrant.  The application is
</span>   629    <span class="xdoc">     *  responsible for ensuring that invocations of this function are
</span>   630    <span class="xdoc">     *  serialized: either only one thread in the system ever calls this
</span>   631    <span class="xdoc">     *  function or all calls are "wrapped" by an appropriate mutex.
</span>   632    <span class="xdoc">     *
</span>   633    <span class="xdoc">     *  <b>@see</b> #tickSource
</span>   634    <span class="xdoc">     */</span>
   635        Void tick();
   636    
   637        <span class="xdoc">/*!
</span>   638    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   639    <span class="xdoc">     *  ======== workFunc ========
</span>   640    <span class="xdoc">     *  Clock Q service routine
</span>   641    <span class="xdoc">     *
</span>   642    <span class="xdoc">     *  <b>@param(arg0)</b>    Unused. required to match Swi.FuncPtr
</span>   643    <span class="xdoc">     *  <b>@param(arg1)</b>    Unused. required to match Swi.FuncPtr
</span>   644    <span class="xdoc">     */</span>
   645        Void workFunc(UArg arg0, UArg arg1);
   646    
   647        <span class="xdoc">/*!
</span>   648    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   649    <span class="xdoc">     *  ======== workFuncDynamic ========
</span>   650    <span class="xdoc">     *  Clock Q service routine for TickMode_DYNAMIC
</span>   651    <span class="xdoc">     *
</span>   652    <span class="xdoc">     *  <b>@param(arg0)</b>    Unused. required to match Swi.FuncPtr
</span>   653    <span class="xdoc">     *  <b>@param(arg1)</b>    Unused. required to match Swi.FuncPtr
</span>   654    <span class="xdoc">     */</span>
   655        Void workFuncDynamic(UArg arg0, UArg arg1);
   656    
   657        <span class="xdoc">/*!
</span>   658    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   659    <span class="xdoc">     *  ======= logTick ========
</span>   660    <span class="xdoc">     *  Log the LD_tick from within Clock module scope
</span>   661    <span class="xdoc">     */</span>
   662        Void logTick();
   663    
   664        <span class="xdoc">/*!
</span>   665    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   666    <span class="xdoc">     *  ======== getCompletedTicks ========
</span>   667    <span class="xdoc">     *  Get the number of Clock ticks that have completed
</span>   668    <span class="xdoc">     *
</span>   669    <span class="xdoc">     *  Returns the number of ticks completed, to the point where
</span>   670    <span class="xdoc">     *  the underlying Timer interrupt has been serviced.
</span>   671    <span class="xdoc">     *
</span>   672    <span class="xdoc">     *  Used by some TimestampProviders
</span>   673    <span class="xdoc">     *
</span>   674    <span class="xdoc">     *  <b>@b(returns)</b>     time in clock ticks
</span>   675    <span class="xdoc">     */</span>
   676        UInt32 getCompletedTicks();
   677    
   678        <span class="xdoc">/*!
</span>   679    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   680    <span class="xdoc">     *  ======== getTickPeriod ========
</span>   681    <span class="xdoc">     *  Get the Clock tick period in timer counts
</span>   682    <span class="xdoc">     *
</span>   683    <span class="xdoc">     *  The period is in units returned by the underlying Timer.
</span>   684    <span class="xdoc">     *
</span>   685    <span class="xdoc">     *  Used by some TimestampProviders
</span>   686    <span class="xdoc">     *
</span>   687    <span class="xdoc">     *  <b>@b(returns)</b>     period in timer counts
</span>   688    <span class="xdoc">     */</span>
   689        UInt32 getTickPeriod();
   690    
   691        <span class="xdoc">/*!
</span>   692    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   693    <span class="xdoc">     *  ======== getTicksUntilInterrupt ========
</span>   694    <span class="xdoc">     *  Get the number of Clock tick periods expected to expire between now
</span>   695    <span class="xdoc">     *  and the next interrupt from the timer peripheral
</span>   696    <span class="xdoc">     *
</span>   697    <span class="xdoc">     *  Used internally by Power modules.
</span>   698    <span class="xdoc">     *
</span>   699    <span class="xdoc">     *  <b>@b(returns)</b>     count in ticks
</span>   700    <span class="xdoc">     */</span>
   701        UInt32 getTicksUntilInterrupt();
   702    
   703        <span class="xdoc">/*!
</span>   704    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   705    <span class="xdoc">     *  ======== getTicksUntilTimeout ========
</span>   706    <span class="xdoc">     *  Get the number of Clock tick periods between now and the next
</span>   707    <span class="xdoc">     *  active Clock object timeout.
</span>   708    <span class="xdoc">     *
</span>   709    <span class="xdoc">     *  Used internally by Power modules.
</span>   710    <span class="xdoc">     *
</span>   711    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   712    <span class="xdoc">     *  Must be called with interrupts disabled.  Only applicable for
</span>   713    <span class="xdoc">     *  Clock.TickSource_TIMER.
</span>   714    <span class="xdoc">     *
</span>   715    <span class="xdoc">     *  <b>@b(returns)</b>     count in ticks
</span>   716    <span class="xdoc">     */</span>
   717        UInt32 getTicksUntilTimeout();
   718    
   719        <span class="xdoc">/*!
</span>   720    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   721    <span class="xdoc">     *  ======= walkQueueDynamic ========
</span>   722    <span class="xdoc">     *  Walk Clock's work queue for TickMode_DYNAMIC
</span>   723    <span class="xdoc">     */</span>
   724        UInt32 walkQueueDynamic(Bool service, UInt32 tick);
   725    
   726        <span class="xdoc">/*!
</span>   727    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   728    <span class="xdoc">     *  ======= walkQueuePeriodic ========
</span>   729    <span class="xdoc">     *  Walk Clock's work queue for TickMode_PERIODIC
</span>   730    <span class="xdoc">     */</span>
   731        UInt32 walkQueuePeriodic();
   732    
   733        <span class="xdoc">/*!
</span>   734    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   735    <span class="xdoc">     *  ======= scheduleNextTick ========
</span>   736    <span class="xdoc">     *  Reprogram Clock's Timer for earliest required tick
</span>   737    <span class="xdoc">     */</span>
   738        Void scheduleNextTick(UInt32 deltaTicks, UInt32 absTick);
   739    
   740    <span class=key>instance</span>:
   741    
   742        <span class="xdoc">/*!
</span>   743    <span class="xdoc">     *  ======== create ========
</span>   744    <span class="xdoc">     *  Creates a Clock Instance
</span>   745    <span class="xdoc">     *
</span>   746    <span class="xdoc">     *  The first argument is the function that gets called when the timeout
</span>   747    <span class="xdoc">     *  expires.
</span>   748    <span class="xdoc">     *
</span>   749    <span class="xdoc">     *  The 'timeout' argument is used to specify the startup timeout for
</span>   750    <span class="xdoc">     *  both one-shot and periodic Clock instances (in Clock ticks).  This
</span>   751    <span class="xdoc">     *  timeout is applied when the Clock instance is started.  For periodic
</span>   752    <span class="xdoc">     *  instances, the configured Clock function will be called initially
</span>   753    <span class="xdoc">     *  after an interval equal to the timeout, and will be subsequently
</span>   754    <span class="xdoc">     *  called at the rate specified by the {<b>@link</b> #period} parameter.  For
</span>   755    <span class="xdoc">     *  one-shot instances (where the {<b>@link</b> #period} parameter is 0), once
</span>   756    <span class="xdoc">     *  the Clock instance is started (with {<b>@link</b> #start Clock_start()} or
</span>   757    <span class="xdoc">     *  automatically if {<b>@link</b> #startFlag} is true) the configured Clock
</span>   758    <span class="xdoc">     *  function will be called once after an interval equal to the timeout.
</span>   759    <span class="xdoc">     *
</span>   760    <span class="xdoc">     *  When instances are created they are placed upon a linked list managed
</span>   761    <span class="xdoc">     *  by the Clock module.  For this reason, instances cannot be created
</span>   762    <span class="xdoc">     *  from either Hwi or Swi context.
</span>   763    <span class="xdoc">     *
</span>   764    <span class="xdoc">     *  By default, all Clock functions run in the context of a Swi.
</span>   765    <span class="xdoc">     *  That is, the Clock module automatically creates a Swi for
</span>   766    <span class="xdoc">     *  its use and runs the Clock functions within that Swi. 
</span>   767    <span class="xdoc">     *  The priority of the Swi used by Clock can be changed
</span>   768    <span class="xdoc">     *  by configuring {<b>@link</b> #swiPriority Clock.swiPriority}.
</span>   769    <span class="xdoc">     *  
</span>   770    <span class="xdoc">     *  If Swis are disabled in an application
</span>   771    <span class="xdoc">     *  (ie {<b>@link</b> ti.sysbios.BIOS#swiEnabled BIOS.swiEnabled} = false),
</span>   772    <span class="xdoc">     *  then all Clock functions are executed within the context of
</span>   773    <span class="xdoc">     *  a Timer Hwi. 
</span>   774    <span class="xdoc">     *  
</span>   775    <span class="xdoc">     *  <b>@a(constraint)</b>
</span>   776    <span class="xdoc">     *  <b>@p(blist)</b>
</span>   777    <span class="xdoc">     *  As Clock functions execute in either a Swi or Hwi context, they
</span>   778    <span class="xdoc">     *  are not permitted to call blocking APIs.
</span>   779    <span class="xdoc">     *  <b>@p</b>
</span>   780    <span class="xdoc">     *  <b>@a</b>
</span>   781    <span class="xdoc">     *
</span>   782    <span class="xdoc">     *  <b>@param(clockFxn)</b>  Function that runs upon timeout
</span>   783    <span class="xdoc">     *  <b>@param(timeout)</b>   One-shot timeout or initial start delay (in clock
</span>   784    <span class="xdoc">     *                    ticks)
</span>   785    <span class="xdoc">     */</span>
   786        create(FuncPtr clockFxn, UInt timeout);
   787    
   788        <span class="xdoc">/*!
</span>   789    <span class="xdoc">     *  ======== startFlag ========
</span>   790    <span class="xdoc">     *  Start immediately after instance is created
</span>   791    <span class="xdoc">     *
</span>   792    <span class="xdoc">     *  When this flag is set to false, the user will have to call
</span>   793    <span class="xdoc">     *  Clock_start() to start the instance.
</span>   794    <span class="xdoc">     *
</span>   795    <span class="xdoc">     *  When set to true, both statically created Clock objects and Clock
</span>   796    <span class="xdoc">     *  objects created in main() are started at the end of main() when the
</span>   797    <span class="xdoc">     *  user calls BIOS_start(). Dynamically created Clock objects created
</span>   798    <span class="xdoc">     *  after main() (ie within a task) will be started immediately.
</span>   799    <span class="xdoc">     *
</span>   800    <span class="xdoc">     *  The default setting for this parameter is false.
</span>   801    <span class="xdoc">     *
</span>   802    <span class="xdoc">     *  The configured Clock function will be called initially after an
</span>   803    <span class="xdoc">     *  interval equal to the 'timeout' argument for both one-shot and
</span>   804    <span class="xdoc">     *  periodic Clock objects.
</span>   805    <span class="xdoc">     *
</span>   806    <span class="xdoc">     *  Periodic Clock objects will subsequently be called at the rate
</span>   807    <span class="xdoc">     *  specified by the {<b>@link</b> #period} parameter.
</span>   808    <span class="xdoc">     *
</span>   809    <span class="xdoc">     */</span>
   810        <span class=key>config</span> Bool startFlag = <span class=key>false</span>;
   811    
   812        <span class="xdoc">/*!
</span>   813    <span class="xdoc">     *  ======== period ========
</span>   814    <span class="xdoc">     *  Period of this instance (in clock ticks)
</span>   815    <span class="xdoc">     *
</span>   816    <span class="xdoc">     *  This parameter is used to set the subsequent timeout interval (in
</span>   817    <span class="xdoc">     *  Clock ticks) for periodic instances.
</span>   818    <span class="xdoc">     *
</span>   819    <span class="xdoc">     *  The default value of this parameter is 0, which indicates this is
</span>   820    <span class="xdoc">     *  a one-shot Clock object.
</span>   821    <span class="xdoc">     *
</span>   822    <span class="xdoc">     *  A non zero value for this parameter specifies that the Clock
</span>   823    <span class="xdoc">     *  object is to be called periodically, and also specifies the
</span>   824    <span class="xdoc">     *  rate (in Clock ticks) that the Clock function will be called
</span>   825    <span class="xdoc">     *  AFTER the initial 'timeout' argument period.
</span>   826    <span class="xdoc">     *
</span>   827    <span class="xdoc">     *  For one-shot Clock instances, this parameter must be set to zero.
</span>   828    <span class="xdoc">     */</span>
   829        <span class=key>config</span> UInt32 period = 0;
   830    
   831        <span class="xdoc">/*!
</span>   832    <span class="xdoc">     *  ======== arg ========
</span>   833    <span class="xdoc">     *  Uninterpreted argument passed to instance function
</span>   834    <span class="xdoc">     *
</span>   835    <span class="xdoc">     *  The default is null.
</span>   836    <span class="xdoc">     */</span>
   837        <span class=key>config</span> UArg arg = <span class=key>null</span>;
   838    
   839        <span class="xdoc">/*!
</span>   840    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   841    <span class="xdoc">     *  ======== addI ========
</span>   842    <span class="xdoc">     *  Lightweight One-Shot Clock create for internal SYS/BIOS timeout APIs
</span>   843    <span class="xdoc">     *  Does NOT start the timeout (ie requires Clock_startI() to be called)
</span>   844    <span class="xdoc">     *  Does NOT assume Hwis are disabled
</span>   845    <span class="xdoc">     */</span>
   846        Void addI(FuncPtr clockFxn, UInt32 timeout, UArg arg);
   847    
   848        <span class="xdoc">/*!
</span>   849    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   850    <span class="xdoc">     *  ======== removeI ========
</span>   851    <span class="xdoc">     *  Lightweight Clock delete for internal SYS/BIOS timeout APIs
</span>   852    <span class="xdoc">     *  Assumes Hwis are disabled
</span>   853    <span class="xdoc">     */</span>
   854        Void removeI();
   855    
   856        <span class="xdoc">/*!
</span>   857    <span class="xdoc">     *  ======== start ========
</span>   858    <span class="xdoc">     *  Start instance
</span>   859    <span class="xdoc">     *
</span>   860    <span class="xdoc">     *  The {<b>@link</b> #timeout} and {<b>@link</b> #period} values set during create()
</span>   861    <span class="xdoc">     *  or by calling Clock_setTimeout() and Clock_setPeriod() are used and
</span>   862    <span class="xdoc">     *  the expiry is recomputed.
</span>   863    <span class="xdoc">     *  Note that for periodic instances, the first expiry is
</span>   864    <span class="xdoc">     *  computed using the timeout specified. All subsequent expiries use the
</span>   865    <span class="xdoc">     *  period value.
</span>   866    <span class="xdoc">     *
</span>   867    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   868    <span class="xdoc">     *  Timeout of instance cannot be zero
</span>   869    <span class="xdoc">     */</span>
   870        Void start();
   871    
   872        <span class="xdoc">/*!
</span>   873    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   874    <span class="xdoc">     *  ======== startI ========
</span>   875    <span class="xdoc">     *  Internal start function which assumes Hwis disabled
</span>   876    <span class="xdoc">     */</span>
   877        Void startI();
   878    
   879        <span class="xdoc">/*!
</span>   880    <span class="xdoc">     *  ======== stop ========
</span>   881    <span class="xdoc">     *  Stop instance
</span>   882    <span class="xdoc">     */</span>
   883        Void stop();
   884    
   885        <span class="xdoc">/*!
</span>   886    <span class="xdoc">     *  ======== setPeriod ========
</span>   887    <span class="xdoc">     *  Set periodic interval
</span>   888    <span class="xdoc">     *
</span>   889    <span class="xdoc">     *  <b>@param(period)</b>          periodic interval in Clock ticks
</span>   890    <span class="xdoc">     *
</span>   891    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   892    <span class="xdoc">     *  Cannot change period of instance that has been started.
</span>   893    <span class="xdoc">     */</span>
   894        Void setPeriod(UInt32 period);
   895    
   896        <span class="xdoc">/*!
</span>   897    <span class="xdoc">     *  ======== setTimeout ========
</span>   898    <span class="xdoc">     *  Set the initial timeout
</span>   899    <span class="xdoc">     *
</span>   900    <span class="xdoc">     *  <b>@param(timeout)</b>         initial timeout in Clock ticks
</span>   901    <span class="xdoc">     *
</span>   902    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   903    <span class="xdoc">     *  Cannot change the initial timeout of instance that has been started.
</span>   904    <span class="xdoc">     */</span>
   905        Void setTimeout(UInt32 timeout);
   906    
   907        <span class="xdoc">/*!
</span>   908    <span class="xdoc">     *  ======== setFunc ========
</span>   909    <span class="xdoc">     *  Overwrite Clock function and arg
</span>   910    <span class="xdoc">     *
</span>   911    <span class="xdoc">     *  Replaces a Clock object's clockFxn function originally
</span>   912    <span class="xdoc">     *  provided in {<b>@link</b> #create}.
</span>   913    <span class="xdoc">     *
</span>   914    <span class="xdoc">     *  <b>@param(clockFxn)</b>        function of type FuncPtr
</span>   915    <span class="xdoc">     *  <b>@param(arg)</b>             argument to clockFxn
</span>   916    <span class="xdoc">     *
</span>   917    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   918    <span class="xdoc">     *  Cannot change function and arg of Clock object that has been started.
</span>   919    <span class="xdoc">     */</span>
   920        Void setFunc(FuncPtr fxn, UArg arg);
   921    
   922        <span class="xdoc">/*!
</span>   923    <span class="xdoc">     *  ======== getPeriod ========
</span>   924    <span class="xdoc">     *  Get period of instance
</span>   925    <span class="xdoc">     *
</span>   926    <span class="xdoc">     *  Returns the period of an instance.
</span>   927    <span class="xdoc">     *
</span>   928    <span class="xdoc">     *  <b>@b(returns)</b>             returns periodic interval in Clock ticks
</span>   929    <span class="xdoc">     */</span>
   930        UInt32 getPeriod();
   931    
   932        <span class="xdoc">/*!
</span>   933    <span class="xdoc">     *  ======== getTimeout ========
</span>   934    <span class="xdoc">     *  Get timeout of instance
</span>   935    <span class="xdoc">     *
</span>   936    <span class="xdoc">     *  Returns the remaining time if the instance is active; if the instance
</span>   937    <span class="xdoc">     *  is not active, returns zero.
</span>   938    <span class="xdoc">     *
</span>   939    <span class="xdoc">     *  <b>@b(returns)</b>             returns timeout in clock ticks
</span>   940    <span class="xdoc">     */</span>
   941        UInt32 getTimeout();
   942    
   943        <span class="xdoc">/*!
</span>   944    <span class="xdoc">     *  ======== isActive ========
</span>   945    <span class="xdoc">     *  Determine if Clock object is currently active (ie running)
</span>   946    <span class="xdoc">     *
</span>   947    <span class="xdoc">     *  Returns TRUE if Clock object is currently active
</span>   948    <span class="xdoc">     *
</span>   949    <span class="xdoc">     *  <b>@b(returns)</b>             returns active state
</span>   950    <span class="xdoc">     */</span>
   951        Bool isActive();
   952    
   953    <span class=key>internal</span>:
   954    
   955        <span class="comment">/*
</span>   956    <span class="comment">     * ======== timerSupportsDynamic ========
</span>   957    <span class="comment">     * used in Clock.xml to enable/disable tickMode setting
</span>   958    <span class="comment">     */</span>
   959        <span class=key>metaonly</span> <span class=key>config</span> Bool timerSupportsDynamic = <span class=key>false</span>;
   960    
   961        <span class="comment">/*
</span>   962    <span class="comment">     *  ======== doTickFunc =======
</span>   963    <span class="comment">     *  access doTick through a func ptr so that
</span>   964    <span class="comment">     *  ROM'd BIOS code doesn't reference a generated function.
</span>   965    <span class="comment">     */</span>
   966        <span class=key>config</span> Void (*doTickFunc)(UArg);
   967    
   968        <span class="xdoc">/*!
</span>   969    <span class="xdoc">     *  ======== doTick ========
</span>   970    <span class="xdoc">     *  Function called by the timer interrupt handler
</span>   971    <span class="xdoc">     *
</span>   972    <span class="xdoc">     *  <b>@param(arg)</b>     Unused. Required to match signature of Hwi.FuncPtr
</span>   973    <span class="xdoc">     */</span>
   974        Void doTick(UArg arg);
   975    
   976        <span class="comment">/*
</span>   977    <span class="comment">     *  ======== triggerClock ========
</span>   978    <span class="comment">     *  Special Clock object created when Clock.stopCheckNext is 'true'.
</span>   979    <span class="comment">     */</span>
   980        <span class=key>config</span> Clock.Handle triggerClock;
   981    
   982        <span class="comment">/*
</span>   983    <span class="comment">     *  ======== triggerFunc ========
</span>   984    <span class="comment">     *  Empty function used by Clock.triggerClock
</span>   985    <span class="comment">     */</span>
   986        Void triggerFunc(UArg arg);
   987    
   988        <span class="comment">/*
</span>   989    <span class="comment">     *  ======== Instance_State ========
</span>   990    <span class="comment">     */</span>
   991        <span class=key>struct</span> Instance_State {
   992            Queue.Elem      elem;           <span class=comment>// required for clock queue</span>
   993            UInt32          timeout;        <span class=comment>// in clock ticks</span>
   994            UInt32          currTimeout;    <span class=comment>// working timeout</span>
   995            UInt32          period;         <span class=comment>// periodic instance if &gt; 0</span>
   996            volatile Bool   active;         <span class=comment>// active/idle flag</span>
   997            FuncPtr         fxn;            <span class=comment>// instance function</span>
   998            UArg            arg;            <span class=comment>// function arg</span>
   999        };
  1000    
  1001        <span class="comment">/*
</span>  1002    <span class="comment">     *  ======== Module_State ========
</span>  1003    <span class="comment">     */</span>
  1004        <span class=key>struct</span> Module_State {
  1005            volatile UInt32     ticks;          <span class=comment>// last tick serviced</span>
  1006            UInt                swiCount;       <span class=comment>// num of Swi posts before Swi runs</span>
  1007            TimerProxy.Handle   timer;          <span class=comment>// timer used</span>
  1008                                                <span class=comment>// points to generated Clock_doTick()</span>
  1009            Queue.Object        clockQ;         <span class=comment>// clock que</span>
  1010            Swi.Handle          swi;            <span class=comment>// clock swi</span>
  1011            volatile UInt       numTickSkip;    <span class=comment>// number of ticks being suppressed</span>
  1012            UInt32              nextScheduledTick;
  1013            UInt32              maxSkippable;   <span class=comment>// timer dependent (in tickPeriods)</span>
  1014            Bool                inWorkFunc;     <span class=comment>// true if in Clock Swi servicing Q</span>
  1015            volatile Bool       startDuringWorkFunc; <span class=comment>// Clock_start during workFunc?</span>
  1016            Bool                ticking;        <span class=comment>// set true during first Clock tick</span>
  1017        };
  1018    }
</pre>
</body></html>
