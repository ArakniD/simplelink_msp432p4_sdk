<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.uia.runtime.ServiceMgr</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2012, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> * */</span>
    32    
    33    <span class="comment">/*
</span>    34    <span class="comment"> *  ======== ServiceMgr.xdc ========
</span>    35    <span class="comment"> */</span>
    36    
    37    import xdc.runtime.Assert;
    38    import xdc.rov.ViewInfo;
    39    
    40    <span class="xdoc">/*!
</span>    41    <span class="xdoc"> *  ======== ServiceMgr ========
</span>    42    <span class="xdoc"> *  Module that manages UIA Services
</span>    43    <span class="xdoc"> *
</span>    44    <span class="xdoc"> *  The ServiceMgr module manages all the UIA Services. The ServiceMgr module
</span>    45    <span class="xdoc"> *  itself can be plugged with different low level transport functions to
</span>    46    <span class="xdoc"> *  support different methods for getting information between the target
</span>    47    <span class="xdoc"> *  and instrumentation host. Some of these methods (e.g. File) only support
</span>    48    <span class="xdoc"> *  sending information from the target to the host. They do not support
</span>    49    <span class="xdoc"> *  sending information from the host to the target.
</span>    50    <span class="xdoc"> *
</span>    51    <span class="xdoc"> *  The ServiceMgr module also supports two different topologies.
</span>    52    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    53    <span class="xdoc"> *      - Topology_SINGLECORE: Each core on the device communicates
</span>    54    <span class="xdoc"> *        directly the instrumentation host.
</span>    55    <span class="xdoc"> *      - Topology_MULTICORE: Only one core (i.e. master)
</span>    56    <span class="xdoc"> *        communicates with the instrumentation host. Communication
</span>    57    <span class="xdoc"> *        with other cores are routed to the via the master core.
</span>    58    <span class="xdoc"> *        The master core is determined by the {<b>@link</b> #masterProcId}
</span>    59    <span class="xdoc"> *        parameter. The routing is done via Ipc's MessageQ module.
</span>    60    <span class="xdoc"> *        Note: ServiceMgr is a user of Ipc and depends on the
</span>    61    <span class="xdoc"> *        application to configure and initialize Ipc.
</span>    62    <span class="xdoc"> *  <b>@p</b>
</span>    63    <span class="xdoc"> *
</span>    64    <span class="xdoc"> *  There are two different uses of the ServiceMgr module:
</span>    65    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    66    <span class="xdoc"> *      - Applications (configuration only)
</span>    67    <span class="xdoc"> *      - Services
</span>    68    <span class="xdoc"> *  <b>@p</b>
</span>    69    <span class="xdoc"> *
</span>    70    <span class="xdoc"> *  <b>@p(html)</b>
</span>    71    <span class="xdoc"> *  &lt;B&gt;Applications&lt;/B&gt;
</span>    72    <span class="xdoc"> *  <b>@p</b>
</span>    73    <span class="xdoc"> *  The ServiceMgr module contains the generic configuration.
</span>    74    <span class="xdoc"> *  Many of these configuration values change
</span>    75    <span class="xdoc"> *  depending on the device. The ServiceMgr module uses the
</span>    76    <span class="xdoc"> *  ti.uia.family.Settings module to fill in values if they are not set by
</span>    77    <span class="xdoc"> *  the application.
</span>    78    <span class="xdoc"> *
</span>    79    <span class="xdoc"> *  The ServiceMgr does expose many configuration parameters to allow users
</span>    80    <span class="xdoc"> *  to modify the default behavior.
</span>    81    <span class="xdoc"> *
</span>    82    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    83    <span class="xdoc"> *      - Topology: UIA is shipped with support for two different topologies:
</span>    84    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    85    <span class="xdoc"> *          - Topology_SINGLECORE: Each core on the device communicates
</span>    86    <span class="xdoc"> *               directly the instrumentation host.
</span>    87    <span class="xdoc"> *          - Topology_MULTICORE: Only one core (i.e. master)
</span>    88    <span class="xdoc"> *               communicates with the instrumentation host. Communication
</span>    89    <span class="xdoc"> *               with other cores are routed to the via the master core.
</span>    90    <span class="xdoc"> *               The master core is determined by the {<b>@link</b> #masterProcId}
</span>    91    <span class="xdoc"> *               parameter. The routing is done via Ipc's MessageQ module.
</span>    92    <span class="xdoc"> *               Note: ServiceMgr is a user of Ipc and depends on the
</span>    93    <span class="xdoc"> *               application to configure and initialize Ipc.
</span>    94    <span class="xdoc"> *  <b>@p</b>
</span>    95    <span class="xdoc"> *
</span>    96    <span class="xdoc"> *      - Transport: The ServiceMgr has  pluggable transport functions. The
</span>    97    <span class="xdoc"> *               determination of the transport is accomplished via the
</span>    98    <span class="xdoc"> *               {<b>@link</b> #transportType} parameter. The parameter is defaulted
</span>    99    <span class="xdoc"> *               based on the device is not explicitly set.
</span>   100    <span class="xdoc"> *
</span>   101    <span class="xdoc"> *      - Packets: UIA makes a distinction between event and messages packets.
</span>   102    <span class="xdoc"> *                 Events packets are generally bigger to hold many event
</span>   103    <span class="xdoc"> *                 records. The size and number of these packets are defaulted
</span>   104    <span class="xdoc"> *                 by UIA based on the transport and device. However the number
</span>   105    <span class="xdoc"> *                 of event packets might need to be increased on a multicore
</span>   106    <span class="xdoc"> *                 device with heavy event record load.
</span>   107    <span class="xdoc"> *                 {<b>@link</b> #numEventPacketBufs} can be increased in this case.
</span>   108    <span class="xdoc"> *
</span>   109    <span class="xdoc"> *      - Tasks: The ServiceMgr module might have up to two tasks:
</span>   110    <span class="xdoc"> *               transfer agent task and receive task. The receive task only
</span>   111    <span class="xdoc"> *               recieves control messages from the instrumentation host and
</span>   112    <span class="xdoc"> *               forwards it on the the transfer agent task.
</span>   113    <span class="xdoc"> *               The transfer agent task is responsible for everything else
</span>   114    <span class="xdoc"> *               (e.g. period management, event collection, communicating with
</span>   115    <span class="xdoc"> *               remote cores in a multicore configuration, sending UIA Packets
</span>   116    <span class="xdoc"> *               to the instrumentation host, etc.).
</span>   117    <span class="xdoc"> *
</span>   118    <span class="xdoc"> *               The application can specify the stack sizes and placement of
</span>   119    <span class="xdoc"> *               these task via the ServiceMgr.
</span>   120    <span class="xdoc"> *
</span>   121    <span class="xdoc"> *               If there is only one task needed, the parameters for the
</span>   122    <span class="xdoc"> *               receive task is ignored.
</span>   123    <span class="xdoc"> *  <b>@p</b>
</span>   124    <span class="xdoc"> *
</span>   125    <span class="xdoc"> *  <b>@p(html)</b>
</span>   126    <span class="xdoc"> *  &lt;B&gt;Services&lt;/B&gt;
</span>   127    <span class="xdoc"> *  <b>@p</b>
</span>   128    <span class="xdoc"> *  All services must register with the ServiceMgr module via the
</span>   129    <span class="xdoc"> *  {<b>@link</b> #register} function. Each service
</span>   130    <span class="xdoc"> *  must have a unique service id (the first 3 are reserved). The service id
</span>   131    <span class="xdoc"> *  is obtained via the encoded type ServiceIdDesc.
</span>   132    <span class="xdoc"> *
</span>   133    <span class="xdoc"> *  From the service's standpoint, the ServiceMgr module manages all the
</span>   134    <span class="xdoc"> *  buffers for sending and receive messages and events. The services need
</span>   135    <span class="xdoc"> *  to obtain packets from the ServiceMgr via the {<b>@link</b> #getFreePacket}
</span>   136    <span class="xdoc"> *  function. To send a packet, the service must call the
</span>   137    <span class="xdoc"> *  {<b>@link</b> #sendPacket} function.
</span>   138    <span class="xdoc"> *
</span>   139    <span class="xdoc"> *  All data send and received by a service must be contained in a
</span>   140    <span class="xdoc"> *  {<b>@link</b> UIAPacket} header. Refer to this module for more details.
</span>   141    <span class="xdoc"> *
</span>   142    <span class="xdoc"> *  From the service's standpoint, the ServiceMgr module also manages the
</span>   143    <span class="xdoc"> *  the period of service. Each service can request the interval at which
</span>   144    <span class="xdoc"> *  the ServiceMgr calls the service's {<b>@link</b> #ProcessCallback} to send out
</span>   145    <span class="xdoc"> *  events. This interval can be set by the service via the {<b>@link</b> #register}
</span>   146    <span class="xdoc"> *  function. If during runtime the service wants to change it period, it
</span>   147    <span class="xdoc"> *  can call {<b>@link</b> #setPeriod}.
</span>   148    <span class="xdoc"> */</span>
   149    @CustomHeader
   150    <span class=key>module</span> ServiceMgr
   151    {
   152        <span class="xdoc">/*!
</span>   153    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   154    <span class="xdoc">     *  ======== ModuleView ========
</span>   155    <span class="xdoc">     */</span>
   156        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   157            Int        periodInMs;
   158            Bool       supportControl;
   159            String     topology;
   160            Int        numServices;
   161            Int        masterProcId;
   162            Int        runCount;
   163            <span class=comment>//string     masterRunning; //TODO SDOCM00077324</span>
   164        }
   165    
   166        <span class="xdoc">/*!
</span>   167    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   168    <span class="xdoc">     *  ======== PacketView ========
</span>   169    <span class="xdoc">     */</span>
   170        <span class=key>metaonly</span> <span class=key>struct</span> PacketView {
   171            SizeT      maxEventPacketSize;
   172            Int        numEventPacketBufs;
   173            SizeT      maxCtrlPacketSize;
   174            Int        numOutgoingCtrlPacketBufs;
   175            Int        numIncomingCtrlPacketBufs;
   176        }
   177    
   178        <span class="xdoc">/*!
</span>   179    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   180    <span class="xdoc">     *  ======== TransportView ========
</span>   181    <span class="xdoc">     */</span>
   182        <span class=key>metaonly</span> <span class=key>struct</span> TransportView {
   183            String     initFxn;
   184            String     startFxn;
   185            String     recvFxn;
   186            String     sendFxn;
   187            String     stopFxn;
   188            String     exitFxn;
   189        }
   190    
   191        <span class="xdoc">/*!
</span>   192    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   193    <span class="xdoc">     *  ======== StatisticsView ========
</span>   194    <span class="xdoc">     */</span>
   195        <span class=key>metaonly</span> <span class=key>struct</span> StatisticsView {
   196            Int     numEventPacketsSent;
   197            Int     numEventPacketsFailed;
   198            Int     numMsgPacketsSent;
   199            Int     numMsgPacketsFailed;
   200        }
   201    
   202        <span class="xdoc">/*!
</span>   203    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   204    <span class="xdoc">     *  ======== rovViewInfo ========
</span>   205    <span class="xdoc">     */</span>
   206        @Facet
   207        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo =
   208            ViewInfo.create({
   209                viewMap: [
   210                    [<span class="string">'Module'</span>,
   211                        {
   212                            type: ViewInfo.MODULE,
   213                            viewInitFxn: <span class="string">'viewInitModule'</span>,
   214                            structName: <span class="string">'ModuleView'</span>
   215                        }
   216                    ],
   217                    <span class=comment>// SDOCM00077324</span>
   218                    <span class=comment>// ServiceMgr's ROV should obtain information from proxies</span>
   219                    <span class=comment>//['Statistics',</span>
   220                    <span class=comment>//    {</span>
   221                    <span class=comment>//        type: ViewInfo.MODULE,</span>
   222                    <span class=comment>//        viewInitFxn: 'viewInitStats',</span>
   223                    <span class=comment>//        structName: 'StatisticsView'</span>
   224                    <span class=comment>//    }</span>
   225                    <span class=comment>//],</span>
   226                    [<span class="string">'Transport'</span>,
   227                        {
   228                            type: ViewInfo.MODULE,
   229                            viewInitFxn: <span class="string">'viewInitTransport'</span>,
   230                            structName: <span class="string">'TransportView'</span>
   231                        }
   232                    ],
   233                    [<span class="string">'Packet'</span>,
   234                        {
   235                            type: ViewInfo.MODULE,
   236                            viewInitFxn: <span class="string">'viewInitPacket'</span>,
   237                            structName: <span class="string">'PacketView'</span>
   238                        }
   239                    ],
   240                ]
   241            });
   242    
   243        <span class="xdoc">/*!
</span>   244    <span class="xdoc">     *  ======== Reason ========
</span>   245    <span class="xdoc">     *  Used in the ProcessCallback to denote the reason
</span>   246    <span class="xdoc">     *
</span>   247    <span class="xdoc">     *  ServiceMgr_Reason_PERIODEXPIRED: the {<b>@link</b> #ProcessCallback} is being
</span>   248    <span class="xdoc">     *  called because it is time to collect events and send them.
</span>   249    <span class="xdoc">     *
</span>   250    <span class="xdoc">     *  ServiceMgr_Reason_REQUESTENERGY: the {<b>@link</b> #ProcessCallback} is being
</span>   251    <span class="xdoc">     *  called because the service requested energy to perform some action.
</span>   252    <span class="xdoc">     *
</span>   253    <span class="xdoc">     *  ServiceMgr_Reason_INCOMINGMSG: the {<b>@link</b> #ProcessCallback} is being
</span>   254    <span class="xdoc">     *  called because there is an incoming message for the service.
</span>   255    <span class="xdoc">     */</span>
   256        <span class=key>enum</span> Reason {
   257            Reason_PERIODEXPIRED,
   258            Reason_REQUESTENERGY,
   259            Reason_INCOMINGMSG
   260        };
   261    
   262        <span class="xdoc">/*!
</span>   263    <span class="xdoc">     *  ======== Topology ========
</span>   264    <span class="xdoc">     *  Used to define UIA topology.
</span>   265    <span class="xdoc">     *
</span>   266    <span class="xdoc">     *  If UIA is configured for multicore, all events and messages are routed
</span>   267    <span class="xdoc">     *  via the master core to the non-master cores. Choosing multicore requires
</span>   268    <span class="xdoc">     *  setting the {<b>@link</b> #master} config.
</span>   269    <span class="xdoc">     *
</span>   270    <span class="xdoc">     *  If UIA is configured for Topology_SINGLECORE, each core on the device
</span>   271    <span class="xdoc">     *  communicates with the instrumentation host directly.
</span>   272    <span class="xdoc">     */</span>
   273        <span class=key>enum</span> Topology {
   274            Topology_SINGLECORE,
   275            Topology_MULTICORE
   276        };
   277    
   278        <span class="xdoc">/*!
</span>   279    <span class="xdoc">     *  ======== TransportType ========
</span>   280    <span class="xdoc">     *  Used to specify the type of transport for UIA to use.
</span>   281    <span class="xdoc">     *
</span>   282    <span class="xdoc">     *  TransportType defines what the underlying transport will be used. In
</span>   283    <span class="xdoc">     *  a multi-core topology, this parameter is only relevant for the
</span>   284    <span class="xdoc">     *  {<b>@link</b> #masterProcId} core. The masterProcId core uses the TransportType
</span>   285    <span class="xdoc">     *  to determine how to get the data off the target.
</span>   286    <span class="xdoc">     *
</span>   287    <span class="xdoc">     *  <b>@p(blist)</b>
</span>   288    <span class="xdoc">     *  -TransportType_ETHERNET: Use the Ethernet transport. On a SYS/BIOS
</span>   289    <span class="xdoc">     *      system, this uses the NDK. The application is responsible for
</span>   290    <span class="xdoc">     *      adding the NDK into the application and initializing it.
</span>   291    <span class="xdoc">     *  -TransportType_FILE: Use the File transport.
</span>   292    <span class="xdoc">     *      On a SYS/BIOS system, this transport requires a JTAG connection.
</span>   293    <span class="xdoc">     *  -TransportType_USER: This allows the application to specify their
</span>   294    <span class="xdoc">     *      own transport functions.
</span>   295    <span class="xdoc">     *  -TransportType_NULL: No transport functions are needed. This should
</span>   296    <span class="xdoc">     *      only be used on the non-masterProcId cores.
</span>   297    <span class="xdoc">     *  <b>@p</b>
</span>   298    <span class="xdoc">     */</span>
   299        <span class=key>metaonly</span> <span class=key>enum</span> TransportType {
   300            TransportType_ETHERNET,
   301            TransportType_FILE,
   302            TransportType_USER,
   303            TransportType_NULL
   304        };
   305    
   306        <span class="xdoc">/*!
</span>   307    <span class="xdoc">     *  ======== ProcessCallback ========
</span>   308    <span class="xdoc">     *  Function prototype for the processMsg callback
</span>   309    <span class="xdoc">     *
</span>   310    <span class="xdoc">     *  A ProcessCallback function must be supplied by every service.
</span>   311    <span class="xdoc">     *  The function is provided in the {<b>@link</b> #register} function.
</span>   312    <span class="xdoc">     *
</span>   313    <span class="xdoc">     *  For a description of the ServiceMgr_Reason parameter, please refer
</span>   314    <span class="xdoc">     *  to {<b>@link</b> #Reason}.
</span>   315    <span class="xdoc">     *
</span>   316    <span class="xdoc">     *  The UIPacket_Hdr field is only used in the {<b>@link</b> #Reason_INCOMINGMSG}
</span>   317    <span class="xdoc">     *  case. For any other reason, this value is NULL.
</span>   318    <span class="xdoc">     */</span>
   319        <span class=key>typedef</span> Void (*ProcessCallback)(Reason, UIAPacket.Hdr *);
   320    
   321        <span class="xdoc">/*!
</span>   322    <span class="xdoc">     *  ======== WAIT_FOREVER ========
</span>   323    <span class="xdoc">     *  Wait forever constant that can be used in ServiceMgr_getFreePacket.
</span>   324    <span class="xdoc">     */</span>
   325        <span class=key>const</span> UInt WAIT_FOREVER = ~(0);
   326    
   327        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
   328        <span class=key>metaonly</span> <span class=key>struct</span> ServiceIdDesc { Bits16 val; };
   329    
   330        <span class="xdoc">/*!
</span>   331    <span class="xdoc">     *  ======== ServiceId ========
</span>   332    <span class="xdoc">     *  Used by services to generate a serviceId
</span>   333    <span class="xdoc">     *
</span>   334    <span class="xdoc">     *  Services needs to define a ServiceId in their xdc file.
</span>   335    <span class="xdoc">     *  Then the ServiceMgr module will assign a unique value to it during
</span>   336    <span class="xdoc">     *  build time.
</span>   337    <span class="xdoc">     *
</span>   338    <span class="xdoc">     *  For example in ti.uia.service.Rta.xdc there is the following line:
</span>   339    <span class="xdoc">     *  <b>@p(code)</b>
</span>   340    <span class="xdoc">     *  readonly config ServiceMgr.ServiceId SERVICEID;
</span>   341    <span class="xdoc">     *  <b>@p</b>
</span>   342    <span class="xdoc">     */</span>
   343        @Encoded <span class=key>typedef</span> ServiceIdDesc ServiceId;     <span class="xdoc">/*! Control command type */</span>
   344    
   345        <span class="xdoc">/*!
</span>   346    <span class="xdoc">     *  Assert raised when calling API with invalid ServiceId
</span>   347    <span class="xdoc">     */</span>
   348        <span class=key>config</span> Assert.Id A_invalidServiceId  = {
   349            msg: <span class="string">"A_invalidServiceId: ServiceId out of range"</span>
   350        };
   351    
   352        <span class="xdoc">/*!
</span>   353    <span class="xdoc">     *  Assert raised invalid processCallbackFxn is supplied
</span>   354    <span class="xdoc">     */</span>
   355        <span class=key>config</span> Assert.Id A_invalidProcessCallbackFxn  = {
   356            msg: <span class="string">"A_invalidProcessCallbackFxn: Callback cannot be NULL"</span>
   357        };
   358    
   359        <span class="xdoc">/*!
</span>   360    <span class="xdoc">     *  ======== customTransportType ========
</span>   361    <span class="xdoc">     *  Custom transport used to send the records to an instrumentation host
</span>   362    <span class="xdoc">     */</span>
   363        <span class=key>metaonly</span> <span class=key>config</span> String customTransportType = <span class=key>null</span>;
   364    
   365        <span class="xdoc">/*!
</span>   366    <span class="xdoc">     *  ======== transportFxns ========
</span>   367    <span class="xdoc">     *  Transport functions used to communicate to the instrumentation host
</span>   368    <span class="xdoc">     *
</span>   369    <span class="xdoc">     *  These functions are setup by default based on the device.
</span>   370    <span class="xdoc">     *  The user can explicitly set this parameter if the default is not
</span>   371    <span class="xdoc">     *  appropriate.
</span>   372    <span class="xdoc">     */</span>
   373        <span class=key>config</span> Transport.FxnSet transportFxns;
   374    
   375        <span class="xdoc">/*!
</span>   376    <span class="xdoc">     *  ======== topology ========
</span>   377    <span class="xdoc">     *  Used to define UIA topology.
</span>   378    <span class="xdoc">     *
</span>   379    <span class="xdoc">     *  If `Topology_MULTICORE` is chosen, the ServiceMgr will use Ipc to
</span>   380    <span class="xdoc">     *  discover the core configuration and to communicate between the cores.
</span>   381    <span class="xdoc">     *  UIA will route the outbound packets from each core through the master
</span>   382    <span class="xdoc">     *  core. UIA will also route messages received by the master core to
</span>   383    <span class="xdoc">     *  their intended recipient.
</span>   384    <span class="xdoc">     *
</span>   385    <span class="xdoc">     *  If UIA is configured for Topology_SINGLECORE, each core on the device
</span>   386    <span class="xdoc">     *  communicates with the instrumentation host directly.
</span>   387    <span class="xdoc">     *
</span>   388    <span class="xdoc">     *  The default is Topology_SINGLECORE.
</span>   389    <span class="xdoc">     */</span>
   390        <span class=key>config</span> Topology topology = Topology_SINGLECORE;
   391    
   392        <span class="xdoc">/*!
</span>   393    <span class="xdoc">     *  ======== transportType ========
</span>   394    <span class="xdoc">     *  Determines the transport that UIA will be configured for.
</span>   395    <span class="xdoc">     *
</span>   396    <span class="xdoc">     *  For a given transport type, UIA picks an appropriate transport
</span>   397    <span class="xdoc">     *  implementation to use based on your device. This is specified by the
</span>   398    <span class="xdoc">     *  ti.uia.family.Settings module. Refer to the examples for configuring
</span>   399    <span class="xdoc">     *  the actual transport implementation.
</span>   400    <span class="xdoc">     *
</span>   401    <span class="xdoc">     *  If someone writes an new transport (e.g. RapidIO),
</span>   402    <span class="xdoc">     *  they can be plugged in by setting the TransportType
</span>   403    <span class="xdoc">     *  to `TransportType_USER` and then plugging
</span>   404    <span class="xdoc">     *  the transportFxns manually. It must also set up the following parameters
</span>   405    <span class="xdoc">     *  as directed by the new transport developer.
</span>   406    <span class="xdoc">     *  <b>@p(blist)</b>
</span>   407    <span class="xdoc">     *  -ServiceMgr.supportControl: does the transport support receiving
</span>   408    <span class="xdoc">     *               messages from the host. For example TransportFile does not.
</span>   409    <span class="xdoc">     *  -ServiceMgr.maxEventPacketSize: Max size of an outgoing event packet. For
</span>   410    <span class="xdoc">     *               example TransportNdk uses 1472 (emac size minus headers)
</span>   411    <span class="xdoc">     *  -ServiceMgr.maxCtrlPacketSize: Max size of the message packets. This can
</span>   412    <span class="xdoc">     *               be zero if supportControl is false.
</span>   413    <span class="xdoc">     *  <b>@p</b>
</span>   414    <span class="xdoc">     *
</span>   415    <span class="xdoc">     *  Here is an example of plugging the transport XYZ into the ServiceMgr:
</span>   416    <span class="xdoc">     *  <b>@p(code)</b>
</span>   417    <span class="xdoc">     *  var ServiceMgr = xdc.useModule('ti.uia.runtime.ServiceMgr');
</span>   418    <span class="xdoc">     *  ServiceMgr.transportType = ServiceMgr.TransportType_USER;
</span>   419    <span class="xdoc">     *  var xyzTransport = {
</span>   420    <span class="xdoc">     *      initFxn: '&amp;TransportXYZ_init',
</span>   421    <span class="xdoc">     *      startFxn: '&amp;TransportXYZ_start',
</span>   422    <span class="xdoc">     *      recvFxn: '&amp;TransportXYZ_recv',
</span>   423    <span class="xdoc">     *      sendFxn: '&amp;TransportXYZ_send',
</span>   424    <span class="xdoc">     *      stopFxn: '&amp;TransportXYZ_stop',
</span>   425    <span class="xdoc">     *      exitFxn: '&amp;TransportXYZ_exit'
</span>   426    <span class="xdoc">     *  };
</span>   427    <span class="xdoc">     *  ServiceMgr.transportFxns = xyzTransport;
</span>   428    <span class="xdoc">     *
</span>   429    <span class="xdoc">     *  ServiceMgr.maxEventPacketSize = 1024
</span>   430    <span class="xdoc">     *  ServiceMgr.maxCtrlPacketSize  = 1024;
</span>   431    <span class="xdoc">     *  ServiceMgr.supportControl     = true;
</span>   432    <span class="xdoc">     *  <b>@p</b>
</span>   433    <span class="xdoc">     */</span>
   434        <span class=key>metaonly</span> <span class=key>config</span> TransportType transportType;
   435    
   436        <span class="xdoc">/*!
</span>   437    <span class="xdoc">     *  ======== periodInMs ========
</span>   438    <span class="xdoc">     *  Period in miliseconds of ServiceMgr's transfer agent
</span>   439    <span class="xdoc">     *
</span>   440    <span class="xdoc">     *  The transfer agent runs at the configured period. It checks to see
</span>   441    <span class="xdoc">     *  if a service's period has expired. If it has expired, the service's
</span>   442    <span class="xdoc">     *  {<b>@link</b> #ProcessCallback} is called with the
</span>   443    <span class="xdoc">     *  {<b>@link</b> #Reason_PERIODEXPIRED} reason.
</span>   444    <span class="xdoc">     *
</span>   445    <span class="xdoc">     *  A service should not set it's period to a value less than the ServiceMgr
</span>   446    <span class="xdoc">     *  module'speriod. A service's period should be a multiple of the
</span>   447    <span class="xdoc">     *  ServiceMgr module's period. If it is not, it will called at the rounded
</span>   448    <span class="xdoc">     *  up period. For example, if ServiceMgr.periodInMs = 100 and a service
</span>   449    <span class="xdoc">     *  sets its period to 250. That service will be called every 300
</span>   450    <span class="xdoc">     *  milliseconds.
</span>   451    <span class="xdoc">     *
</span>   452    <span class="xdoc">     *  This value does not guarantee that the transfer agent will run at this
</span>   453    <span class="xdoc">     *  rate. Even if the period has expired, the transfer agent will not run
</span>   454    <span class="xdoc">     *  until the current running Task has yielded and there are no other higher
</span>   455    <span class="xdoc">     *  priority Tasks ready.
</span>   456    <span class="xdoc">     *
</span>   457    <span class="xdoc">     *  Default is 100ms.
</span>   458    <span class="xdoc">     */</span>
   459        <span class=key>config</span> Int periodInMs = 100;
   460    
   461        <span class="xdoc">/*!
</span>   462    <span class="xdoc">     *  ======== maxEventPacketSize  ========
</span>   463    <span class="xdoc">     *  Size of Event packets in bytes
</span>   464    <span class="xdoc">     *
</span>   465    <span class="xdoc">     *  This size includes the UIAPacket header. This value's default
</span>   466    <span class="xdoc">     *  depends on the device.
</span>   467    <span class="xdoc">     */</span>
   468        <span class=key>config</span> SizeT maxEventPacketSize;
   469    
   470        <span class="xdoc">/*!
</span>   471    <span class="xdoc">     *  ======== numEventPacketBufs  ========
</span>   472    <span class="xdoc">     *  Number of UIAPacket events on the processor
</span>   473    <span class="xdoc">     */</span>
   474        <span class=key>config</span> Int numEventPacketBufs  = 2;
   475    
   476        <span class="xdoc">/*!
</span>   477    <span class="xdoc">     *  ======== maxCtrlPacketSize  ========
</span>   478    <span class="xdoc">     *  Size of control message packets in bytes
</span>   479    <span class="xdoc">     *
</span>   480    <span class="xdoc">     *  This size includes the UIAPacket header. This value's default
</span>   481    <span class="xdoc">     *  depends on the device.
</span>   482    <span class="xdoc">     */</span>
   483        <span class=key>config</span> SizeT maxCtrlPacketSize;
   484    
   485        <span class="xdoc">/*!
</span>   486    <span class="xdoc">     *  ======== numOutgoingCtrlPacketBufs  ========
</span>   487    <span class="xdoc">     *  Number of outgoing Ctrl buffers on the processor
</span>   488    <span class="xdoc">     */</span>
   489        <span class=key>config</span> Int numOutgoingCtrlPacketBufs  = 2;
   490    
   491        <span class="xdoc">/*!
</span>   492    <span class="xdoc">     *  ======== numIncomingCtrlPacketBufs  ========
</span>   493    <span class="xdoc">     *  Number of incoming Ctrl buffers on the master processor
</span>   494    <span class="xdoc">     */</span>
   495        <span class=key>config</span> Int numIncomingCtrlPacketBufs  = 2;
   496    
   497        <span class="xdoc">/*!
</span>   498    <span class="xdoc">     *  ======== supportControl ========
</span>   499    <span class="xdoc">     *  Configure whether control messages are supported.
</span>   500    <span class="xdoc">     *
</span>   501    <span class="xdoc">     *  Default is determined based on the device and transport type.
</span>   502    <span class="xdoc">     *
</span>   503    <span class="xdoc">     *  The application should only set this if {<b>@link</b> #transportType}
</span>   504    <span class="xdoc">     *  is TransportType_USER and it is plugging in a new set
</span>   505    <span class="xdoc">     *  of transport functions. The transport function package should
</span>   506    <span class="xdoc">     *  specify how to set this parameter.
</span>   507    <span class="xdoc">     */</span>
   508        <span class=key>config</span> Bool supportControl;
   509    
   510        <span class="xdoc">/*!
</span>   511    <span class="xdoc">     *  ======== transferAgentPriority ========
</span>   512    <span class="xdoc">     *  Priority of the Transfer Agent Task.
</span>   513    <span class="xdoc">     *
</span>   514    <span class="xdoc">     *  Default is 1, the lowest priority.
</span>   515    <span class="xdoc">     */</span>
   516        <span class=key>config</span> Int transferAgentPriority = 1;
   517    
   518        <span class="xdoc">/*!
</span>   519    <span class="xdoc">     *  ======== transferAgentStackSize ========
</span>   520    <span class="xdoc">     *  Transfer Agent Task stack size in MAUs.
</span>   521    <span class="xdoc">     *
</span>   522    <span class="xdoc">     *  The recommended size is 2048 bytes.
</span>   523    <span class="xdoc">     */</span>
   524        <span class=key>config</span> SizeT transferAgentStackSize = 2048;
   525    
   526        <span class="xdoc">/*!
</span>   527    <span class="xdoc">     *  ======== transferAgentStackSection ========
</span>   528    <span class="xdoc">     *  Memory section for Transfer Agent Task's stack.
</span>   529    <span class="xdoc">     *
</span>   530    <span class="xdoc">     *  If this parameter is not set then the Task.defaultStackSection is used.
</span>   531    <span class="xdoc">     *  See the Task module for instructions on creating a stack section in
</span>   532    <span class="xdoc">     *  a different memory segment.
</span>   533    <span class="xdoc">     */</span>
   534        <span class=key>metaonly</span> <span class=key>config</span> String transferAgentStackSection = <span class=key>null</span>;
   535    
   536        <span class="xdoc">/*!
</span>   537    <span class="xdoc">     *  ======== rxTaskPriority ========
</span>   538    <span class="xdoc">     *  Priority of the Transfer Agent Task.
</span>   539    <span class="xdoc">     *
</span>   540    <span class="xdoc">     *  Default is 1, the lowest priority.
</span>   541    <span class="xdoc">     */</span>
   542        <span class=key>config</span> Int rxTaskPriority = 1;
   543    
   544        <span class="xdoc">/*!
</span>   545    <span class="xdoc">     *  ======== rxTaskStackSize ========
</span>   546    <span class="xdoc">     *  Transfer Agent Task stack size in MAUs.
</span>   547    <span class="xdoc">     *
</span>   548    <span class="xdoc">     *  The recommended size is 2048 bytes.
</span>   549    <span class="xdoc">     */</span>
   550        <span class=key>config</span> SizeT rxTaskStackSize = 2048;
   551    
   552        <span class="xdoc">/*!
</span>   553    <span class="xdoc">     *  ======== rxTaskStackSection ========
</span>   554    <span class="xdoc">     *  Memory section for Receiving Task's stack.
</span>   555    <span class="xdoc">     *
</span>   556    <span class="xdoc">     *  If this parameter is not set then the Task.defaultStackSection is used.
</span>   557    <span class="xdoc">     *  See the Task module for instructions on creating a stack section in
</span>   558    <span class="xdoc">     *  a different memory segment.
</span>   559    <span class="xdoc">     */</span>
   560        <span class=key>metaonly</span> <span class=key>config</span> String rxTaskStackSection = <span class=key>null</span>;
   561    
   562        <span class="xdoc">/*!
</span>   563    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   564    <span class="xdoc">     *  ======== SupportProxy ========
</span>   565    <span class="xdoc">     *  The implementation module of the low-level ServiceMgr functions
</span>   566    <span class="xdoc">     */</span>
   567        <span class=key>proxy</span> SupportProxy <span class=key>inherits</span> IServiceMgrSupport;
   568    
   569        <span class="xdoc">/*!
</span>   570    <span class="xdoc">     *  ======== masterProcId ========
</span>   571    <span class="xdoc">     *  Processor that communicates to the instrumentation host
</span>   572    <span class="xdoc">     *
</span>   573    <span class="xdoc">     *  This value denotes which core in a multiple core topology is
</span>   574    <span class="xdoc">     *  the master core. All routing of UIA data to the instrumentation
</span>   575    <span class="xdoc">     *  host is done via this core.
</span>   576    <span class="xdoc">     *
</span>   577    <span class="xdoc">     *  The procId corresponds to Ipc's MultiProc value.
</span>   578    <span class="xdoc">     *
</span>   579    <span class="xdoc">     *  For single processor systems, or where there is no routing of
</span>   580    <span class="xdoc">     *  data via an intermediate core, this value is ignored.
</span>   581    <span class="xdoc">     */</span>
   582        <span class=key>config</span> UInt16 masterProcId = 0;
   583    
   584        <span class="xdoc">/*!
</span>   585    <span class="xdoc">     *  ======== freePacket ========
</span>   586    <span class="xdoc">     *  Function to return an unused packet back to the ServiceMgr module
</span>   587    <span class="xdoc">     *
</span>   588    <span class="xdoc">     *  This function can be used to return an unused packet back to the
</span>   589    <span class="xdoc">     *  ServiceMgr module. It must only return packets that were obtained via
</span>   590    <span class="xdoc">     *  the {<b>@link</b> #getFreePacket} function.
</span>   591    <span class="xdoc">     *
</span>   592    <span class="xdoc">     *  <b>@param(packet)</b>  Pointer to a UIAPacket
</span>   593    <span class="xdoc">     */</span>
   594        Void freePacket(UIAPacket.Hdr *packet);
   595    
   596        <span class="xdoc">/*!
</span>   597    <span class="xdoc">     *  ======== getFreePacket ========
</span>   598    <span class="xdoc">     *  Function to obtain a free UIA packet
</span>   599    <span class="xdoc">     *
</span>   600    <span class="xdoc">     *  The service can specify what type of packet it wants with the
</span>   601    <span class="xdoc">     *  first parameter. Currently only UIAPacket_HdrType_Msg and
</span>   602    <span class="xdoc">     *  UIAPacket_HdrType_EventPkt are supported.
</span>   603    <span class="xdoc">     *
</span>   604    <span class="xdoc">     *  The function fills in the HdrType field of the packet automatically
</span>   605    <span class="xdoc">     *  for the service. All other fields are un-initialized.
</span>   606    <span class="xdoc">     *
</span>   607    <span class="xdoc">     *  <b>@param(type)</b>    Requested type of packet
</span>   608    <span class="xdoc">     *  <b>@param(timeout)</b> Return after this many system time units
</span>   609    <span class="xdoc">     *
</span>   610    <span class="xdoc">     *  <b>@b(returns)</b>     Pointer to a packet if successful. NULL if timeout.
</span>   611    <span class="xdoc">     */</span>
   612        UIAPacket.Hdr *getFreePacket(UIAPacket.HdrType type, UInt timeout);
   613    
   614        <span class="xdoc">/*!
</span>   615    <span class="xdoc">     *  ======== getNumServices ========
</span>   616    <span class="xdoc">     *  Returns the number of services present in the system
</span>   617    <span class="xdoc">     *
</span>   618    <span class="xdoc">     *  <b>@b(returns)</b>     Number of services
</span>   619    <span class="xdoc">     */</span>
   620        Int getNumServices();
   621    
   622        <span class="xdoc">/*!
</span>   623    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   624    <span class="xdoc">     *  ======== processCallback ========
</span>   625    <span class="xdoc">     *  Callback function called by the support proxy
</span>   626    <span class="xdoc">     *
</span>   627    <span class="xdoc">     *  This function is called by the support proxy when it needs to
</span>   628    <span class="xdoc">     *  call a service's ProcessCallback function.
</span>   629    <span class="xdoc">     *
</span>   630    <span class="xdoc">     *  This function should not be called by a service.
</span>   631    <span class="xdoc">     *
</span>   632    <span class="xdoc">     *  <b>@param(id)</b>      Service id of the service
</span>   633    <span class="xdoc">     *  <b>@param(reason)</b>  Reason for calling the service's ProcessCallback
</span>   634    <span class="xdoc">     *                  function
</span>   635    <span class="xdoc">     *  <b>@param(packet)</b>  If the reason is {<b>@link</b> #Reason_INCOMINGMSG}, this
</span>   636    <span class="xdoc">     *                  parameter points to the incoming msg. Otherwise it is
</span>   637    <span class="xdoc">     *                  NULL. The service does not own this packet. It should
</span>   638    <span class="xdoc">     *                  NOT re-use it. Internally the ServiceMgr module will
</span>   639    <span class="xdoc">     *                  return it to an internal queue after the
</span>   640    <span class="xdoc">     *                  processCallback returns.
</span>   641    <span class="xdoc">     */</span>
   642        Void processCallback(ServiceId id, Reason reason, UIAPacket.Hdr *packet);
   643    
   644        <span class="xdoc">/*!
</span>   645    <span class="xdoc">     *  ======== register ========
</span>   646    <span class="xdoc">     *  Register a services with the ServiceMgr module
</span>   647    <span class="xdoc">     *
</span>   648    <span class="xdoc">     *  All service's must register with the ServiceMgr module statically.
</span>   649    <span class="xdoc">     *
</span>   650    <span class="xdoc">     *  Refer to {<b>@link</b> #periodInMs} for a description of the period parameter.
</span>   651    <span class="xdoc">     *
</span>   652    <span class="xdoc">     *  <b>@param(id)</b>      Service id of the service (refer to
</span>   653    <span class="xdoc">     *                  {<b>@link</b> #ServiceId}).
</span>   654    <span class="xdoc">     *
</span>   655    <span class="xdoc">     *  <b>@param(processCallbackFxn)</b>  Service's callback function.
</span>   656    <span class="xdoc">     *
</span>   657    <span class="xdoc">     *  <b>@param(periodInMs)</b> Period of the service.
</span>   658    <span class="xdoc">     */</span>
   659        <span class=key>metaonly</span> Int register(ServiceId id, ProcessCallback processCallbackFxn,
   660                              UInt32 periodInMs);
   661    
   662        <span class="xdoc">/*!
</span>   663    <span class="xdoc">     *  ======== requestEnergy ========
</span>   664    <span class="xdoc">     *  Function to request energy for a service
</span>   665    <span class="xdoc">     *
</span>   666    <span class="xdoc">     *  Generally services do not maintain an active thread.
</span>   667    <span class="xdoc">     *  They may request the ServiceMgr module to call the
</span>   668    <span class="xdoc">     *  {<b>@link</b> #ProcessCallback} in the context of the transfer agent.
</span>   669    <span class="xdoc">     *  This can be accomplished via this function.
</span>   670    <span class="xdoc">     *
</span>   671    <span class="xdoc">     *  <b>@param(id)</b>     Service id of the service
</span>   672    <span class="xdoc">     */</span>
   673        Void requestEnergy(ServiceId id);
   674    
   675        <span class="xdoc">/*!
</span>   676    <span class="xdoc">     *  ======== sendPacket ========
</span>   677    <span class="xdoc">     *  Send a UIAPacket to the instrumentation host
</span>   678    <span class="xdoc">     *
</span>   679    <span class="xdoc">     *  All UIAPacket fields except for SenderAdrs must be filled in.
</span>   680    <span class="xdoc">     *
</span>   681    <span class="xdoc">     *  The caller loses ownership of the packet once it is successfully sent.
</span>   682    <span class="xdoc">     *  If this function fails, the caller still owns the packet. It can re-use
</span>   683    <span class="xdoc">     *  it or free it via the {<b>@link</b> #freePacket} function.
</span>   684    <span class="xdoc">     *
</span>   685    <span class="xdoc">     *  <b>@param(packet)</b>  UIAPacket to be sent
</span>   686    <span class="xdoc">     *
</span>   687    <span class="xdoc">     *  <b>@b(returns)</b>     TRUE denotes success and the packet is
</span>   688    <span class="xdoc">     *                  no longer owned by the caller. FALSE denotes
</span>   689    <span class="xdoc">     *                  failure and the packet is still owned by the caller.
</span>   690    <span class="xdoc">     */</span>
   691        Bool sendPacket(UIAPacket.Hdr *packet);
   692    
   693        <span class="xdoc">/*!
</span>   694    <span class="xdoc">     *  ======== setPeriod ========
</span>   695    <span class="xdoc">     *  Allows services to set their event collection period
</span>   696    <span class="xdoc">     *
</span>   697    <span class="xdoc">     *  ServiceMgr's period should be a multiple of the ServiceMgr's period
</span>   698    <span class="xdoc">     *  ({<b>@link</b> #periodInMs}). If it is not, they will called at the rounded
</span>   699    <span class="xdoc">     *  up period. For example, if ServiceMgr.periodInMs = 100 and a service sets
</span>   700    <span class="xdoc">     *  its period to 250. That service will be called every 300 milliseconds.
</span>   701    <span class="xdoc">     *
</span>   702    <span class="xdoc">     *  <b>@param(id)</b>         Service id of the service
</span>   703    <span class="xdoc">     *
</span>   704    <span class="xdoc">     *  <b>@param(periodInMs)</b> Requested period in milliseconds
</span>   705    <span class="xdoc">     */</span>
   706        Void setPeriod(ServiceId id, UInt32 periodInMs);
   707    
   708    <span class=key>internal</span>:
   709    
   710        <span class="xdoc">/*!
</span>   711    <span class="xdoc">     *  ======== ServiceMgr Information ========
</span>   712    <span class="xdoc">     *  The following arrays contain information about each service
</span>   713    <span class="xdoc">     */</span>
   714        <span class=key>config</span> ProcessCallback processCallbackFxn[];
   715    
   716        <span class=key>struct</span> Module_State {
   717            Int runCount;
   718            Int numServices;
   719        };
   720    }
</pre>
</body></html>
